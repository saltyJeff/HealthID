{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/compressjs/lib/Util.js","webpack:///./node_modules/compressjs/lib/Stream.js","webpack:///./node_modules/riot/riot.js","webpack:///./node_modules/compressjs/lib/RangeCoder.js","webpack:///./node_modules/compressjs/lib/freeze.js","webpack:///./node_modules/compressjs/lib/BitStream.js","webpack:///./node_modules/compressjs/lib/NoModel.js","webpack:///./node_modules/compressjs/lib/FenwickModel.js","webpack:///./node_modules/compressjs/lib/LogDistanceModel.js","webpack:///./node_modules/compressjs/lib/DefSumModel.js","webpack:///./node_modules/compressjs/lib/Huffman.js","webpack:///./node_modules/compressjs/lib/Context1Model.js","webpack:///./node_modules/compressjs/lib/BWT.js","webpack:///./src/edit/person-edit.tag","webpack:///./node_modules/compressjs/lib/MTFModel.js","webpack:///./node_modules/base64-js/index.js","webpack:///./node_modules/buffer/index.js","webpack:///./src/patientcoder.js","webpack:///./src/edit/info-edit.tag","webpack:///./src/edit/conditions-edit.tag","webpack:///./src/edit/contacts-edit.tag","webpack:///./src/edit/app-edit.tag","webpack:///./node_modules/compressjs/lib/Simple.js","webpack:///./node_modules/compressjs/lib/PPM.js","webpack:///./node_modules/compressjs/lib/Lzp3.js","webpack:///./node_modules/compressjs/lib/LzjbR.js","webpack:///./node_modules/compressjs/lib/Lzjb.js","webpack:///./node_modules/compressjs/lib/Dmc.js","webpack:///./node_modules/compressjs/lib/HuffmanAllocator.js","webpack:///./node_modules/compressjs/lib/CRC32.js","webpack:///./node_modules/compressjs/lib/Bzip2.js","webpack:///./node_modules/compressjs/lib/BWTC.js","webpack:///./node_modules/process/browser.js","webpack:///./node_modules/compressjs/main.js","webpack:///./node_modules/isarray/index.js","webpack:///./node_modules/ieee754/index.js","webpack:///(webpack)/buildin/global.js","webpack:///./src/view/conditions-view.tag","webpack:///./src/view/contacts-view.tag","webpack:///./src/view/app-view.tag","webpack:///./src/index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","process","Buffer","freeze","Stream","Util","create","EOF","coerceInputStream","input","forceRead","readByte","ch","this","_eof","size","seek","pos","tell","bind","buffer","length","read","buf","bufOffset","bytesRead","eof","BufferStream","resizeOk","writeByte","_byte","newBuffer","makeU8Buffer","set","getBuffer","TypeError","subarray","coerceOutputStream","output","stream","retval","console","assert","compressFileHelper","magic","guts","suppressFinalByte","inStream","outStream","props","fileSize","charCodeAt","tmpOutput","writeUnsignedNumber","decompressFileHelper","Error","readUnsignedNumber","compressWithModel","model","inSize","encode","decompressWithModel","outSize","decode","bytes","push","Math","floor","zerofill","a","len","fallbackarray","Array","ensureZeroed","some","Uint32Array","x","Uint8Array","b","fill","makeU16Buffer","Uint16Array","makeU32Buffer","makeS32Buffer","Int32Array","arraycopy","dst","src","bytemsb","fls","v","log2c","write","flush","$","selector","ctx","document","querySelector","styleNode","cssTextProp","__TAGS_CACHE","__TAG_IMPL","YIELD_TAG","GLOBAL_MIXIN","ATTRS_PREFIX","REF_DIRECTIVES","IS_DIRECTIVE","CONDITIONAL_DIRECTIVE","LOOP_DIRECTIVE","LOOP_NO_REORDER_DIRECTIVE","SHOW_DIRECTIVE","HIDE_DIRECTIVE","KEY_DIRECTIVE","RIOT_EVENTS_KEY","T_STRING","T_OBJECT","T_UNDEF","T_FUNCTION","XLINK_NS","SVG_NS","XLINK_REGEX","WIN","window","undefined","RE_EVENTS_PREFIX","RE_HTML_ATTRS","CASE_SENSITIVE_ATTRIBUTES","viewbox","preserveaspectratio","RE_BOOL_ATTRS","IE_VERSION","documentMode","makeElement","createElementNS","createElement","setAttribute","dom","val","xlink","exec","setAttributeNS","newNode","userNode","byName","remainder","needsInject","id","parentNode","replaceChild","head","appendChild","styleSheet","styleManager","add","css","inject","style","keys","map","k","concat","join","cssText","innerHTML","skipRegex","beforeReChars","beforeReWords","wordsLastChar","reduce","w","slice","RE_REGEX","RE_VN_CHAR","prev","code","test","start","re","lastIndex","match","next","indexOf","end","brackets","UNDEF","_regex","_settings","REGLOB","R_STRINGS","S_QBLOCKS","source","UNSUPPORTED","RegExp","NEED_ESCAPE","S_QBLOCK2","FINDBRACES","(","[","{","DEFAULT","_pairs","cachedBrackets","_cache","_loopback","_rewrite","bp","replace","global","_create","pair","arr","split","_brackets","reOrIdx","_reset","str","tmpl","_bp","isexpr","mark","parts","qblocks","prevStr","index","rech","ix","pushQBlock","unescapeStr","_pos","_lastIndex","slash","hasExpr","loopKeys","expr","key","trim","array","settings","riot","R_MLCOMMS","_tmpl","data","RE_DQUOTE","qstr","j","list","_parseExpr","RE_QBMARK","_","_getTmpl","Function","err","riotData","tagName","__","_riot_id","errorHandler","error","message","log","clearCache","RE_CSNAME","RE_BREND","asText","cnt","jsb","rightContext","skipBraces","_wrapExpr","mm","lv","ir","JS_CONTEXT","JS_VARNAME","JS_NOPROPS","tb","mvar","version","observable","el","callbacks","defineProperties","on","event","fn","writable","off","cb","splice","one","apply","arguments","trigger","fns","arguments$1","arglen","args","getPropDescriptor","getOwnPropertyDescriptor","isUndefined","isWritable","obj","descriptor","extend","skipAnonymousTags","autoUpdate","$$","querySelectorAll","createDOMPlaceholder","createTextNode","toggleVisibility","show","display","hidden","getAttribute","removeAttribute","setInnerHTML","container","html","isSvg","node","ownerDocument","importNode","DOMParser","parseFromString","documentElement","walkAttributes","toLowerCase","createFragment","createDocumentFragment","safeInsert","root","curr","insertBefore","styleObjectToString","acc","prop","walkNodes","context","res","firstChild","nextSibling","mkEl","setAttr","getAttr","remAttr","walkAttrs","createFrag","isNil","isBlank","isFunction","isObject","owner","ownerSVGElement","isArray","isBoolAttr","isString","check","contains","item","each","startsWith","uid","define","options","toCamel","toUpperCase","warn","misc","objectCreate","arrayishAdd","ensureArray","dest","isArr","hasIndex","oldIndex","getName","skipDataIs","child","namedTag","inheritParentProps","parent","reHasYield","reYieldAll","reYieldSrc","reYieldDest","rootEls","tr","th","td","col","tblTags","GENERIC","SVG","mkdom","ref","text","def","replaceYield","select","selectedIndex","tname","childElementCount","specialTags","getImmediateCustomParent","tag","ptag","isAnonymous","setEventHandler","handler","eventName","e","currentTarget","target","srcElement","which","charCode","keyCode","preventUpdate","isMounted","update","listeners","removeEventListener","addEventListener","initChild","opts","createTag","tags","arrayishRemove","makeVirtual","sib","tail","frag","virts","makeReplaceVirtual","updateExpression","attrName","normalizeAttrName","attr","isToggle","isVirtual","isStyleAttr","isClassAttr","wasCreated","mount","hasValue","isObj","JSON","stringify","wasParsedOnce","bool","isRtag","_tag","unmount","impl","attrs","onUnmount","delName","dataIs","updateDataIs","nodeValue","expressions","updateOpts","isLoop","instAttrs","query","filter","t","Tag","onCreate","class","constructor","mount$1","tag2","elem","allTags","nodeList","_el","pushTagsTo","riotTag","mixins","globals","mixins_id","mixin","mix","g","store","update$1","unregister","core","moveChild","newPos","moveVirtual","mkitem","base","remove","_each","hasKeys","mustReorder","keyAttr","hasKeyAttrExpr","placeholder","ifExpr","oldItems","removeChild","items","tmpItems","_item","itemId","originalItem","keyedItem","getItemId","doReorder","oldPos","isNew","mustAppend","mustCreate","cloneNode","nextTag","this$1","unmountRedundant","RefExpr","init","attrValue","rawValue","hasExp","old","customParent","tagOrDom","__ref","refs","createRefDirective","unmountAll","IfExpr","stub","pristine","current","parseExpressions","createIfDirective","mustIncludeRoot","tagImpl","type","nodeType","attributes","parentElement","outerHTML","parseAttributes","setMountState","conf","skipAnonymous","isInline","implAttrs","nextOpts","canTrigger","shouldUpdate","componentUpdate","tag$$1","instance","propsBlacklist","proto","getPrototypeOf","getOwnPropertyNames","hasGetterSetter","isPrototypeOf","globalMixin","componentMount","mustKeepRoot","tagIndex","forEach","tagUnmount","implClass","_innerHTML","getTagName","mountTo","selectTags","getTag","initChildTag","moveChildTag","getImmediateCustomParentTag","settings$1","util","vdom","Tag$1","tag$1","tag2$1","mount$2","mixin$1","update$2","unregister$1","observable$2","riot$1","default","factory","Top_value","pow","CODE_BITS","Bottom_value","MAX_INT","RangeCoder","low","range","help","bytecount","enc_normalize","rc","outputStream","encodeStart","initlength","encodeFreq","sy_f","lt_f","tot_f","tmp","encodeShift","shift","encodeBit","encodeByte","encodeShort","encodeFinish","decodeStart","skipInitialRead","dec_normalize","inputStream","decodeCulFreq","decodeCulShift","decodeUpdate","decodeBit","decodeByte","decodeShort","decodeFinish","writeBit","readBit","BitStream","bufferByte","bit","seekBit","n_byte","n_bit","readBits","tellBit","writeBits","high","NoModel","bitstream","bits","symbol","MAGIC","compressFile","decompressFile","FenwickModel","coder","max_prob","increment","numSyms","tree","_sumTree","clone","newModel","mask","_rescale","_decode","isEscape","prob","leftProb","noEscape","finalByte","LogDistanceModel","extraStates","lgDistanceModelFactory","lengthBitsModelFactory","lgDistanceModel","distanceModel","numBits","distance","lgDistance","rest","DefSumModel","isDecoder","ESCAPE","escape","updateCount","updateThresh","PROB_TOTAL","probToSym","escProbToSym","_update","cumProb","cumEscProb","odd","newProb","probLimit","escProbLimit","HTable","up","down","weight","htable","Huffman","max_weight","table","esc","leader","slide","swap","scale","sendid","max","empty","idx","emit","readid","alphabetSize","huff","Context1Model","modelFactory","contextSize","literalModel","lastchar","modelp","ASSERT","getCounts","T","C","getBuckets","B","sum","SA_IS","SA","fs","isbwt","RA","q","newfs","c0","c1","pidx","flags","LMSsort","plen","qlen","diff","LMSpostproc","computeBWT","induceSA","BWT","suffixsort","BYTES_PER_ELEMENT","bwtransform","U","A","unbwtransform","LF","bwtransform2","TT","self","person","handleNumber","substr","NUMERIC_SORT","MTFModel","betterEscape","sym","seenSyms","sortedSeen","sort","total","seen","byteLength","b64","placeHoldersCount","toByteArray","placeHolders","Arr","L","revLookup","fromByteArray","uint8","extraBytes","len2","encodeChunk","lookup","num","base64","ieee754","kMaxLength","TYPED_ARRAY_SUPPORT","createBuffer","that","RangeError","__proto__","arg","encodingOrOffset","allocUnsafe","from","ArrayBuffer","byteOffset","fromArrayLike","fromArrayBuffer","string","encoding","isEncoding","actual","fromString","isBuffer","checked","copy","fromObject","assertSize","toString","isView","loweredCase","utf8ToBytes","base64ToBytes","bidirectionalIndexOf","dir","isNaN","arrayIndexOf","lastIndexOf","indexSize","arrLength","valLength","String","readUInt16BE","foundIndex","found","hexWrite","offset","Number","remaining","strLen","parsed","parseInt","utf8Write","blitBuffer","asciiWrite","byteArray","asciiToBytes","latin1Write","base64Write","ucs2Write","units","hi","lo","utf16leToBytes","base64Slice","utf8Slice","min","secondByte","thirdByte","fourthByte","tempCodePoint","firstByte","codePoint","bytesPerSequence","codePoints","MAX_ARGUMENTS_LENGTH","fromCharCode","decodeCodePointsArray","SlowBuffer","alloc","INSPECT_MAX_BYTES","foo","typedArraySupport","poolSize","_augment","Symbol","species","allocUnsafeSlow","_isBuffer","compare","y","swap16","swap32","swap64","hexSlice","asciiSlice","latin1Slice","utf16leSlice","equals","inspect","thisStart","thisEnd","thisCopy","targetCopy","includes","isFinite","toJSON","_arr","ret","out","toHex","checkOffset","ext","checkInt","objectWriteUInt16","littleEndian","objectWriteUInt32","checkIEEE754","writeFloat","noAssert","writeDouble","newBuf","sliceLen","readUIntLE","mul","readUIntBE","readUInt8","readUInt16LE","readUInt32LE","readUInt32BE","readIntLE","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","writeUIntLE","writeUIntBE","writeUInt8","writeUInt16LE","writeUInt16BE","writeUInt32LE","writeUInt32BE","writeIntLE","limit","sub","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","targetStart","INVALID_BASE64_RE","Infinity","leadSurrogate","stringtrim","base64clean","algorithm","Lzp3","base64js","makePatient","decompressed","TextDecoder","compressed","jsonStr","parse","makeString","patient","TextEncoder","conditions","delCondition","addPerson","people","delPerson","selected","patientcoder","route","getElementById","click","phone","contacts","info","submitPatient","Simple","encoder","block","counts","blockLength","sawEOF","readBlock","decoder","blocksize","cf","Window","firstPass","put","PPM","contexts","Cm1Context","exclude","cm1coder","DenseMTFModel","refcount","incr","ex_sy_f","ex_seen","ex_lt_f","ex_tot_f","DMM_INCREMENT","newContext","initialSymbol","newExclude","result","cc","contextString","matchLevel","maxSize","ctxt4","ctxt3","ctxt2","getIndex","matchLen","h4","h3","h2","coderFactory","sparseCoderFactory","noCoderFactory","huffLiteral","huffLen","MAX_MATCH_LEN","matchContext","prevMatchLen","WINDOW_SIZE","context1","finish","use_huffman_code","LzjbR","cpy","mlen","hash","hp","lempel","LEMPEL_SIZE","EXPAND","round","OFFSET_MASK","windowpos","winput","unbuffer","pop","unget","matchpossibility","noModelFactory","sparseModelFactory","lenModel","posModel","lastChar","lastOffset","initialPos","c2","c3","w1","w2","w3","c4","last","Lzjb","outwindow","outpos","dumpout","copymask","copymap","Dmc","MarkovNode","optModel","count","MarkovModel","MIN_CNT1","MIN_CNT2","nodes","maybeSplit","to","trans_cnt","next_cnt","first","nodesToMove","temp","allocateHuffmanCodeLengths","maximumLength","headNode","tailNode","topNode","setExtendedParentPointers","nodesToRelocate","currentDepth","currentNode","findNodesToRelocate","availableNodes","lastNode","firstNode","nextNode","allocateNodeLengths","insertDepth","nodesLeftToMove","allocateNodeLengthsWithRelocation","crc32Lookup","crc","getCRC","updateCRC","updateCRCRun","CRC32","HuffmanAllocator","mtf","Err","OK","LAST_BLOCK","NOT_BZIP_DATA","UNEXPECTED_INPUT_EOF","UNEXPECTED_OUTPUT_EOF","DATA_ERROR","OUT_OF_MEMORY","OBSOLETE_INPUT","END_OF_BLOCK","ErrorMessages","_throw","status","optDetail","msg","errorCode","Bunzip","writePos","writeCurrent","writeCount","_start_bunzip","_init_block","_get_next_block","blockCRC","level","reader","dbufSize","nextoutput","streamCRC","h","targetBlockCRC","origPointer","symToByte","symTotal","groupCount","nSelectors","mtfSymbol","selectors","hufGroup","symCount","groups","minLen","maxLen","MAX_HUFCODE_BITS","permute","pp","MAX_VALUE","byteCount","uc","runPos","dbufCount","dbuf","GROUP_SIZE","nextSym","run","writeRun","_read_bunzip","outputBuffer","copies","previous","outbyte","outputsize","multistream","bz","targetStreamCRC","decodeBlock","writeCopies","callback","delegate","blockSize","position","StaticHuffman","freq","mergedFreq","sortedFreq","codeLengths","computeCanonical","merged","prevLen","curLen","cost","currentLength","delta","codeLength","runLength","assignSelectors","groupSize","best","bestCost","groupCost","compressBlock","used","compact","endOfBlock","M","emitLastRun","targetGroups","ceil","groupCounts","splits","s1","s2","f","optimizeHuffmanGroups","Bzip2","blockSizeMultiplier","decompressBlock","BWTC","fast","bitModelFactory","useTree","full","blockIndicator","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","defaultClearTimeout","runTimeout","fun","setTimeout","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","drainQueue","timeout","marker","runClearTimeout","Item","noop","nextTick","title","browser","env","argv","versions","addListener","once","removeListener","removeAllListeners","prependListener","prependOnceListener","binding","cwd","chdir","umask","isLE","mLen","nBytes","eLen","eMax","eBias","nBits","NaN","rt","abs","LN2","eval","href","questionIdx","strOfInterest","substring","parsePatient","location"],"mappings":"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","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"D:\\\\Jefferson\\\\Documents\\\\Programming\\\\git\\\\HealthID\\\\html\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 42);\n","/* Some basic utilities, used in a number of places. */\n\nconst freeze = require('./freeze');\nconst Stream = require('./Stream');\n\nvar Util = Object.create(null);\nvar EOF = Stream.EOF;\n\n/* Take a buffer, array, or stream, and return an input stream. */\nUtil.coerceInputStream = function(input, forceRead) {\n    if (!('readByte' in input)) {\n        var buffer = input;\n        input = new Stream();\n        input.size = buffer.length;\n        input.pos = 0;\n        input.readByte = function() {\n            if (this.pos >= this.size) { return EOF; }\n            return buffer[this.pos++];\n        };\n        input.read = function(buf, bufOffset, length) {\n            var bytesRead = 0;\n            while (bytesRead < length && this.pos < buffer.length) {\n                buf[bufOffset++] = buffer[this.pos++];\n                bytesRead++;\n            }\n            return bytesRead;\n        };\n        input.seek = function(pos) { this.pos = pos; };\n        input.tell = function() { return this.pos; };\n        input.eof = function() { return this.pos >= buffer.length; };\n    } else if (forceRead && !('read' in input)) {\n        // wrap input if it doesn't implement read\n        var s = input;\n        input = new Stream();\n        input.readByte = function() {\n            var ch = s.readByte();\n            if (ch === EOF) { this._eof = true; }\n            return ch;\n        };\n        if ('size' in s) { input.size = s.size; }\n        if ('seek' in s) {\n            input.seek = function(pos) {\n                s.seek(pos); // may throw if s doesn't implement seek\n                this._eof = false;\n            };\n        }\n        if ('tell' in s) {\n            input.tell = s.tell.bind(s);\n        }\n    }\n    return input;\n};\n\nvar BufferStream = function(buffer, resizeOk) {\n    this.buffer = buffer;\n    this.resizeOk = resizeOk;\n    this.pos = 0;\n};\nBufferStream.prototype = Object.create(Stream.prototype);\nBufferStream.prototype.writeByte = function(_byte) {\n    if (this.resizeOk && this.pos >= this.buffer.length) {\n        var newBuffer = Util.makeU8Buffer(this.buffer.length * 2);\n        newBuffer.set(this.buffer);\n        this.buffer = newBuffer;\n    }\n    this.buffer[this.pos++] = _byte;\n};\nBufferStream.prototype.getBuffer = function() {\n    // trim buffer if needed\n    if (this.pos !== this.buffer.length) {\n        if (!this.resizeOk)\n            throw new TypeError('outputsize does not match decoded input');\n        var newBuffer = Util.makeU8Buffer(this.pos);\n        newBuffer.set(this.buffer.subarray(0, this.pos));\n        this.buffer = newBuffer;\n    }\n    return this.buffer;\n};\n\n/* Take a stream (or not) and an (optional) size, and return an\n    * output stream.  Return an object with a 'retval' field equal to\n    * the output stream (if that was given) or else a pointer at the\n    * internal Uint8Array/buffer/array; and a 'stream' field equal to\n    * an output stream to use.\n    */\nUtil.coerceOutputStream = function(output, size) {\n    var r = { stream: output, retval: output };\n    if (output) {\n        if (typeof(output)==='object' && 'writeByte' in output) {\n            return r; /* leave output alone */\n        } else if (typeof(size) === 'number') {\n            console.assert(size >= 0);\n            r.stream = new BufferStream(Util.makeU8Buffer(size), false);\n        } else { // output is a buffer\n            r.stream = new BufferStream(output, false);\n        }\n    } else {\n        r.stream = new BufferStream(Util.makeU8Buffer(16384), true);\n    }\n    Object.defineProperty(r, 'retval', {\n        get: r.stream.getBuffer.bind(r.stream)\n    });\n    return r;\n};\n\nUtil.compressFileHelper = function(magic, guts, suppressFinalByte) {\n    return function(inStream, outStream, props) {\n        inStream = Util.coerceInputStream(inStream);\n        var o = Util.coerceOutputStream(outStream, outStream);\n        outStream = o.stream;\n\n        // write the magic number to identify this file type\n        // (it better be ASCII, we're not doing utf-8 conversion)\n        var i;\n        for (i=0; i<magic.length; i++) {\n            outStream.writeByte(magic.charCodeAt(i));\n        }\n\n        // if we know the size, write it\n        var fileSize;\n        if ('size' in inStream && inStream.size >= 0) {\n            fileSize = inStream.size;\n        } else {\n            fileSize = -1; // size unknown\n        }\n        if (suppressFinalByte) {\n            var tmpOutput = Util.coerceOutputStream([]);\n            Util.writeUnsignedNumber(tmpOutput.stream, fileSize + 1);\n            tmpOutput = tmpOutput.retval;\n            for (i=0; i<tmpOutput.length-1; i++) {\n                outStream.writeByte(tmpOutput[i]);\n            }\n            suppressFinalByte = tmpOutput[tmpOutput.length-1];\n        } else {\n            Util.writeUnsignedNumber(outStream, fileSize + 1);\n        }\n\n        // call the guts to do the real compression\n        guts(inStream, outStream, fileSize, props, suppressFinalByte);\n\n        return o.retval;\n    };\n};\nUtil.decompressFileHelper = function(magic, guts) {\n    return function(inStream, outStream) {\n        inStream = Util.coerceInputStream(inStream);\n\n        // read the magic number to confirm this file type\n        // (it better be ASCII, we're not doing utf-8 conversion)\n        var i;\n        for (i=0; i<magic.length; i++) {\n            if (magic.charCodeAt(i) !== inStream.readByte()) {\n                throw new Error(\"Bad magic\");\n            }\n        }\n\n        // read the file size & create an appropriate output stream/buffer\n        var fileSize = Util.readUnsignedNumber(inStream) - 1;\n        var o = Util.coerceOutputStream(outStream, fileSize);\n        outStream = o.stream;\n\n        // call the guts to do the real decompression\n        guts(inStream, outStream, fileSize);\n\n        return o.retval;\n    };\n};\n// a helper for simple self-test of model encode\nUtil.compressWithModel = function(inStream, fileSize, model) {\n    var inSize = 0;\n    while (inSize !== fileSize) {\n        var ch = inStream.readByte();\n        if (ch === EOF) {\n            model.encode(256); // end of stream;\n            break;\n        }\n        model.encode(ch);\n        inSize++;\n    }\n};\n// a helper for simple self-test of model decode\nUtil.decompressWithModel = function(outStream, fileSize, model) {\n    var outSize = 0;\n    while (outSize !== fileSize) {\n        var ch = model.decode();\n        if (ch === 256) {\n            break; // end of stream;\n        }\n        outStream.writeByte(ch);\n        outSize++;\n    }\n};\n\n/** Write a number using a self-delimiting big-endian encoding. */\nUtil.writeUnsignedNumber = function(output, n) {\n    console.assert(n >= 0);\n    var bytes = [], i;\n    do {\n        bytes.push(n & 0x7F);\n        // use division instead of shift to allow encoding numbers up to\n        // 2^53\n        n = Math.floor( n / 128 );\n    } while (n !== 0);\n    bytes[0] |= 0x80; // mark end of encoding.\n    for (i=bytes.length-1; i>=0; i--) {\n        output.writeByte(bytes[i]); // write in big-endian order\n    }\n    return output;\n};\n\n/** Read a number using a self-delimiting big-endian encoding. */\nUtil.readUnsignedNumber = function(input) {\n    var n = 0, c;\n    while (true) {\n        c = input.readByte();\n        if (c&0x80) { n += (c&0x7F); break; }\n        // using + and * instead of << allows decoding numbers up to 2^53\n        n = (n + c) * 128;\n    }\n    return n;\n};\n\n// Compatibility thunks for Buffer/TypedArray constructors.\n\nvar zerofill = function(a) {\n    for (var i = 0, len = a.length; i < len; i++) {\n        a[i] = 0;\n    }\n    return a;\n};\n\nvar fallbackarray = function(size) {\n    return zerofill(new Array(size));\n};\n\n// Node 0.11.6 - 0.11.10ish don't properly zero fill typed arrays.\n// See https://github.com/joyent/node/issues/6664\n// Try to detect and workaround the bug.\nvar ensureZeroed = function id(a) { return a; };\nif ((typeof(process) !== 'undefined') &&\n    Array.prototype.some.call(new Uint32Array(128), function(x) {\n        return x !== 0;\n    })) {\n    //console.warn('Working around broken TypedArray');\n    ensureZeroed = zerofill;\n}\n\n/** Portable 8-bit unsigned buffer. */\nUtil.makeU8Buffer = (typeof(Uint8Array) !== 'undefined') ? function(size) {\n    // Uint8Array ought to be  automatically zero-filled\n    return ensureZeroed(new Uint8Array(size));\n} : (typeof(Buffer) !== 'undefined') ? function(size) {\n    var b = new Buffer(size);\n    b.fill(0);\n    return b;\n} : fallbackarray;\n\n/** Portable 16-bit unsigned buffer. */\nUtil.makeU16Buffer = (typeof(Uint16Array) !== 'undefined') ? function(size) {\n    // Uint16Array ought to be  automatically zero-filled\n    return ensureZeroed(new Uint16Array(size));\n} : fallbackarray;\n\n/** Portable 32-bit unsigned buffer. */\nUtil.makeU32Buffer = (typeof(Uint32Array) !== 'undefined') ? function(size) {\n    // Uint32Array ought to be  automatically zero-filled\n    return ensureZeroed(new Uint32Array(size));\n} : fallbackarray;\n\n/** Portable 32-bit signed buffer. */\nUtil.makeS32Buffer = (typeof(Int32Array) !== 'undefined') ? function(size) {\n    // Int32Array ought to be  automatically zero-filled\n    return ensureZeroed(new Int32Array(size));\n} : fallbackarray;\n\nUtil.arraycopy = function(dst, src) {\n    console.assert(dst.length >= src.length);\n    for (var i = 0, len = src.length; i < len ; i++) {\n        dst[i] = src[i];\n    }\n    return dst;\n};\n\n/** Highest bit set in a byte. */\nvar bytemsb = [\n    0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5,\n    5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7,\n    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n    7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8 /* 256 */\n];\nconsole.assert(bytemsb.length===0x100);\n/** Find last set (most significant bit).\n *  @return the last bit set in the argument.\n *          <code>fls(0)==0</code> and <code>fls(1)==1</code>. */\nvar fls = Util.fls = function(v) {\n    console.assert(v>=0);\n    if (v > 0xFFFFFFFF) { // use floating-point mojo\n        return 32 + fls(Math.floor(v / 0x100000000));\n    }\n    if ( (v & 0xFFFF0000) !== 0) {\n        if ( (v & 0xFF000000) !== 0) {\n            return 24 + bytemsb[(v>>>24) & 0xFF];\n        } else {\n            return 16 + bytemsb[v>>>16];\n        }\n    } else if ( (v & 0x0000FF00) !== 0) {\n        return 8 + bytemsb[v>>>8];\n    } else {\n        return bytemsb[v];\n    }\n};\n/** Returns ceil(log2(n)) */\nUtil.log2c = function(v) {\n    return (v===0)?-1:fls(v-1);\n};\n\nmodule.exports = freeze(Util); // ensure constants are recognized as such.\n","/** Abstract Stream interface, for byte-oriented i/o. */\nconst freeze = require('./freeze');\n\nvar EOF = -1;\n\nvar Stream = function() {\n    /* ABSTRACT */\n};\n// you must define one of read / readByte for a readable stream\nStream.prototype.readByte = function() {\n    var buf = [ 0 ];\n    var len = this.read(buf, 0, 1);\n    if (len===0) { this._eof = true; return EOF; }\n    return buf[0];\n};\nStream.prototype.read = function(buf, bufOffset, length) {\n    var ch, bytesRead = 0;\n    while (bytesRead < length) {\n        ch = this.readByte();\n        if (ch === EOF) { this._eof = true; break; }\n        buf[bufOffset+(bytesRead++)] = ch;\n    }\n    return bytesRead;\n};\n// reasonable default implementation of 'eof'\nStream.prototype.eof = function() { return !!this._eof; };\n// not all readable streams are seekable\nStream.prototype.seek = function(pos) {\n    throw new Error('Stream is not seekable.');\n};\nStream.prototype.tell = function() {\n    throw new Error('Stream is not seekable.');\n};\n// you must define one of write / writeByte for a writable stream\nStream.prototype.writeByte = function(_byte) {\n    var buf = [ _byte ];\n    this.write(buf, 0, 1);\n};\nStream.prototype.write = function(buf, bufOffset, length) {\n    var i;\n    for (i=0; i<length; i++) {\n        this.writeByte(buf[bufOffset + i]);\n    }\n    return length;\n};\n// flush will happily do nothing if you don't override it.\nStream.prototype.flush = function() { };\n\n// export EOF as a constant.\nStream.EOF = EOF;\n\nmodule.exports = freeze(Stream);\n","/* Riot v3.9.0, @license MIT */\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(factory((global.riot = {})));\n}(this, (function (exports) { 'use strict';\n\n/**\n * Shorter and fast way to select a single node in the DOM\n * @param   { String } selector - unique dom selector\n * @param   { Object } ctx - DOM node where the target of our search will is located\n * @returns { Object } dom node found\n */\nfunction $(selector, ctx) {\n  return (ctx || document).querySelector(selector)\n}\n\nvar\n  // be aware, internal usage\n  // ATTENTION: prefix the global dynamic variables with `__`\n  // tags instances cache\n  __TAGS_CACHE = [],\n  // tags implementation cache\n  __TAG_IMPL = {},\n  YIELD_TAG = 'yield',\n\n  /**\n   * Const\n   */\n  GLOBAL_MIXIN = '__global_mixin',\n\n  // riot specific prefixes or attributes\n  ATTRS_PREFIX = 'riot-',\n\n  // Riot Directives\n  REF_DIRECTIVES = ['ref', 'data-ref'],\n  IS_DIRECTIVE = 'data-is',\n  CONDITIONAL_DIRECTIVE = 'if',\n  LOOP_DIRECTIVE = 'each',\n  LOOP_NO_REORDER_DIRECTIVE = 'no-reorder',\n  SHOW_DIRECTIVE = 'show',\n  HIDE_DIRECTIVE = 'hide',\n  KEY_DIRECTIVE = 'key',\n  RIOT_EVENTS_KEY = '__riot-events__',\n\n  // for typeof == '' comparisons\n  T_STRING = 'string',\n  T_OBJECT = 'object',\n  T_UNDEF  = 'undefined',\n  T_FUNCTION = 'function',\n\n  XLINK_NS = 'http://www.w3.org/1999/xlink',\n  SVG_NS = 'http://www.w3.org/2000/svg',\n  XLINK_REGEX = /^xlink:(\\w+)/,\n\n  WIN = typeof window === T_UNDEF ? undefined : window,\n\n  // special native tags that cannot be treated like the others\n  RE_SPECIAL_TAGS = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?|opt(?:ion|group))$/,\n  RE_SPECIAL_TAGS_NO_OPTION = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?)$/,\n  RE_EVENTS_PREFIX = /^on/,\n  RE_HTML_ATTRS = /([-\\w]+) ?= ?(?:\"([^\"]*)|'([^']*)|({[^}]*}))/g,\n  // some DOM attributes must be normalized\n  CASE_SENSITIVE_ATTRIBUTES = {\n    'viewbox': 'viewBox',\n    'preserveaspectratio': 'preserveAspectRatio'\n  },\n  /**\n   * Matches boolean HTML attributes in the riot tag definition.\n   * With a long list like this, a regex is faster than `[].indexOf` in most browsers.\n   * @const {RegExp}\n   * @see [attributes.md](https://github.com/riot/compiler/blob/dev/doc/attributes.md)\n   */\n  RE_BOOL_ATTRS = /^(?:disabled|checked|readonly|required|allowfullscreen|auto(?:focus|play)|compact|controls|default|formnovalidate|hidden|ismap|itemscope|loop|multiple|muted|no(?:resize|shade|validate|wrap)?|open|reversed|seamless|selected|sortable|truespeed|typemustmatch)$/,\n  // version# for IE 8-11, 0 for others\n  IE_VERSION = (WIN && WIN.document || {}).documentMode | 0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n/**\n * Create a generic DOM node\n * @param   { String } name - name of the DOM node we want to create\n * @returns { Object } DOM node just created\n */\nfunction makeElement(name) {\n  return name === 'svg' ? document.createElementNS(SVG_NS, name) : document.createElement(name)\n}\n\n/**\n * Set any DOM attribute\n * @param { Object } dom - DOM node we want to update\n * @param { String } name - name of the property we want to set\n * @param { String } val - value of the property we want to set\n */\nfunction setAttribute(dom, name, val) {\n  var xlink = XLINK_REGEX.exec(name);\n  if (xlink && xlink[1])\n    { dom.setAttributeNS(XLINK_NS, xlink[1], val); }\n  else\n    { dom.setAttribute(name, val); }\n}\n\nvar styleNode;\n// Create cache and shortcut to the correct property\nvar cssTextProp;\nvar byName = {};\nvar remainder = [];\nvar needsInject = false;\n\n// skip the following code on the server\nif (WIN) {\n  styleNode = ((function () {\n    // create a new style element with the correct type\n    var newNode = makeElement('style');\n    // replace any user node or insert the new one into the head\n    var userNode = $('style[type=riot]');\n\n    setAttribute(newNode, 'type', 'text/css');\n    /* istanbul ignore next */\n    if (userNode) {\n      if (userNode.id) { newNode.id = userNode.id; }\n      userNode.parentNode.replaceChild(newNode, userNode);\n    } else { document.head.appendChild(newNode); }\n\n    return newNode\n  }))();\n  cssTextProp = styleNode.styleSheet;\n}\n\n/**\n * Object that will be used to inject and manage the css of every tag instance\n */\nvar styleManager = {\n  styleNode: styleNode,\n  /**\n   * Save a tag style to be later injected into DOM\n   * @param { String } css - css string\n   * @param { String } name - if it's passed we will map the css to a tagname\n   */\n  add: function add(css, name) {\n    if (name) { byName[name] = css; }\n    else { remainder.push(css); }\n    needsInject = true;\n  },\n  /**\n   * Inject all previously saved tag styles into DOM\n   * innerHTML seems slow: http://jsperf.com/riot-insert-style\n   */\n  inject: function inject() {\n    if (!WIN || !needsInject) { return }\n    needsInject = false;\n    var style = Object.keys(byName)\n      .map(function (k) { return byName[k]; })\n      .concat(remainder).join('\\n');\n    /* istanbul ignore next */\n    if (cssTextProp) { cssTextProp.cssText = style; }\n    else { styleNode.innerHTML = style; }\n  }\n}\n\n/**\n * The riot template engine\n * @version v3.0.8\n */\n\nvar skipRegex = (function () { //eslint-disable-line no-unused-vars\n\n  var beforeReChars = '[{(,;:?=|&!^~>%*/';\n\n  var beforeReWords = [\n    'case',\n    'default',\n    'do',\n    'else',\n    'in',\n    'instanceof',\n    'prefix',\n    'return',\n    'typeof',\n    'void',\n    'yield'\n  ];\n\n  var wordsLastChar = beforeReWords.reduce(function (s, w) {\n    return s + w.slice(-1)\n  }, '');\n\n  var RE_REGEX = /^\\/(?=[^*>/])[^[/\\\\]*(?:(?:\\\\.|\\[(?:\\\\.|[^\\]\\\\]*)*\\])[^[\\\\/]*)*?\\/[gimuy]*/;\n  var RE_VN_CHAR = /[$\\w]/;\n\n  function prev (code, pos) {\n    while (--pos >= 0 && /\\s/.test(code[pos])){ }\n    return pos\n  }\n\n  function _skipRegex (code, start) {\n\n    var re = /.*/g;\n    var pos = re.lastIndex = start++;\n    var match = re.exec(code)[0].match(RE_REGEX);\n\n    if (match) {\n      var next = pos + match[0].length;\n\n      pos = prev(code, pos);\n      var c = code[pos];\n\n      if (pos < 0 || ~beforeReChars.indexOf(c)) {\n        return next\n      }\n\n      if (c === '.') {\n\n        if (code[pos - 1] === '.') {\n          start = next;\n        }\n\n      } else if (c === '+' || c === '-') {\n\n        if (code[--pos] !== c ||\n            (pos = prev(code, pos)) < 0 ||\n            !RE_VN_CHAR.test(code[pos])) {\n          start = next;\n        }\n\n      } else if (~wordsLastChar.indexOf(c)) {\n\n        var end = pos + 1;\n\n        while (--pos >= 0 && RE_VN_CHAR.test(code[pos])){ }\n        if (~beforeReWords.indexOf(code.slice(pos + 1, end))) {\n          start = next;\n        }\n      }\n    }\n\n    return start\n  }\n\n  return _skipRegex\n\n})();\n\n/**\n * riot.util.brackets\n *\n * - `brackets    ` - Returns a string or regex based on its parameter\n * - `brackets.set` - Change the current riot brackets\n *\n * @module\n */\n\n/* global riot */\n\n/* istanbul ignore next */\nvar brackets = (function (UNDEF) {\n\n  var\n    REGLOB = 'g',\n\n    R_MLCOMMS = /\\/\\*[^*]*\\*+(?:[^*\\/][^*]*\\*+)*\\//g,\n\n    R_STRINGS = /\"[^\"\\\\]*(?:\\\\[\\S\\s][^\"\\\\]*)*\"|'[^'\\\\]*(?:\\\\[\\S\\s][^'\\\\]*)*'|`[^`\\\\]*(?:\\\\[\\S\\s][^`\\\\]*)*`/g,\n\n    S_QBLOCKS = R_STRINGS.source + '|' +\n      /(?:\\breturn\\s+|(?:[$\\w\\)\\]]|\\+\\+|--)\\s*(\\/)(?![*\\/]))/.source + '|' +\n      /\\/(?=[^*\\/])[^[\\/\\\\]*(?:(?:\\[(?:\\\\.|[^\\]\\\\]*)*\\]|\\\\.)[^[\\/\\\\]*)*?([^<]\\/)[gim]*/.source,\n\n    UNSUPPORTED = RegExp('[\\\\' + 'x00-\\\\x1F<>a-zA-Z0-9\\'\",;\\\\\\\\]'),\n\n    NEED_ESCAPE = /(?=[[\\]()*+?.^$|])/g,\n\n    S_QBLOCK2 = R_STRINGS.source + '|' + /(\\/)(?![*\\/])/.source,\n\n    FINDBRACES = {\n      '(': RegExp('([()])|'   + S_QBLOCK2, REGLOB),\n      '[': RegExp('([[\\\\]])|' + S_QBLOCK2, REGLOB),\n      '{': RegExp('([{}])|'   + S_QBLOCK2, REGLOB)\n    },\n\n    DEFAULT = '{ }';;;;;;;;;\n\n  var _pairs = [\n    '{', '}',\n    '{', '}',\n    /{[^}]*}/,\n    /\\\\([{}])/g,\n    /\\\\({)|{/g,\n    RegExp('\\\\\\\\(})|([[({])|(})|' + S_QBLOCK2, REGLOB),\n    DEFAULT,\n    /^\\s*{\\^?\\s*([$\\w]+)(?:\\s*,\\s*(\\S+))?\\s+in\\s+(\\S.*)\\s*}/,\n    /(^|[^\\\\]){=[\\S\\s]*?}/\n  ];\n\n  var\n    cachedBrackets = UNDEF,\n    _regex,\n    _cache = [],\n    _settings;;;;\n\n  function _loopback (re) { return re }\n\n  function _rewrite (re, bp) {\n    if (!bp) { bp = _cache; }\n    return new RegExp(\n      re.source.replace(/{/g, bp[2]).replace(/}/g, bp[3]), re.global ? REGLOB : ''\n    )\n  }\n\n  function _create (pair) {\n    if (pair === DEFAULT) { return _pairs }\n\n    var arr = pair.split(' ');\n\n    if (arr.length !== 2 || UNSUPPORTED.test(pair)) {\n      throw new Error('Unsupported brackets \"' + pair + '\"')\n    }\n    arr = arr.concat(pair.replace(NEED_ESCAPE, '\\\\').split(' '));\n\n    arr[4] = _rewrite(arr[1].length > 1 ? /{[\\S\\s]*?}/ : _pairs[4], arr);\n    arr[5] = _rewrite(pair.length > 3 ? /\\\\({|})/g : _pairs[5], arr);\n    arr[6] = _rewrite(_pairs[6], arr);\n    arr[7] = RegExp('\\\\\\\\(' + arr[3] + ')|([[({])|(' + arr[3] + ')|' + S_QBLOCK2, REGLOB);\n    arr[8] = pair;\n    return arr\n  }\n\n  function _brackets (reOrIdx) {\n    return reOrIdx instanceof RegExp ? _regex(reOrIdx) : _cache[reOrIdx]\n  }\n\n  _brackets.split = function split (str, tmpl, _bp) {\n    // istanbul ignore next: _bp is for the compiler\n    if (!_bp) { _bp = _cache; }\n\n    var\n      parts = [],\n      match,\n      isexpr,\n      start,\n      pos,\n      re = _bp[6];;;;;;\n\n    var qblocks = [];\n    var prevStr = '';\n    var mark, lastIndex;;\n\n    isexpr = start = re.lastIndex = 0;\n\n    while ((match = re.exec(str))) {\n\n      lastIndex = re.lastIndex;\n      pos = match.index;\n\n      if (isexpr) {\n\n        if (match[2]) {\n\n          var ch = match[2];\n          var rech = FINDBRACES[ch];\n          var ix = 1;\n\n          rech.lastIndex = lastIndex;\n          while ((match = rech.exec(str))) {\n            if (match[1]) {\n              if (match[1] === ch) { ++ix; }\n              else if (!--ix) { break }\n            } else {\n              rech.lastIndex = pushQBlock(match.index, rech.lastIndex, match[2]);\n            }\n          }\n          re.lastIndex = ix ? str.length : rech.lastIndex;\n          continue\n        }\n\n        if (!match[3]) {\n          re.lastIndex = pushQBlock(pos, lastIndex, match[4]);\n          continue\n        }\n      }\n\n      if (!match[1]) {\n        unescapeStr(str.slice(start, pos));\n        start = re.lastIndex;\n        re = _bp[6 + (isexpr ^= 1)];\n        re.lastIndex = start;\n      }\n    }\n\n    if (str && start < str.length) {\n      unescapeStr(str.slice(start));\n    }\n\n    parts.qblocks = qblocks;\n\n    return parts\n\n    function unescapeStr (s) {\n      if (prevStr) {\n        s = prevStr + s;\n        prevStr = '';\n      }\n      if (tmpl || isexpr) {\n        parts.push(s && s.replace(_bp[5], '$1'));\n      } else {\n        parts.push(s);\n      }\n    }\n\n    function pushQBlock(_pos, _lastIndex, slash) { //eslint-disable-line\n      if (slash) {\n        _lastIndex = skipRegex(str, _pos);\n      }\n\n      if (tmpl && _lastIndex > _pos + 2) {\n        mark = '\\u2057' + qblocks.length + '~';\n        qblocks.push(str.slice(_pos, _lastIndex));\n        prevStr += str.slice(start, _pos) + mark;\n        start = _lastIndex;\n      }\n      return _lastIndex\n    }\n  };\n\n  _brackets.hasExpr = function hasExpr (str) {\n    return _cache[4].test(str)\n  };\n\n  _brackets.loopKeys = function loopKeys (expr) {\n    var m = expr.match(_cache[9]);\n\n    return m\n      ? { key: m[1], pos: m[2], val: _cache[0] + m[3].trim() + _cache[1] }\n      : { val: expr.trim() }\n  };\n\n  _brackets.array = function array (pair) {\n    return pair ? _create(pair) : _cache\n  };\n\n  function _reset (pair) {\n    if ((pair || (pair = DEFAULT)) !== _cache[8]) {\n      _cache = _create(pair);\n      _regex = pair === DEFAULT ? _loopback : _rewrite;\n      _cache[9] = _regex(_pairs[9]);\n    }\n    cachedBrackets = pair;\n  }\n\n  function _setSettings (o) {\n    var b;\n\n    o = o || {};\n    b = o.brackets;\n    Object.defineProperty(o, 'brackets', {\n      set: _reset,\n      get: function () { return cachedBrackets },\n      enumerable: true\n    });\n    _settings = o;\n    _reset(b);\n  }\n\n  Object.defineProperty(_brackets, 'settings', {\n    set: _setSettings,\n    get: function () { return _settings }\n  });\n\n  /* istanbul ignore next: in the browser riot is always in the scope */\n  _brackets.settings = typeof riot !== 'undefined' && riot.settings || {};\n  _brackets.set = _reset;\n  _brackets.skipRegex = skipRegex;\n\n  _brackets.R_STRINGS = R_STRINGS;\n  _brackets.R_MLCOMMS = R_MLCOMMS;\n  _brackets.S_QBLOCKS = S_QBLOCKS;\n  _brackets.S_QBLOCK2 = S_QBLOCK2;\n\n  return _brackets\n\n})();\n\n/**\n * @module tmpl\n *\n * tmpl          - Root function, returns the template value, render with data\n * tmpl.hasExpr  - Test the existence of a expression inside a string\n * tmpl.loopKeys - Get the keys for an 'each' loop (used by `_each`)\n */\n\n/* istanbul ignore next */\nvar tmpl = (function () {\n\n  var _cache = {};\n\n  function _tmpl (str, data) {\n    if (!str) { return str }\n\n    return (_cache[str] || (_cache[str] = _create(str))).call(\n      data, _logErr.bind({\n        data: data,\n        tmpl: str\n      })\n    )\n  }\n\n  _tmpl.hasExpr = brackets.hasExpr;\n\n  _tmpl.loopKeys = brackets.loopKeys;\n\n  // istanbul ignore next\n  _tmpl.clearCache = function () { _cache = {}; };\n\n  _tmpl.errorHandler = null;\n\n  function _logErr (err, ctx) {\n\n    err.riotData = {\n      tagName: ctx && ctx.__ && ctx.__.tagName,\n      _riot_id: ctx && ctx._riot_id  //eslint-disable-line camelcase\n    };\n\n    if (_tmpl.errorHandler) { _tmpl.errorHandler(err); }\n    else if (\n      typeof console !== 'undefined' &&\n      typeof console.error === 'function'\n    ) {\n      console.error(err.message);\n      console.log('<%s> %s', err.riotData.tagName || 'Unknown tag', this.tmpl); // eslint-disable-line\n      console.log(this.data); // eslint-disable-line\n    }\n  }\n\n  function _create (str) {\n    var expr = _getTmpl(str);\n\n    if (expr.slice(0, 11) !== 'try{return ') { expr = 'return ' + expr; }\n\n    return new Function('E', expr + ';')    // eslint-disable-line no-new-func\n  }\n\n  var RE_DQUOTE = /\\u2057/g;\n  var RE_QBMARK = /\\u2057(\\d+)~/g;\n\n  function _getTmpl (str) {\n    var parts = brackets.split(str.replace(RE_DQUOTE, '\"'), 1);\n    var qstr = parts.qblocks;\n    var expr;\n\n    if (parts.length > 2 || parts[0]) {\n      var i, j, list = [];;;\n\n      for (i = j = 0; i < parts.length; ++i) {\n\n        expr = parts[i];\n\n        if (expr && (expr = i & 1\n\n            ? _parseExpr(expr, 1, qstr)\n\n            : '\"' + expr\n                .replace(/\\\\/g, '\\\\\\\\')\n                .replace(/\\r\\n?|\\n/g, '\\\\n')\n                .replace(/\"/g, '\\\\\"') +\n              '\"'\n\n          )) { list[j++] = expr; }\n\n      }\n\n      expr = j < 2 ? list[0]\n           : '[' + list.join(',') + '].join(\"\")';\n\n    } else {\n\n      expr = _parseExpr(parts[1], 0, qstr);\n    }\n\n    if (qstr.length) {\n      expr = expr.replace(RE_QBMARK, function (_, pos) {\n        return qstr[pos]\n          .replace(/\\r/g, '\\\\r')\n          .replace(/\\n/g, '\\\\n')\n      });\n    }\n    return expr\n  }\n\n  var RE_CSNAME = /^(?:(-?[_A-Za-z\\xA0-\\xFF][-\\w\\xA0-\\xFF]*)|\\u2057(\\d+)~):/;\n  var\n    RE_BREND = {\n      '(': /[()]/g,\n      '[': /[[\\]]/g,\n      '{': /[{}]/g\n    };\n\n  function _parseExpr (expr, asText, qstr) {\n\n    expr = expr\n      .replace(/\\s+/g, ' ').trim()\n      .replace(/\\ ?([[\\({},?\\.:])\\ ?/g, '$1');\n\n    if (expr) {\n      var\n        list = [],\n        cnt = 0,\n        match;;;\n\n      while (expr &&\n            (match = expr.match(RE_CSNAME)) &&\n            !match.index\n        ) {\n        var\n          key,\n          jsb,\n          re = /,|([[{(])|$/g;;;\n\n        expr = RegExp.rightContext;\n        key  = match[2] ? qstr[match[2]].slice(1, -1).trim().replace(/\\s+/g, ' ') : match[1];\n\n        while (jsb = (match = re.exec(expr))[1]) { skipBraces(jsb, re); }\n\n        jsb  = expr.slice(0, match.index);\n        expr = RegExp.rightContext;\n\n        list[cnt++] = _wrapExpr(jsb, 1, key);\n      }\n\n      expr = !cnt ? _wrapExpr(expr, asText)\n           : cnt > 1 ? '[' + list.join(',') + '].join(\" \").trim()' : list[0];\n    }\n    return expr\n\n    function skipBraces (ch, re) {\n      var\n        mm,\n        lv = 1,\n        ir = RE_BREND[ch];;;\n\n      ir.lastIndex = re.lastIndex;\n      while (mm = ir.exec(expr)) {\n        if (mm[0] === ch) { ++lv; }\n        else if (!--lv) { break }\n      }\n      re.lastIndex = lv ? expr.length : ir.lastIndex;\n    }\n  }\n\n  // istanbul ignore next: not both\n  var // eslint-disable-next-line max-len\n    JS_CONTEXT = '\"in this?this:' + (typeof window !== 'object' ? 'global' : 'window') + ').',\n    JS_VARNAME = /[,{][\\$\\w]+(?=:)|(^ *|[^$\\w\\.{])(?!(?:typeof|true|false|null|undefined|in|instanceof|is(?:Finite|NaN)|void|NaN|new|Date|RegExp|Math)(?![$\\w]))([$_A-Za-z][$\\w]*)/g,\n    JS_NOPROPS = /^(?=(\\.[$\\w]+))\\1(?:[^.[(]|$)/;;;\n\n  function _wrapExpr (expr, asText, key) {\n    var tb;\n\n    expr = expr.replace(JS_VARNAME, function (match, p, mvar, pos, s) {\n      if (mvar) {\n        pos = tb ? 0 : pos + match.length;\n\n        if (mvar !== 'this' && mvar !== 'global' && mvar !== 'window') {\n          match = p + '(\"' + mvar + JS_CONTEXT + mvar;\n          if (pos) { tb = (s = s[pos]) === '.' || s === '(' || s === '['; }\n        } else if (pos) {\n          tb = !JS_NOPROPS.test(s.slice(pos));\n        }\n      }\n      return match\n    });\n\n    if (tb) {\n      expr = 'try{return ' + expr + '}catch(e){E(e,this)}';\n    }\n\n    if (key) {\n\n      expr = (tb\n          ? 'function(){' + expr + '}.call(this)' : '(' + expr + ')'\n        ) + '?\"' + key + '\":\"\"';\n\n    } else if (asText) {\n\n      expr = 'function(v){' + (tb\n          ? expr.replace('return ', 'v=') : 'v=(' + expr + ')'\n        ) + ';return v||v===0?v:\"\"}.call(this)';\n    }\n\n    return expr\n  }\n\n  _tmpl.version = brackets.version = 'v3.0.8';\n\n  return _tmpl\n\n})();\n\n/* istanbul ignore next */\nvar observable = function(el) {\n\n  /**\n   * Extend the original object or create a new empty one\n   * @type { Object }\n   */\n\n  el = el || {};\n\n  /**\n   * Private variables\n   */\n  var callbacks = {},\n    slice = Array.prototype.slice;;\n\n  /**\n   * Public Api\n   */\n\n  // extend the el object adding the observable methods\n  Object.defineProperties(el, {\n    /**\n     * Listen to the given `event` ands\n     * execute the `callback` each time an event is triggered.\n     * @param  { String } event - event id\n     * @param  { Function } fn - callback function\n     * @returns { Object } el\n     */\n    on: {\n      value: function(event, fn) {\n        if (typeof fn == 'function')\n          { (callbacks[event] = callbacks[event] || []).push(fn); }\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Removes the given `event` listeners\n     * @param   { String } event - event id\n     * @param   { Function } fn - callback function\n     * @returns { Object } el\n     */\n    off: {\n      value: function(event, fn) {\n        if (event == '*' && !fn) { callbacks = {}; }\n        else {\n          if (fn) {\n            var arr = callbacks[event];\n            for (var i = 0, cb; cb = arr && arr[i]; ++i) {\n              if (cb == fn) { arr.splice(i--, 1); }\n            }\n          } else { delete callbacks[event]; }\n        }\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Listen to the given `event` and\n     * execute the `callback` at most once\n     * @param   { String } event - event id\n     * @param   { Function } fn - callback function\n     * @returns { Object } el\n     */\n    one: {\n      value: function(event, fn) {\n        function on() {\n          el.off(event, on);\n          fn.apply(el, arguments);\n        }\n        return el.on(event, on)\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Execute all callback functions that listen to\n     * the given `event`\n     * @param   { String } event - event id\n     * @returns { Object } el\n     */\n    trigger: {\n      value: function(event) {\n        var arguments$1 = arguments;\n\n\n        // getting the arguments\n        var arglen = arguments.length - 1,\n          args = new Array(arglen),\n          fns,\n          fn,\n          i;;;;;\n\n        for (i = 0; i < arglen; i++) {\n          args[i] = arguments$1[i + 1]; // skip first argument\n        }\n\n        fns = slice.call(callbacks[event] || [], 0);\n\n        for (i = 0; fn = fns[i]; ++i) {\n          fn.apply(el, args);\n        }\n\n        if (callbacks['*'] && event != '*')\n          { el.trigger.apply(el, ['*', event].concat(args)); }\n\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    }\n  });\n\n  return el\n\n};\n\n/**\n * Short alias for Object.getOwnPropertyDescriptor\n */\nfunction getPropDescriptor (o, k) {\n  return Object.getOwnPropertyDescriptor(o, k)\n}\n\n/**\n * Check if passed argument is undefined\n * @param   { * } value -\n * @returns { Boolean } -\n */\nfunction isUndefined(value) {\n  return typeof value === T_UNDEF\n}\n\n/**\n * Check whether object's property could be overridden\n * @param   { Object }  obj - source object\n * @param   { String }  key - object property\n * @returns { Boolean } true if writable\n */\nfunction isWritable(obj, key) {\n  var descriptor = getPropDescriptor(obj, key);\n  return isUndefined(obj[key]) || descriptor && descriptor.writable\n}\n\n/**\n * Extend any object with other properties\n * @param   { Object } src - source object\n * @returns { Object } the resulting extended object\n *\n * var obj = { foo: 'baz' }\n * extend(obj, {bar: 'bar', foo: 'bar'})\n * console.log(obj) => {bar: 'bar', foo: 'bar'}\n *\n */\nfunction extend(src) {\n  var obj;\n  var i = 1;\n  var args = arguments;\n  var l = args.length;\n\n  for (; i < l; i++) {\n    if (obj = args[i]) {\n      for (var key in obj) {\n        // check if this property of the source object could be overridden\n        if (isWritable(src, key))\n          { src[key] = obj[key]; }\n      }\n    }\n  }\n  return src\n}\n\n/**\n * Alias for Object.create\n */\nfunction create(src) {\n  return Object.create(src)\n}\n\nvar settings = extend(create(brackets.settings), {\n  skipAnonymousTags: true,\n  // handle the auto updates on any DOM event\n  autoUpdate: true\n})\n\n/**\n * Shorter and fast way to select multiple nodes in the DOM\n * @param   { String } selector - DOM selector\n * @param   { Object } ctx - DOM node where the targets of our search will is located\n * @returns { Object } dom nodes found\n */\nfunction $$(selector, ctx) {\n  return [].slice.call((ctx || document).querySelectorAll(selector))\n}\n\n/**\n * Create a document text node\n * @returns { Object } create a text node to use as placeholder\n */\nfunction createDOMPlaceholder() {\n  return document.createTextNode('')\n}\n\n/**\n * Toggle the visibility of any DOM node\n * @param   { Object }  dom - DOM node we want to hide\n * @param   { Boolean } show - do we want to show it?\n */\n\nfunction toggleVisibility(dom, show) {\n  dom.style.display = show ? '' : 'none';\n  dom.hidden = show ? false : true;\n}\n\n/**\n * Get the value of any DOM attribute on a node\n * @param   { Object } dom - DOM node we want to parse\n * @param   { String } name - name of the attribute we want to get\n * @returns { String | undefined } name of the node attribute whether it exists\n */\nfunction getAttribute(dom, name) {\n  return dom.getAttribute(name)\n}\n\n/**\n * Remove any DOM attribute from a node\n * @param   { Object } dom - DOM node we want to update\n * @param   { String } name - name of the property we want to remove\n */\nfunction removeAttribute(dom, name) {\n  dom.removeAttribute(name);\n}\n\n/**\n * Set the inner html of any DOM node SVGs included\n * @param { Object } container - DOM node where we'll inject new html\n * @param { String } html - html to inject\n * @param { Boolean } isSvg - svg tags should be treated a bit differently\n */\n/* istanbul ignore next */\nfunction setInnerHTML(container, html, isSvg) {\n  // innerHTML is not supported on svg tags so we neet to treat them differently\n  if (isSvg) {\n    var node = container.ownerDocument.importNode(\n      new DOMParser()\n        .parseFromString((\"<svg xmlns=\\\"\" + SVG_NS + \"\\\">\" + html + \"</svg>\"), 'application/xml')\n        .documentElement,\n      true\n    );\n\n    container.appendChild(node);\n  } else {\n    container.innerHTML = html;\n  }\n}\n\n/**\n * Minimize risk: only zero or one _space_ between attr & value\n * @param   { String }   html - html string we want to parse\n * @param   { Function } fn - callback function to apply on any attribute found\n */\nfunction walkAttributes(html, fn) {\n  if (!html) { return }\n  var m;\n  while (m = RE_HTML_ATTRS.exec(html))\n    { fn(m[1].toLowerCase(), m[2] || m[3] || m[4]); }\n}\n\n/**\n * Create a document fragment\n * @returns { Object } document fragment\n */\nfunction createFragment() {\n  return document.createDocumentFragment()\n}\n\n/**\n * Insert safely a tag to fix #1962 #1649\n * @param   { HTMLElement } root - children container\n * @param   { HTMLElement } curr - node to insert\n * @param   { HTMLElement } next - node that should preceed the current node inserted\n */\nfunction safeInsert(root, curr, next) {\n  root.insertBefore(curr, next.parentNode && next);\n}\n\n/**\n * Convert a style object to a string\n * @param   { Object } style - style object we need to parse\n * @returns { String } resulting css string\n * @example\n * styleObjectToString({ color: 'red', height: '10px'}) // => 'color: red; height: 10px'\n */\nfunction styleObjectToString(style) {\n  return Object.keys(style).reduce(function (acc, prop) {\n    return (acc + \" \" + prop + \": \" + (style[prop]) + \";\")\n  }, '')\n}\n\n/**\n * Walk down recursively all the children tags starting dom node\n * @param   { Object }   dom - starting node where we will start the recursion\n * @param   { Function } fn - callback to transform the child node just found\n * @param   { Object }   context - fn can optionally return an object, which is passed to children\n */\nfunction walkNodes(dom, fn, context) {\n  if (dom) {\n    var res = fn(dom, context);\n    var next;\n    // stop the recursion\n    if (res === false) { return }\n\n    dom = dom.firstChild;\n\n    while (dom) {\n      next = dom.nextSibling;\n      walkNodes(dom, fn, res);\n      dom = next;\n    }\n  }\n}\n\n\n\nvar dom = Object.freeze({\n\t$$: $$,\n\t$: $,\n\tcreateDOMPlaceholder: createDOMPlaceholder,\n\tmkEl: makeElement,\n\tsetAttr: setAttribute,\n\ttoggleVisibility: toggleVisibility,\n\tgetAttr: getAttribute,\n\tremAttr: removeAttribute,\n\tsetInnerHTML: setInnerHTML,\n\twalkAttrs: walkAttributes,\n\tcreateFrag: createFragment,\n\tsafeInsert: safeInsert,\n\tstyleObjectToString: styleObjectToString,\n\twalkNodes: walkNodes\n});\n\n/**\n * Check against the null and undefined values\n * @param   { * }  value -\n * @returns {Boolean} -\n */\nfunction isNil(value) {\n  return isUndefined(value) || value === null\n}\n\n/**\n * Check if passed argument is empty. Different from falsy, because we dont consider 0 or false to be blank\n * @param { * } value -\n * @returns { Boolean } -\n */\nfunction isBlank(value) {\n  return isNil(value) || value === ''\n}\n\n/**\n * Check if passed argument is a function\n * @param   { * } value -\n * @returns { Boolean } -\n */\nfunction isFunction(value) {\n  return typeof value === T_FUNCTION\n}\n\n/**\n * Check if passed argument is an object, exclude null\n * NOTE: use isObject(x) && !isArray(x) to excludes arrays.\n * @param   { * } value -\n * @returns { Boolean } -\n */\nfunction isObject(value) {\n  return value && typeof value === T_OBJECT // typeof null is 'object'\n}\n\n/**\n * Check if a DOM node is an svg tag or part of an svg\n * @param   { HTMLElement }  el - node we want to test\n * @returns {Boolean} true if it's an svg node\n */\nfunction isSvg(el) {\n  var owner = el.ownerSVGElement;\n  return !!owner || owner === null\n}\n\n/**\n * Check if passed argument is a kind of array\n * @param   { * } value -\n * @returns { Boolean } -\n */\nfunction isArray(value) {\n  return Array.isArray(value) || value instanceof Array\n}\n\n/**\n * Check if the passed argument is a boolean attribute\n * @param   { String } value -\n * @returns { Boolean } -\n */\nfunction isBoolAttr(value) {\n  return RE_BOOL_ATTRS.test(value)\n}\n\n/**\n * Check if passed argument is a string\n * @param   { * } value -\n * @returns { Boolean } -\n */\nfunction isString(value) {\n  return typeof value === T_STRING\n}\n\n\n\nvar check = Object.freeze({\n\tisBlank: isBlank,\n\tisFunction: isFunction,\n\tisObject: isObject,\n\tisSvg: isSvg,\n\tisWritable: isWritable,\n\tisArray: isArray,\n\tisBoolAttr: isBoolAttr,\n\tisNil: isNil,\n\tisString: isString,\n\tisUndefined: isUndefined\n});\n\n/**\n * Check whether an array contains an item\n * @param   { Array } array - target array\n * @param   { * } item - item to test\n * @returns { Boolean } -\n */\nfunction contains(array, item) {\n  return array.indexOf(item) !== -1\n}\n\n/**\n * Specialized function for looping an array-like collection with `each={}`\n * @param   { Array } list - collection of items\n * @param   {Function} fn - callback function\n * @returns { Array } the array looped\n */\nfunction each(list, fn) {\n  var len = list ? list.length : 0;\n  var i = 0;\n  for (; i < len; i++) { fn(list[i], i); }\n  return list\n}\n\n/**\n * Faster String startsWith alternative\n * @param   { String } str - source string\n * @param   { String } value - test string\n * @returns { Boolean } -\n */\nfunction startsWith(str, value) {\n  return str.slice(0, value.length) === value\n}\n\n/**\n * Function returning always a unique identifier\n * @returns { Number } - number from 0...n\n */\nvar uid = (function uid() {\n  var i = -1;\n  return function () { return ++i; }\n})()\n\n/**\n * Helper function to set an immutable property\n * @param   { Object } el - object where the new property will be set\n * @param   { String } key - object key where the new property will be stored\n * @param   { * } value - value of the new property\n * @param   { Object } options - set the propery overriding the default options\n * @returns { Object } - the initial object\n */\nfunction define(el, key, value, options) {\n  Object.defineProperty(el, key, extend({\n    value: value,\n    enumerable: false,\n    writable: false,\n    configurable: true\n  }, options));\n  return el\n}\n\n/**\n * Convert a string containing dashes to camel case\n * @param   { String } str - input string\n * @returns { String } my-string -> myString\n */\nfunction toCamel(str) {\n  return str.replace(/-(\\w)/g, function (_, c) { return c.toUpperCase(); })\n}\n\n/**\n * Warn a message via console\n * @param   {String} message - warning message\n */\nfunction warn(message) {\n  if (console && console.warn) { console.warn(message); }\n}\n\n\n\nvar misc = Object.freeze({\n\tcontains: contains,\n\teach: each,\n\tgetPropDescriptor: getPropDescriptor,\n\tstartsWith: startsWith,\n\tuid: uid,\n\tdefineProperty: define,\n\tobjectCreate: create,\n\textend: extend,\n\ttoCamel: toCamel,\n\twarn: warn\n});\n\n/**\n * Set the property of an object for a given key. If something already\n * exists there, then it becomes an array containing both the old and new value.\n * @param { Object } obj - object on which to set the property\n * @param { String } key - property name\n * @param { Object } value - the value of the property to be set\n * @param { Boolean } ensureArray - ensure that the property remains an array\n * @param { Number } index - add the new item in a certain array position\n */\nfunction arrayishAdd(obj, key, value, ensureArray, index) {\n  var dest = obj[key];\n  var isArr = isArray(dest);\n  var hasIndex = !isUndefined(index);\n\n  if (dest && dest === value) { return }\n\n  // if the key was never set, set it once\n  if (!dest && ensureArray) { obj[key] = [value]; }\n  else if (!dest) { obj[key] = value; }\n  // if it was an array and not yet set\n  else {\n    if (isArr) {\n      var oldIndex = dest.indexOf(value);\n      // this item never changed its position\n      if (oldIndex === index) { return }\n      // remove the item from its old position\n      if (oldIndex !== -1) { dest.splice(oldIndex, 1); }\n      // move or add the item\n      if (hasIndex) {\n        dest.splice(index, 0, value);\n      } else {\n        dest.push(value);\n      }\n    } else { obj[key] = [dest, value]; }\n  }\n}\n\n/**\n * Detect the tag implementation by a DOM node\n * @param   { Object } dom - DOM node we need to parse to get its tag implementation\n * @returns { Object } it returns an object containing the implementation of a custom tag (template and boot function)\n */\nfunction get(dom) {\n  return dom.tagName && __TAG_IMPL[getAttribute(dom, IS_DIRECTIVE) ||\n    getAttribute(dom, IS_DIRECTIVE) || dom.tagName.toLowerCase()]\n}\n\n/**\n * Get the tag name of any DOM node\n * @param   { Object } dom - DOM node we want to parse\n * @param   { Boolean } skipDataIs - hack to ignore the data-is attribute when attaching to parent\n * @returns { String } name to identify this dom node in riot\n */\nfunction getName(dom, skipDataIs) {\n  var child = get(dom);\n  var namedTag = !skipDataIs && getAttribute(dom, IS_DIRECTIVE);\n  return namedTag && !tmpl.hasExpr(namedTag) ?\n    namedTag : child ? child.name : dom.tagName.toLowerCase()\n}\n\n/**\n * Return a temporary context containing also the parent properties\n * @this Tag\n * @param { Tag } - temporary tag context containing all the parent properties\n */\nfunction inheritParentProps() {\n  if (this.parent) { return extend(create(this), this.parent) }\n  return this\n}\n\n/*\n  Includes hacks needed for the Internet Explorer version 9 and below\n  See: http://kangax.github.io/compat-table/es5/#ie8\n       http://codeplanet.io/dropping-ie8/\n*/\n\nvar\n  reHasYield  = /<yield\\b/i,\n  reYieldAll  = /<yield\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>|>)/ig,\n  reYieldSrc  = /<yield\\s+to=['\"]([^'\">]*)['\"]\\s*>([\\S\\s]*?)<\\/yield\\s*>/ig,\n  reYieldDest = /<yield\\s+from=['\"]?([-\\w]+)['\"]?\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>)/ig,\n  rootEls = { tr: 'tbody', th: 'tr', td: 'tr', col: 'colgroup' },\n  tblTags = IE_VERSION && IE_VERSION < 10 ? RE_SPECIAL_TAGS : RE_SPECIAL_TAGS_NO_OPTION,\n  GENERIC = 'div',\n  SVG = 'svg';;;;;;;;\n\n\n/*\n  Creates the root element for table or select child elements:\n  tr/th/td/thead/tfoot/tbody/caption/col/colgroup/option/optgroup\n*/\nfunction specialTags(el, tmpl, tagName) {\n\n  var\n    select = tagName[0] === 'o',\n    parent = select ? 'select>' : 'table>';;\n\n  // trim() is important here, this ensures we don't have artifacts,\n  // so we can check if we have only one element inside the parent\n  el.innerHTML = '<' + parent + tmpl.trim() + '</' + parent;\n  parent = el.firstChild;\n\n  // returns the immediate parent if tr/th/td/col is the only element, if not\n  // returns the whole tree, as this can include additional elements\n  /* istanbul ignore next */\n  if (select) {\n    parent.selectedIndex = -1;  // for IE9, compatible w/current riot behavior\n  } else {\n    // avoids insertion of cointainer inside container (ex: tbody inside tbody)\n    var tname = rootEls[tagName];\n    if (tname && parent.childElementCount === 1) { parent = $(tname, parent); }\n  }\n  return parent\n}\n\n/*\n  Replace the yield tag from any tag template with the innerHTML of the\n  original tag in the page\n*/\nfunction replaceYield(tmpl, html) {\n  // do nothing if no yield\n  if (!reHasYield.test(tmpl)) { return tmpl }\n\n  // be careful with #1343 - string on the source having `$1`\n  var src = {};\n\n  html = html && html.replace(reYieldSrc, function (_, ref, text) {\n    src[ref] = src[ref] || text;   // preserve first definition\n    return ''\n  }).trim();\n\n  return tmpl\n    .replace(reYieldDest, function (_, ref, def) {  // yield with from - to attrs\n      return src[ref] || def || ''\n    })\n    .replace(reYieldAll, function (_, def) {        // yield without any \"from\"\n      return html || def || ''\n    })\n}\n\n/**\n * Creates a DOM element to wrap the given content. Normally an `DIV`, but can be\n * also a `TABLE`, `SELECT`, `TBODY`, `TR`, or `COLGROUP` element.\n *\n * @param   { String } tmpl  - The template coming from the custom tag definition\n * @param   { String } html - HTML content that comes from the DOM element where you\n *           will mount the tag, mostly the original tag in the page\n * @param   { Boolean } isSvg - true if the root node is an svg\n * @returns { HTMLElement } DOM element with _tmpl_ merged through `YIELD` with the _html_.\n */\nfunction mkdom(tmpl, html, isSvg) {\n  var match   = tmpl && tmpl.match(/^\\s*<([-\\w]+)/);\n  var  tagName = match && match[1].toLowerCase();\n  var el = makeElement(isSvg ? SVG : GENERIC);\n\n  // replace all the yield tags with the tag inner html\n  tmpl = replaceYield(tmpl, html);\n\n  /* istanbul ignore next */\n  if (tblTags.test(tagName))\n    { el = specialTags(el, tmpl, tagName); }\n  else\n    { setInnerHTML(el, tmpl, isSvg); }\n\n  return el\n}\n\n/**\n * Loop backward all the parents tree to detect the first custom parent tag\n * @param   { Object } tag - a Tag instance\n * @returns { Object } the instance of the first custom parent tag found\n */\nfunction getImmediateCustomParent(tag) {\n  var ptag = tag;\n  while (ptag.__.isAnonymous) {\n    if (!ptag.parent) { break }\n    ptag = ptag.parent;\n  }\n  return ptag\n}\n\n/**\n * Trigger DOM events\n * @param   { HTMLElement } dom - dom element target of the event\n * @param   { Function } handler - user function\n * @param   { Object } e - event object\n */\nfunction handleEvent(dom, handler, e) {\n  var ptag = this.__.parent;\n  var item = this.__.item;\n\n  if (!item)\n    { while (ptag && !item) {\n      item = ptag.__.item;\n      ptag = ptag.__.parent;\n    } }\n\n  // override the event properties\n  /* istanbul ignore next */\n  if (isWritable(e, 'currentTarget')) { e.currentTarget = dom; }\n  /* istanbul ignore next */\n  if (isWritable(e, 'target')) { e.target = e.srcElement; }\n  /* istanbul ignore next */\n  if (isWritable(e, 'which')) { e.which = e.charCode || e.keyCode; }\n\n  e.item = item;\n\n  handler.call(this, e);\n\n  // avoid auto updates\n  if (!settings.autoUpdate) { return }\n\n  if (!e.preventUpdate) {\n    var p = getImmediateCustomParent(this);\n    // fixes #2083\n    if (p.isMounted) { p.update(); }\n  }\n}\n\n/**\n * Attach an event to a DOM node\n * @param { String } name - event name\n * @param { Function } handler - event callback\n * @param { Object } dom - dom node\n * @param { Tag } tag - tag instance\n */\nfunction setEventHandler(name, handler, dom, tag) {\n  var eventName;\n  var cb = handleEvent.bind(tag, dom, handler);\n\n  // avoid to bind twice the same event\n  // possible fix for #2332\n  dom[name] = null;\n\n  // normalize event name\n  eventName = name.replace(RE_EVENTS_PREFIX, '');\n\n  // cache the listener into the listeners array\n  if (!contains(tag.__.listeners, dom)) { tag.__.listeners.push(dom); }\n  if (!dom[RIOT_EVENTS_KEY]) { dom[RIOT_EVENTS_KEY] = {}; }\n  if (dom[RIOT_EVENTS_KEY][name]) { dom.removeEventListener(eventName, dom[RIOT_EVENTS_KEY][name]); }\n\n  dom[RIOT_EVENTS_KEY][name] = cb;\n  dom.addEventListener(eventName, cb, false);\n}\n\n/**\n * Create a new child tag including it correctly into its parent\n * @param   { Object } child - child tag implementation\n * @param   { Object } opts - tag options containing the DOM node where the tag will be mounted\n * @param   { String } innerHTML - inner html of the child node\n * @param   { Object } parent - instance of the parent tag including the child custom tag\n * @returns { Object } instance of the new child tag just created\n */\nfunction initChild(child, opts, innerHTML, parent) {\n  var tag = createTag(child, opts, innerHTML);\n  var tagName = opts.tagName || getName(opts.root, true);\n  var ptag = getImmediateCustomParent(parent);\n  // fix for the parent attribute in the looped elements\n  define(tag, 'parent', ptag);\n  // store the real parent tag\n  // in some cases this could be different from the custom parent tag\n  // for example in nested loops\n  tag.__.parent = parent;\n\n  // add this tag to the custom parent tag\n  arrayishAdd(ptag.tags, tagName, tag);\n\n  // and also to the real parent tag\n  if (ptag !== parent)\n    { arrayishAdd(parent.tags, tagName, tag); }\n\n  return tag\n}\n\n/**\n * Removes an item from an object at a given key. If the key points to an array,\n * then the item is just removed from the array.\n * @param { Object } obj - object on which to remove the property\n * @param { String } key - property name\n * @param { Object } value - the value of the property to be removed\n * @param { Boolean } ensureArray - ensure that the property remains an array\n*/\nfunction arrayishRemove(obj, key, value, ensureArray) {\n  if (isArray(obj[key])) {\n    var index = obj[key].indexOf(value);\n    if (index !== -1) { obj[key].splice(index, 1); }\n    if (!obj[key].length) { delete obj[key]; }\n    else if (obj[key].length === 1 && !ensureArray) { obj[key] = obj[key][0]; }\n  } else if (obj[key] === value)\n    { delete obj[key]; } // otherwise just delete the key\n}\n\n/**\n * Adds the elements for a virtual tag\n * @this Tag\n * @param { Node } src - the node that will do the inserting or appending\n * @param { Tag } target - only if inserting, insert before this tag's first child\n */\nfunction makeVirtual(src, target) {\n  var this$1 = this;\n\n  var head = createDOMPlaceholder();\n  var tail = createDOMPlaceholder();\n  var frag = createFragment();\n  var sib;\n  var el;\n\n  this.root.insertBefore(head, this.root.firstChild);\n  this.root.appendChild(tail);\n\n  this.__.head = el = head;\n  this.__.tail = tail;\n\n  while (el) {\n    sib = el.nextSibling;\n    frag.appendChild(el);\n    this$1.__.virts.push(el); // hold for unmounting\n    el = sib;\n  }\n\n  if (target)\n    { src.insertBefore(frag, target.__.head); }\n  else\n    { src.appendChild(frag); }\n}\n\n/**\n * makes a tag virtual and replaces a reference in the dom\n * @this Tag\n * @param { tag } the tag to make virtual\n * @param { ref } the dom reference location\n */\nfunction makeReplaceVirtual(tag, ref) {\n  var frag = createFragment();\n  makeVirtual.call(tag, frag);\n  ref.parentNode.replaceChild(frag, ref);\n}\n\n/**\n * Update dynamically created data-is tags with changing expressions\n * @param { Object } expr - expression tag and expression info\n * @param { Tag }    parent - parent for tag creation\n * @param { String } tagName - tag implementation we want to use\n */\nfunction updateDataIs(expr, parent, tagName) {\n  var tag = expr.tag || expr.dom._tag;\n  var ref;\n\n  var ref$1 = tag ? tag.__ : {};\n  var head = ref$1.head;\n  var isVirtual = expr.dom.tagName === 'VIRTUAL';\n\n  if (tag && expr.tagName === tagName) {\n    tag.update();\n    return\n  }\n\n  // sync _parent to accommodate changing tagnames\n  if (tag) {\n    // need placeholder before unmount\n    if(isVirtual) {\n      ref = createDOMPlaceholder();\n      head.parentNode.insertBefore(ref, head);\n    }\n\n    tag.unmount(true);\n  }\n\n  // unable to get the tag name\n  if (!isString(tagName)) { return }\n\n  expr.impl = __TAG_IMPL[tagName];\n\n  // unknown implementation\n  if (!expr.impl) { return }\n\n  expr.tag = tag = initChild(\n    expr.impl, {\n      root: expr.dom,\n      parent: parent,\n      tagName: tagName\n    },\n    expr.dom.innerHTML,\n    parent\n  );\n\n  each(expr.attrs, function (a) { return setAttribute(tag.root, a.name, a.value); });\n  expr.tagName = tagName;\n  tag.mount();\n\n  // root exist first time, after use placeholder\n  if (isVirtual) { makeReplaceVirtual(tag, ref || tag.root); }\n\n  // parent is the placeholder tag, not the dynamic tag so clean up\n  parent.__.onUnmount = function () {\n    var delName = tag.opts.dataIs;\n    arrayishRemove(tag.parent.tags, delName, tag);\n    arrayishRemove(tag.__.parent.tags, delName, tag);\n    tag.unmount();\n  };\n}\n\n/**\n * Nomalize any attribute removing the \"riot-\" prefix\n * @param   { String } attrName - original attribute name\n * @returns { String } valid html attribute name\n */\nfunction normalizeAttrName(attrName) {\n  if (!attrName) { return null }\n  attrName = attrName.replace(ATTRS_PREFIX, '');\n  if (CASE_SENSITIVE_ATTRIBUTES[attrName]) { attrName = CASE_SENSITIVE_ATTRIBUTES[attrName]; }\n  return attrName\n}\n\n/**\n * Update on single tag expression\n * @this Tag\n * @param { Object } expr - expression logic\n * @returns { undefined }\n */\nfunction updateExpression(expr) {\n  if (this.root && getAttribute(this.root,'virtualized')) { return }\n\n  var dom = expr.dom;\n  // remove the riot- prefix\n  var attrName = normalizeAttrName(expr.attr);\n  var isToggle = contains([SHOW_DIRECTIVE, HIDE_DIRECTIVE], attrName);\n  var isVirtual = expr.root && expr.root.tagName === 'VIRTUAL';\n  var ref = this.__;\n  var isAnonymous = ref.isAnonymous;\n  var parent = dom && (expr.parent || dom.parentNode);\n  // detect the style attributes\n  var isStyleAttr = attrName === 'style';\n  var isClassAttr = attrName === 'class';\n\n  var value;\n\n  // if it's a tag we could totally skip the rest\n  if (expr._riot_id) {\n    if (expr.__.wasCreated) {\n      expr.update();\n    // if it hasn't been mounted yet, do that now.\n    } else {\n      expr.mount();\n      if (isVirtual) {\n        makeReplaceVirtual(expr, expr.root);\n      }\n    }\n    return\n  }\n\n  // if this expression has the update method it means it can handle the DOM changes by itself\n  if (expr.update) { return expr.update() }\n\n  var context = isToggle && !isAnonymous ? inheritParentProps.call(this) : this;\n\n  // ...it seems to be a simple expression so we try to calculate its value\n  value = tmpl(expr.expr, context);\n\n  var hasValue = !isBlank(value);\n  var isObj = isObject(value);\n\n  // convert the style/class objects to strings\n  if (isObj) {\n    if (isClassAttr) {\n      value = tmpl(JSON.stringify(value), this);\n    } else if (isStyleAttr) {\n      value = styleObjectToString(value);\n    }\n  }\n\n  // remove original attribute\n  if (expr.attr && (!expr.wasParsedOnce || !hasValue || value === false)) {\n    // remove either riot-* attributes or just the attribute name\n    removeAttribute(dom, getAttribute(dom, expr.attr) ? expr.attr : attrName);\n  }\n\n  // for the boolean attributes we don't need the value\n  // we can convert it to checked=true to checked=checked\n  if (expr.bool) { value = value ? attrName : false; }\n  if (expr.isRtag) { return updateDataIs(expr, this, value) }\n  if (expr.wasParsedOnce && expr.value === value) { return }\n\n  // update the expression value\n  expr.value = value;\n  expr.wasParsedOnce = true;\n\n  // if the value is an object (and it's not a style or class attribute) we can not do much more with it\n  if (isObj && !isClassAttr && !isStyleAttr && !isToggle) { return }\n  // avoid to render undefined/null values\n  if (!hasValue) { value = ''; }\n\n  // textarea and text nodes have no attribute name\n  if (!attrName) {\n    // about #815 w/o replace: the browser converts the value to a string,\n    // the comparison by \"==\" does too, but not in the server\n    value += '';\n    // test for parent avoids error with invalid assignment to nodeValue\n    if (parent) {\n      // cache the parent node because somehow it will become null on IE\n      // on the next iteration\n      expr.parent = parent;\n      if (parent.tagName === 'TEXTAREA') {\n        parent.value = value;                    // #1113\n        if (!IE_VERSION) { dom.nodeValue = value; }  // #1625 IE throws here, nodeValue\n      }                                         // will be available on 'updated'\n      else { dom.nodeValue = value; }\n    }\n    return\n  }\n\n\n  // event handler\n  if (isFunction(value)) {\n    setEventHandler(attrName, value, dom, this);\n  // show / hide\n  } else if (isToggle) {\n    toggleVisibility(dom, attrName === HIDE_DIRECTIVE ? !value : value);\n  // handle attributes\n  } else {\n    if (expr.bool) {\n      dom[attrName] = value;\n    }\n\n    if (attrName === 'value' && dom.value !== value) {\n      dom.value = value;\n    } else if (hasValue && value !== false) {\n      setAttribute(dom, attrName, value);\n    }\n\n    // make sure that in case of style changes\n    // the element stays hidden\n    if (isStyleAttr && dom.hidden) { toggleVisibility(dom, false); }\n  }\n}\n\n/**\n * Update all the expressions in a Tag instance\n * @this Tag\n * @param { Array } expressions - expression that must be re evaluated\n */\nfunction update(expressions) {\n  each(expressions, updateExpression.bind(this));\n}\n\n/**\n * We need to update opts for this tag. That requires updating the expressions\n * in any attributes on the tag, and then copying the result onto opts.\n * @this Tag\n * @param   {Boolean} isLoop - is it a loop tag?\n * @param   { Tag }  parent - parent tag node\n * @param   { Boolean }  isAnonymous - is it a tag without any impl? (a tag not registered)\n * @param   { Object }  opts - tag options\n * @param   { Array }  instAttrs - tag attributes array\n */\nfunction updateOpts(isLoop, parent, isAnonymous, opts, instAttrs) {\n  // isAnonymous `each` tags treat `dom` and `root` differently. In this case\n  // (and only this case) we don't need to do updateOpts, because the regular parse\n  // will update those attrs. Plus, isAnonymous tags don't need opts anyway\n  if (isLoop && isAnonymous) { return }\n  var ctx = isLoop ? inheritParentProps.call(this) : parent || this;\n\n  each(instAttrs, function (attr) {\n    if (attr.expr) { updateExpression.call(ctx, attr.expr); }\n    // normalize the attribute names\n    opts[toCamel(attr.name).replace(ATTRS_PREFIX, '')] = attr.expr ? attr.expr.value : attr.value;\n  });\n}\n\n/**\n * Update the tag expressions and options\n * @param { Tag } tag - tag object\n * @param { * } data - data we want to use to extend the tag properties\n * @param { Array } expressions - component expressions array\n * @returns { Tag } the current tag instance\n */\nfunction componentUpdate(tag, data, expressions) {\n  var __ = tag.__;\n  var nextOpts = {};\n  var canTrigger = tag.isMounted && !__.skipAnonymous;\n\n  // inherit properties from the parent tag\n  if (__.isAnonymous && __.parent) { extend(tag, __.parent); }\n  extend(tag, data);\n\n  updateOpts.apply(tag, [__.isLoop, __.parent, __.isAnonymous, nextOpts, __.instAttrs]);\n\n  if (\n    canTrigger &&\n    tag.isMounted &&\n    isFunction(tag.shouldUpdate) && !tag.shouldUpdate(data, nextOpts)\n  ) {\n    return tag\n  }\n\n  extend(tag.opts, nextOpts);\n\n  if (canTrigger) { tag.trigger('update', data); }\n  update.call(tag, expressions);\n  if (canTrigger) { tag.trigger('updated'); }\n\n  return tag\n}\n\n/**\n * Get selectors for tags\n * @param   { Array } tags - tag names to select\n * @returns { String } selector\n */\nfunction query(tags) {\n  // select all tags\n  if (!tags) {\n    var keys = Object.keys(__TAG_IMPL);\n    return keys + query(keys)\n  }\n\n  return tags\n    .filter(function (t) { return !/[^-\\w]/.test(t); })\n    .reduce(function (list, t) {\n      var name = t.trim().toLowerCase();\n      return list + \",[\" + IS_DIRECTIVE + \"=\\\"\" + name + \"\\\"]\"\n    }, '')\n}\n\n/**\n * Another way to create a riot tag a bit more es6 friendly\n * @param { HTMLElement } el - tag DOM selector or DOM node/s\n * @param { Object } opts - tag logic\n * @returns { Tag } new riot tag instance\n */\nfunction Tag(el, opts) {\n  // get the tag properties from the class constructor\n  var ref = this;\n  var name = ref.name;\n  var tmpl = ref.tmpl;\n  var css = ref.css;\n  var attrs = ref.attrs;\n  var onCreate = ref.onCreate;\n  // register a new tag and cache the class prototype\n  if (!__TAG_IMPL[name]) {\n    tag(name, tmpl, css, attrs, onCreate);\n    // cache the class constructor\n    __TAG_IMPL[name].class = this.constructor;\n  }\n\n  // mount the tag using the class instance\n  mount$1(el, name, opts, this);\n  // inject the component css\n  if (css) { styleManager.inject(); }\n\n  return this\n}\n\n/**\n * Create a new riot tag implementation\n * @param   { String }   name - name/id of the new riot tag\n * @param   { String }   tmpl - tag template\n * @param   { String }   css - custom tag css\n * @param   { String }   attrs - root tag attributes\n * @param   { Function } fn - user function\n * @returns { String } name/id of the tag just created\n */\nfunction tag(name, tmpl, css, attrs, fn) {\n  if (isFunction(attrs)) {\n    fn = attrs;\n\n    if (/^[\\w-]+\\s?=/.test(css)) {\n      attrs = css;\n      css = '';\n    } else\n      { attrs = ''; }\n  }\n\n  if (css) {\n    if (isFunction(css))\n      { fn = css; }\n    else\n      { styleManager.add(css); }\n  }\n\n  name = name.toLowerCase();\n  __TAG_IMPL[name] = { name: name, tmpl: tmpl, attrs: attrs, fn: fn };\n\n  return name\n}\n\n/**\n * Create a new riot tag implementation (for use by the compiler)\n * @param   { String }   name - name/id of the new riot tag\n * @param   { String }   tmpl - tag template\n * @param   { String }   css - custom tag css\n * @param   { String }   attrs - root tag attributes\n * @param   { Function } fn - user function\n * @returns { String } name/id of the tag just created\n */\nfunction tag2(name, tmpl, css, attrs, fn) {\n  if (css) { styleManager.add(css, name); }\n\n  __TAG_IMPL[name] = { name: name, tmpl: tmpl, attrs: attrs, fn: fn };\n\n  return name\n}\n\n/**\n * Mount a tag using a specific tag implementation\n * @param   { * } selector - tag DOM selector or DOM node/s\n * @param   { String } tagName - tag implementation name\n * @param   { Object } opts - tag logic\n * @returns { Array } new tags instances\n */\nfunction mount(selector, tagName, opts) {\n  var tags = [];\n  var elem, allTags;;\n\n  function pushTagsTo(root) {\n    if (root.tagName) {\n      var riotTag = getAttribute(root, IS_DIRECTIVE), tag;;\n\n      // have tagName? force riot-tag to be the same\n      if (tagName && riotTag !== tagName) {\n        riotTag = tagName;\n        setAttribute(root, IS_DIRECTIVE, tagName);\n      }\n\n      tag = mount$1(root, riotTag || root.tagName.toLowerCase(), opts);\n\n      if (tag)\n        { tags.push(tag); }\n    } else if (root.length)\n      { each(root, pushTagsTo); } // assume nodeList\n  }\n\n  // inject styles into DOM\n  styleManager.inject();\n\n  if (isObject(tagName)) {\n    opts = tagName;\n    tagName = 0;\n  }\n\n  // crawl the DOM to find the tag\n  if (isString(selector)) {\n    selector = selector === '*' ?\n      // select all registered tags\n      // & tags found with the riot-tag attribute set\n      allTags = query() :\n      // or just the ones named like the selector\n      selector + query(selector.split(/, */));\n\n    // make sure to pass always a selector\n    // to the querySelectorAll function\n    elem = selector ? $$(selector) : [];\n  }\n  else\n    // probably you have passed already a tag or a NodeList\n    { elem = selector; }\n\n  // select all the registered and mount them inside their root elements\n  if (tagName === '*') {\n    // get all custom tags\n    tagName = allTags || query();\n    // if the root els it's just a single tag\n    if (elem.tagName)\n      { elem = $$(tagName, elem); }\n    else {\n      // select all the children for all the different root elements\n      var nodeList = [];\n\n      each(elem, function (_el) { return nodeList.push($$(tagName, _el)); });\n\n      elem = nodeList;\n    }\n    // get rid of the tagName\n    tagName = 0;\n  }\n\n  pushTagsTo(elem);\n\n  return tags\n}\n\n// Create a mixin that could be globally shared across all the tags\nvar mixins = {};\nvar globals = mixins[GLOBAL_MIXIN] = {};\nvar mixins_id = 0;\n\n/**\n * Create/Return a mixin by its name\n * @param   { String }  name - mixin name (global mixin if object)\n * @param   { Object }  mix - mixin logic\n * @param   { Boolean } g - is global?\n * @returns { Object }  the mixin logic\n */\nfunction mixin(name, mix, g) {\n  // Unnamed global\n  if (isObject(name)) {\n    mixin((\"__\" + (mixins_id++) + \"__\"), name, true);\n    return\n  }\n\n  var store = g ? globals : mixins;\n\n  // Getter\n  if (!mix) {\n    if (isUndefined(store[name]))\n      { throw new Error((\"Unregistered mixin: \" + name)) }\n\n    return store[name]\n  }\n\n  // Setter\n  store[name] = isFunction(mix) ?\n    extend(mix.prototype, store[name] || {}) && mix :\n    extend(store[name] || {}, mix);\n}\n\n/**\n * Update all the tags instances created\n * @returns { Array } all the tags instances\n */\nfunction update$1() {\n  return each(__TAGS_CACHE, function (tag) { return tag.update(); })\n}\n\nfunction unregister(name) {\n  __TAG_IMPL[name] = null;\n}\n\nvar version = 'v3.9.0';\n\n\nvar core = Object.freeze({\n\tTag: Tag,\n\ttag: tag,\n\ttag2: tag2,\n\tmount: mount,\n\tmixin: mixin,\n\tupdate: update$1,\n\tunregister: unregister,\n\tversion: version\n});\n\n/**\n * Add a mixin to this tag\n * @returns { Tag } the current tag instance\n */\nfunction componentMixin(tag$$1) {\n  var mixins = [], len = arguments.length - 1;\n  while ( len-- > 0 ) mixins[ len ] = arguments[ len + 1 ];\n\n  each(mixins, function (mix) {\n    var instance;\n    var obj;\n    var props = [];\n\n    // properties blacklisted and will not be bound to the tag instance\n    var propsBlacklist = ['init', '__proto__'];\n\n    mix = isString(mix) ? mixin(mix) : mix;\n\n    // check if the mixin is a function\n    if (isFunction(mix)) {\n      // create the new mixin instance\n      instance = new mix();\n    } else { instance = mix; }\n\n    var proto = Object.getPrototypeOf(instance);\n\n    // build multilevel prototype inheritance chain property list\n    do { props = props.concat(Object.getOwnPropertyNames(obj || instance)); }\n    while (obj = Object.getPrototypeOf(obj || instance))\n\n    // loop the keys in the function prototype or the all object keys\n    each(props, function (key) {\n      // bind methods to tag\n      // allow mixins to override other properties/parent mixins\n      if (!contains(propsBlacklist, key)) {\n        // check for getters/setters\n        var descriptor = getPropDescriptor(instance, key) || getPropDescriptor(proto, key);\n        var hasGetterSetter = descriptor && (descriptor.get || descriptor.set);\n\n        // apply method only if it does not already exist on the instance\n        if (!tag$$1.hasOwnProperty(key) && hasGetterSetter) {\n          Object.defineProperty(tag$$1, key, descriptor);\n        } else {\n          tag$$1[key] = isFunction(instance[key]) ?\n            instance[key].bind(tag$$1) :\n            instance[key];\n        }\n      }\n    });\n\n    // init method will be called automatically\n    if (instance.init)\n      { instance.init.bind(tag$$1)(tag$$1.opts); }\n  });\n\n  return tag$$1\n}\n\n/**\n * Move the position of a custom tag in its parent tag\n * @this Tag\n * @param   { String } tagName - key where the tag was stored\n * @param   { Number } newPos - index where the new tag will be stored\n */\nfunction moveChild(tagName, newPos) {\n  var parent = this.parent;\n  var tags;\n  // no parent no move\n  if (!parent) { return }\n\n  tags = parent.tags[tagName];\n\n  if (isArray(tags))\n    { tags.splice(newPos, 0, tags.splice(tags.indexOf(this), 1)[0]); }\n  else { arrayishAdd(parent.tags, tagName, this); }\n}\n\n/**\n * Move virtual tag and all child nodes\n * @this Tag\n * @param { Node } src  - the node that will do the inserting\n * @param { Tag } target - insert before this tag's first child\n */\nfunction moveVirtual(src, target) {\n  var this$1 = this;\n\n  var el = this.__.head;\n  var sib;\n  var frag = createFragment();\n\n  while (el) {\n    sib = el.nextSibling;\n    frag.appendChild(el);\n    el = sib;\n    if (el === this$1.__.tail) {\n      frag.appendChild(el);\n      src.insertBefore(frag, target.__.head);\n      break\n    }\n  }\n}\n\n/**\n * Convert the item looped into an object used to extend the child tag properties\n * @param   { Object } expr - object containing the keys used to extend the children tags\n * @param   { * } key - value to assign to the new object returned\n * @param   { * } val - value containing the position of the item in the array\n * @param   { Object } base - prototype object for the new item\n * @returns { Object } - new object containing the values of the original item\n *\n * The variables 'key' and 'val' are arbitrary.\n * They depend on the collection type looped (Array, Object)\n * and on the expression used on the each tag\n *\n */\nfunction mkitem(expr, key, val, base) {\n  var item = base ? create(base) : {};\n  item[expr.key] = key;\n  if (expr.pos) { item[expr.pos] = val; }\n  return item\n}\n\n/**\n * Unmount the redundant tags\n * @param   { Array } items - array containing the current items to loop\n * @param   { Array } tags - array containing all the children tags\n */\nfunction unmountRedundant(items, tags) {\n  var i = tags.length;\n  var j = items.length;\n\n  while (i > j) {\n    i--;\n    remove.apply(tags[i], [tags, i]);\n  }\n}\n\n\n/**\n * Remove a child tag\n * @this Tag\n * @param   { Array } tags - tags collection\n * @param   { Number } i - index of the tag to remove\n */\nfunction remove(tags, i) {\n  tags.splice(i, 1);\n  this.unmount();\n  arrayishRemove(this.parent, this, this.__.tagName, true);\n}\n\n/**\n * Move the nested custom tags in non custom loop tags\n * @this Tag\n * @param   { Number } i - current position of the loop tag\n */\nfunction moveNestedTags(i) {\n  var this$1 = this;\n\n  each(Object.keys(this.tags), function (tagName) {\n    moveChild.apply(this$1.tags[tagName], [tagName, i]);\n  });\n}\n\n/**\n * Move a child tag\n * @this Tag\n * @param   { HTMLElement } root - dom node containing all the loop children\n * @param   { Tag } nextTag - instance of the next tag preceding the one we want to move\n * @param   { Boolean } isVirtual - is it a virtual tag?\n */\nfunction move(root, nextTag, isVirtual) {\n  if (isVirtual)\n    { moveVirtual.apply(this, [root, nextTag]); }\n  else\n    { safeInsert(root, this.root, nextTag.root); }\n}\n\n/**\n * Insert and mount a child tag\n * @this Tag\n * @param   { HTMLElement } root - dom node containing all the loop children\n * @param   { Tag } nextTag - instance of the next tag preceding the one we want to insert\n * @param   { Boolean } isVirtual - is it a virtual tag?\n */\nfunction insert(root, nextTag, isVirtual) {\n  if (isVirtual)\n    { makeVirtual.apply(this, [root, nextTag]); }\n  else\n    { safeInsert(root, this.root, nextTag.root); }\n}\n\n/**\n * Append a new tag into the DOM\n * @this Tag\n * @param   { HTMLElement } root - dom node containing all the loop children\n * @param   { Boolean } isVirtual - is it a virtual tag?\n */\nfunction append(root, isVirtual) {\n  if (isVirtual)\n    { makeVirtual.call(this, root); }\n  else\n    { root.appendChild(this.root); }\n}\n\n/**\n * Return the value we want to use to lookup the postion of our items in the collection\n * @param   { String }  keyAttr         - lookup string or expression\n * @param   { * }       originalItem    - original item from the collection\n * @param   { Object }  keyedItem       - object created by riot via { item, i in collection }\n * @param   { Boolean } hasKeyAttrExpr  - flag to check whether the key is an expression\n * @returns { * } value that we will use to figure out the item position via collection.indexOf\n */\nfunction getItemId(keyAttr, originalItem, keyedItem, hasKeyAttrExpr) {\n  if (keyAttr) {\n    return hasKeyAttrExpr ?  tmpl(keyAttr, keyedItem) :  originalItem[keyAttr]\n  }\n\n  return originalItem\n}\n\n/**\n * Manage tags having the 'each'\n * @param   { HTMLElement } dom - DOM node we need to loop\n * @param   { Tag } parent - parent tag instance where the dom node is contained\n * @param   { String } expr - string contained in the 'each' attribute\n * @returns { Object } expression object for this each loop\n */\nfunction _each(dom, parent, expr) {\n  var mustReorder = typeof getAttribute(dom, LOOP_NO_REORDER_DIRECTIVE) !== T_STRING || removeAttribute(dom, LOOP_NO_REORDER_DIRECTIVE);\n  var keyAttr = getAttribute(dom, KEY_DIRECTIVE);\n  var hasKeyAttrExpr = keyAttr ? tmpl.hasExpr(keyAttr) : false;\n  var tagName = getName(dom);\n  var impl = __TAG_IMPL[tagName];\n  var parentNode = dom.parentNode;\n  var placeholder = createDOMPlaceholder();\n  var child = get(dom);\n  var ifExpr = getAttribute(dom, CONDITIONAL_DIRECTIVE);\n  var tags = [];\n  var isLoop = true;\n  var innerHTML = dom.innerHTML;\n  var isAnonymous = !__TAG_IMPL[tagName];\n  var isVirtual = dom.tagName === 'VIRTUAL';\n  var oldItems = [];\n  var hasKeys;\n\n  // remove the each property from the original tag\n  removeAttribute(dom, LOOP_DIRECTIVE);\n  removeAttribute(dom, KEY_DIRECTIVE);\n\n  // parse the each expression\n  expr = tmpl.loopKeys(expr);\n  expr.isLoop = true;\n\n  if (ifExpr) { removeAttribute(dom, CONDITIONAL_DIRECTIVE); }\n\n  // insert a marked where the loop tags will be injected\n  parentNode.insertBefore(placeholder, dom);\n  parentNode.removeChild(dom);\n\n  expr.update = function updateEach() {\n    // get the new items collection\n    expr.value = tmpl(expr.val, parent);\n\n    var items = expr.value;\n    var frag = createFragment();\n    var isObject = !isArray(items) && !isString(items);\n    var root = placeholder.parentNode;\n    var tmpItems = [];\n\n    // if this DOM was removed the update here is useless\n    // this condition fixes also a weird async issue on IE in our unit test\n    if (!root) { return }\n\n    // object loop. any changes cause full redraw\n    if (isObject) {\n      hasKeys = items || false;\n      items = hasKeys ?\n        Object.keys(items).map(function (key) { return mkitem(expr, items[key], key); }) : [];\n    } else {\n      hasKeys = false;\n    }\n\n    if (ifExpr) {\n      items = items.filter(function (item, i) {\n        if (expr.key && !isObject)\n          { return !!tmpl(ifExpr, mkitem(expr, item, i, parent)) }\n\n        return !!tmpl(ifExpr, extend(create(parent), item))\n      });\n    }\n\n    // loop all the new items\n    each(items, function (_item, i) {\n      var item = !hasKeys && expr.key ? mkitem(expr, _item, i) : _item;\n      var itemId = getItemId(keyAttr, _item, item, hasKeyAttrExpr);\n      // reorder only if the items are objects\n      var doReorder = mustReorder && typeof _item === T_OBJECT && !hasKeys;\n      var oldPos = oldItems.indexOf(itemId);\n      var isNew = oldPos === -1;\n      var pos = !isNew && doReorder ? oldPos : i;\n      // does a tag exist in this position?\n      var tag = tags[pos];\n      var mustAppend = i >= oldItems.length;\n      var mustCreate =  doReorder && isNew || !doReorder && !tag;\n\n      // new tag\n      if (mustCreate) {\n        tag = createTag(impl, {\n          parent: parent,\n          isLoop: isLoop,\n          isAnonymous: isAnonymous,\n          tagName: tagName,\n          root: dom.cloneNode(isAnonymous),\n          item: item,\n          index: i,\n        }, innerHTML);\n\n        // mount the tag\n        tag.mount();\n\n        if (mustAppend)\n          { append.apply(tag, [frag || root, isVirtual]); }\n        else\n          { insert.apply(tag, [root, tags[i], isVirtual]); }\n\n        if (!mustAppend) { oldItems.splice(i, 0, item); }\n        tags.splice(i, 0, tag);\n        if (child) { arrayishAdd(parent.tags, tagName, tag, true); }\n      } else if (pos !== i && doReorder) {\n        // move\n        if (keyAttr || contains(items, oldItems[pos])) {\n          move.apply(tag, [root, tags[i], isVirtual]);\n          // move the old tag instance\n          tags.splice(i, 0, tags.splice(pos, 1)[0]);\n          // move the old item\n          oldItems.splice(i, 0, oldItems.splice(pos, 1)[0]);\n        }\n\n        // update the position attribute if it exists\n        if (expr.pos) { tag[expr.pos] = i; }\n\n        // if the loop tags are not custom\n        // we need to move all their custom tags into the right position\n        if (!child && tag.tags) { moveNestedTags.call(tag, i); }\n      }\n\n      // cache the original item to use it in the events bound to this node\n      // and its children\n      extend(tag.__, {\n        item: item,\n        index: i,\n        parent: parent\n      });\n\n      tmpItems[i] = itemId;\n\n      if (!mustCreate) { tag.update(item); }\n    });\n\n    // remove the redundant tags\n    unmountRedundant(items, tags);\n\n    // clone the items array\n    oldItems = tmpItems.slice();\n\n    root.insertBefore(frag, placeholder);\n  };\n\n  expr.unmount = function () {\n    each(tags, function (t) { t.unmount(); });\n  };\n\n  return expr\n}\n\nvar RefExpr = {\n  init: function init(dom, parent, attrName, attrValue) {\n    this.dom = dom;\n    this.attr = attrName;\n    this.rawValue = attrValue;\n    this.parent = parent;\n    this.hasExp = tmpl.hasExpr(attrValue);\n    return this\n  },\n  update: function update() {\n    var old = this.value;\n    var customParent = this.parent && getImmediateCustomParent(this.parent);\n    // if the referenced element is a custom tag, then we set the tag itself, rather than DOM\n    var tagOrDom = this.dom.__ref || this.tag || this.dom;\n\n    this.value = this.hasExp ? tmpl(this.rawValue, this.parent) : this.rawValue;\n\n    // the name changed, so we need to remove it from the old key (if present)\n    if (!isBlank(old) && customParent) { arrayishRemove(customParent.refs, old, tagOrDom); }\n    if (!isBlank(this.value) && isString(this.value)) {\n      // add it to the refs of parent tag (this behavior was changed >=3.0)\n      if (customParent) { arrayishAdd(\n        customParent.refs,\n        this.value,\n        tagOrDom,\n        // use an array if it's a looped node and the ref is not an expression\n        null,\n        this.parent.__.index\n      ); }\n\n      if (this.value !== old) {\n        setAttribute(this.dom, this.attr, this.value);\n      }\n    } else {\n      removeAttribute(this.dom, this.attr);\n    }\n\n    // cache the ref bound to this dom node\n    // to reuse it in future (see also #2329)\n    if (!this.dom.__ref) { this.dom.__ref = tagOrDom; }\n  },\n  unmount: function unmount() {\n    var tagOrDom = this.tag || this.dom;\n    var customParent = this.parent && getImmediateCustomParent(this.parent);\n    if (!isBlank(this.value) && customParent)\n      { arrayishRemove(customParent.refs, this.value, tagOrDom); }\n  }\n}\n\n/**\n * Create a new ref directive\n * @param   { HTMLElement } dom - dom node having the ref attribute\n * @param   { Tag } context - tag instance where the DOM node is located\n * @param   { String } attrName - either 'ref' or 'data-ref'\n * @param   { String } attrValue - value of the ref attribute\n * @returns { RefExpr } a new RefExpr object\n */\nfunction createRefDirective(dom, tag, attrName, attrValue) {\n  return create(RefExpr).init(dom, tag, attrName, attrValue)\n}\n\n/**\n * Trigger the unmount method on all the expressions\n * @param   { Array } expressions - DOM expressions\n */\nfunction unmountAll(expressions) {\n  each(expressions, function (expr) {\n    if (expr.unmount) { expr.unmount(true); }\n    else if (expr.tagName) { expr.tag.unmount(true); }\n    else if (expr.unmount) { expr.unmount(); }\n  });\n}\n\nvar IfExpr = {\n  init: function init(dom, tag, expr) {\n    removeAttribute(dom, CONDITIONAL_DIRECTIVE);\n    extend(this, { tag: tag, expr: expr, stub: createDOMPlaceholder(), pristine: dom });\n    var p = dom.parentNode;\n    p.insertBefore(this.stub, dom);\n    p.removeChild(dom);\n\n    return this\n  },\n  update: function update$$1() {\n    this.value = tmpl(this.expr, this.tag);\n\n    if (this.value && !this.current) { // insert\n      this.current = this.pristine.cloneNode(true);\n      this.stub.parentNode.insertBefore(this.current, this.stub);\n      this.expressions = parseExpressions.apply(this.tag, [this.current, true]);\n    } else if (!this.value && this.current) { // remove\n      unmountAll(this.expressions);\n      if (this.current._tag) {\n        this.current._tag.unmount();\n      } else if (this.current.parentNode) {\n        this.current.parentNode.removeChild(this.current);\n      }\n      this.current = null;\n      this.expressions = [];\n    }\n\n    if (this.value) { update.call(this.tag, this.expressions); }\n  },\n  unmount: function unmount() {\n    unmountAll(this.expressions || []);\n  }\n}\n\n/**\n * Create a new if directive\n * @param   { HTMLElement } dom - if root dom node\n * @param   { Tag } context - tag instance where the DOM node is located\n * @param   { String } attr - if expression\n * @returns { IFExpr } a new IfExpr object\n */\nfunction createIfDirective(dom, tag, attr) {\n  return create(IfExpr).init(dom, tag, attr)\n}\n\n/**\n * Walk the tag DOM to detect the expressions to evaluate\n * @this Tag\n * @param   { HTMLElement } root - root tag where we will start digging the expressions\n * @param   { Boolean } mustIncludeRoot - flag to decide whether the root must be parsed as well\n * @returns { Array } all the expressions found\n */\nfunction parseExpressions(root, mustIncludeRoot) {\n  var this$1 = this;\n\n  var expressions = [];\n\n  walkNodes(root, function (dom) {\n    var type = dom.nodeType;\n    var attr;\n    var tagImpl;\n\n    if (!mustIncludeRoot && dom === root) { return }\n\n    // text node\n    if (type === 3 && dom.parentNode.tagName !== 'STYLE' && tmpl.hasExpr(dom.nodeValue))\n      { expressions.push({dom: dom, expr: dom.nodeValue}); }\n\n    if (type !== 1) { return }\n\n    var isVirtual = dom.tagName === 'VIRTUAL';\n\n    // loop. each does it's own thing (for now)\n    if (attr = getAttribute(dom, LOOP_DIRECTIVE)) {\n      if(isVirtual) { setAttribute(dom, 'loopVirtual', true); } // ignore here, handled in _each\n      expressions.push(_each(dom, this$1, attr));\n      return false\n    }\n\n    // if-attrs become the new parent. Any following expressions (either on the current\n    // element, or below it) become children of this expression.\n    if (attr = getAttribute(dom, CONDITIONAL_DIRECTIVE)) {\n      expressions.push(createIfDirective(dom, this$1, attr));\n      return false\n    }\n\n    if (attr = getAttribute(dom, IS_DIRECTIVE)) {\n      if (tmpl.hasExpr(attr)) {\n        expressions.push({\n          isRtag: true,\n          expr: attr,\n          dom: dom,\n          attrs: [].slice.call(dom.attributes)\n        });\n\n        return false\n      }\n    }\n\n    // if this is a tag, stop traversing here.\n    // we ignore the root, since parseExpressions is called while we're mounting that root\n    tagImpl = get(dom);\n\n    if(isVirtual) {\n      if(getAttribute(dom, 'virtualized')) {dom.parentElement.removeChild(dom); } // tag created, remove from dom\n      if(!tagImpl && !getAttribute(dom, 'virtualized') && !getAttribute(dom, 'loopVirtual'))  // ok to create virtual tag\n        { tagImpl = { tmpl: dom.outerHTML }; }\n    }\n\n    if (tagImpl && (dom !== root || mustIncludeRoot)) {\n      if(isVirtual) { // handled in update\n        if (getAttribute(dom, IS_DIRECTIVE))\n          { warn((\"Virtual tags shouldn't be used together with the \\\"\" + IS_DIRECTIVE + \"\\\" attribute - https://github.com/riot/riot/issues/2511\")); }\n        // can not remove attribute like directives\n        // so flag for removal after creation to prevent maximum stack error\n        setAttribute(dom, 'virtualized', true);\n        var tag = createTag(\n          {tmpl: dom.outerHTML},\n          {root: dom, parent: this$1},\n          dom.innerHTML\n        );\n\n        expressions.push(tag); // no return, anonymous tag, keep parsing\n      } else {\n        expressions.push(\n          initChild(\n            tagImpl,\n            {\n              root: dom,\n              parent: this$1\n            },\n            dom.innerHTML,\n            this$1\n          )\n        );\n        return false\n      }\n    }\n\n    // attribute expressions\n    parseAttributes.apply(this$1, [dom, dom.attributes, function (attr, expr) {\n      if (!expr) { return }\n      expressions.push(expr);\n    }]);\n  });\n\n  return expressions\n}\n\n/**\n * Calls `fn` for every attribute on an element. If that attr has an expression,\n * it is also passed to fn.\n * @this Tag\n * @param   { HTMLElement } dom - dom node to parse\n * @param   { Array } attrs - array of attributes\n * @param   { Function } fn - callback to exec on any iteration\n */\nfunction parseAttributes(dom, attrs, fn) {\n  var this$1 = this;\n\n  each(attrs, function (attr) {\n    if (!attr) { return false }\n\n    var name = attr.name;\n    var bool = isBoolAttr(name);\n    var expr;\n\n    if (contains(REF_DIRECTIVES, name) && dom.tagName.toLowerCase() !== YIELD_TAG) {\n      expr =  createRefDirective(dom, this$1, name, attr.value);\n    } else if (tmpl.hasExpr(attr.value)) {\n      expr = {dom: dom, expr: attr.value, attr: name, bool: bool};\n    }\n\n    fn(attr, expr);\n  });\n}\n\n/**\n * Manage the mount state of a tag triggering also the observable events\n * @this Tag\n * @param { Boolean } value - ..of the isMounted flag\n */\nfunction setMountState(value) {\n  var ref = this.__;\n  var isAnonymous = ref.isAnonymous;\n\n  define(this, 'isMounted', value);\n\n  if (!isAnonymous) {\n    if (value) { this.trigger('mount'); }\n    else {\n      this.trigger('unmount');\n      this.off('*');\n      this.__.wasCreated = false;\n    }\n  }\n}\n\n/**\n * Mount the current tag instance\n * @returns { Tag } the current tag instance\n */\nfunction componentMount(tag$$1, dom, expressions, opts) {\n  var __ = tag$$1.__;\n  var root = __.root;\n  root._tag = tag$$1; // keep a reference to the tag just created\n\n  // Read all the attrs on this instance. This give us the info we need for updateOpts\n  parseAttributes.apply(__.parent, [root, root.attributes, function (attr, expr) {\n    if (!__.isAnonymous && RefExpr.isPrototypeOf(expr)) { expr.tag = tag$$1; }\n    attr.expr = expr;\n    __.instAttrs.push(attr);\n  }]);\n\n  // update the root adding custom attributes coming from the compiler\n  walkAttributes(__.impl.attrs, function (k, v) { __.implAttrs.push({name: k, value: v}); });\n  parseAttributes.apply(tag$$1, [root, __.implAttrs, function (attr, expr) {\n    if (expr) { expressions.push(expr); }\n    else { setAttribute(root, attr.name, attr.value); }\n  }]);\n\n  // initialiation\n  updateOpts.apply(tag$$1, [__.isLoop, __.parent, __.isAnonymous, opts, __.instAttrs]);\n\n  // add global mixins\n  var globalMixin = mixin(GLOBAL_MIXIN);\n\n  if (globalMixin && !__.skipAnonymous) {\n    for (var i in globalMixin) {\n      if (globalMixin.hasOwnProperty(i)) {\n        tag$$1.mixin(globalMixin[i]);\n      }\n    }\n  }\n\n  if (__.impl.fn) { __.impl.fn.call(tag$$1, opts); }\n\n  if (!__.skipAnonymous) { tag$$1.trigger('before-mount'); }\n\n  // parse layout after init. fn may calculate args for nested custom tags\n  each(parseExpressions.apply(tag$$1, [dom, __.isAnonymous]), function (e) { return expressions.push(e); });\n\n  tag$$1.update(__.item);\n\n  if (!__.isAnonymous && !__.isInline) {\n    while (dom.firstChild) { root.appendChild(dom.firstChild); }\n  }\n\n  define(tag$$1, 'root', root);\n\n  // if we need to wait that the parent \"mount\" or \"updated\" event gets triggered\n  if (!__.skipAnonymous && tag$$1.parent) {\n    var p = getImmediateCustomParent(tag$$1.parent);\n    p.one(!p.isMounted ? 'mount' : 'updated', function () {\n      setMountState.call(tag$$1, true);\n    });\n  } else {\n    // otherwise it's not a child tag we can trigger its mount event\n    setMountState.call(tag$$1, true);\n  }\n\n  tag$$1.__.wasCreated = true;\n\n  return tag$$1\n}\n\n/**\n * Unmount the tag instance\n * @param { Boolean } mustKeepRoot - if it's true the root node will not be removed\n * @returns { Tag } the current tag instance\n */\nfunction tagUnmount(tag, mustKeepRoot, expressions) {\n  var __ = tag.__;\n  var root = __.root;\n  var tagIndex = __TAGS_CACHE.indexOf(tag);\n  var p = root.parentNode;\n\n  if (!__.skipAnonymous) { tag.trigger('before-unmount'); }\n\n  // clear all attributes coming from the mounted tag\n  walkAttributes(__.impl.attrs, function (name) {\n    if (startsWith(name, ATTRS_PREFIX))\n      { name = name.slice(ATTRS_PREFIX.length); }\n\n    removeAttribute(root, name);\n  });\n\n  // remove all the event listeners\n  tag.__.listeners.forEach(function (dom) {\n    Object.keys(dom[RIOT_EVENTS_KEY]).forEach(function (eventName) {\n      dom.removeEventListener(eventName, dom[RIOT_EVENTS_KEY][eventName]);\n    });\n  });\n\n  // remove tag instance from the global tags cache collection\n  if (tagIndex !== -1) { __TAGS_CACHE.splice(tagIndex, 1); }\n\n  // clean up the parent tags object\n  if (__.parent && !__.isAnonymous) {\n    var ptag = getImmediateCustomParent(__.parent);\n\n    if (__.isVirtual) {\n      Object\n        .keys(tag.tags)\n        .forEach(function (tagName) { return arrayishRemove(ptag.tags, tagName, tag.tags[tagName]); });\n    } else {\n      arrayishRemove(ptag.tags, __.tagName, tag);\n    }\n  }\n\n  // unmount all the virtual directives\n  if (tag.__.virts) {\n    each(tag.__.virts, function (v) {\n      if (v.parentNode) { v.parentNode.removeChild(v); }\n    });\n  }\n\n  // allow expressions to unmount themselves\n  unmountAll(expressions);\n  each(__.instAttrs, function (a) { return a.expr && a.expr.unmount && a.expr.unmount(); });\n\n  // clear the tag html if it's necessary\n  if (mustKeepRoot) { setInnerHTML(root, ''); }\n  // otherwise detach the root tag from the DOM\n  else if (p) { p.removeChild(root); }\n\n  // custom internal unmount function to avoid relying on the observable\n  if (__.onUnmount) { __.onUnmount(); }\n\n  // weird fix for a weird edge case #2409 and #2436\n  // some users might use your software not as you've expected\n  // so I need to add these dirty hacks to mitigate unexpected issues\n  if (!tag.isMounted) { setMountState.call(tag, true); }\n\n  setMountState.call(tag, false);\n\n  delete root._tag;\n\n  return tag\n}\n\n/**\n * Tag creation factory function\n * @constructor\n * @param { Object } impl - it contains the tag template, and logic\n * @param { Object } conf - tag options\n * @param { String } innerHTML - html that eventually we need to inject in the tag\n */\nfunction createTag(impl, conf, innerHTML) {\n  if ( impl === void 0 ) impl = {};\n  if ( conf === void 0 ) conf = {};\n\n  var tag = conf.context || {};\n  var opts = extend({}, conf.opts);\n  var parent = conf.parent;\n  var isLoop = conf.isLoop;\n  var isAnonymous = !!conf.isAnonymous;\n  var skipAnonymous = settings.skipAnonymousTags && isAnonymous;\n  var item = conf.item;\n  // available only for the looped nodes\n  var index = conf.index;\n  // All attributes on the Tag when it's first parsed\n  var instAttrs = [];\n  // expressions on this type of Tag\n  var implAttrs = [];\n  var expressions = [];\n  var root = conf.root;\n  var tagName = conf.tagName || getName(root);\n  var isVirtual = tagName === 'virtual';\n  var isInline = !isVirtual && !impl.tmpl;\n  var dom;\n\n  // make this tag observable\n  if (!skipAnonymous) { observable(tag); }\n  // only call unmount if we have a valid __TAG_IMPL (has name property)\n  if (impl.name && root._tag) { root._tag.unmount(true); }\n\n  // not yet mounted\n  define(tag, 'isMounted', false);\n\n  define(tag, '__', {\n    impl: impl,\n    root: root,\n    skipAnonymous: skipAnonymous,\n    implAttrs: implAttrs,\n    isAnonymous: isAnonymous,\n    instAttrs: instAttrs,\n    innerHTML: innerHTML,\n    tagName: tagName,\n    index: index,\n    isLoop: isLoop,\n    isInline: isInline,\n    item: item,\n    parent: parent,\n    // tags having event listeners\n    // it would be better to use weak maps here but we can not introduce breaking changes now\n    listeners: [],\n    // these vars will be needed only for the virtual tags\n    virts: [],\n    wasCreated: false,\n    tail: null,\n    head: null\n  });\n\n  // create a unique id to this tag\n  // it could be handy to use it also to improve the virtual dom rendering speed\n  define(tag, '_riot_id', uid()); // base 1 allows test !t._riot_id\n  define(tag, 'root', root);\n  extend(tag, { opts: opts }, item);\n  // protect the \"tags\" and \"refs\" property from being overridden\n  define(tag, 'parent', parent || null);\n  define(tag, 'tags', {});\n  define(tag, 'refs', {});\n\n  if (isInline || isLoop && isAnonymous) {\n    dom = root;\n  } else {\n    if (!isVirtual) { root.innerHTML = ''; }\n    dom = mkdom(impl.tmpl, innerHTML, isSvg(root));\n  }\n\n  define(tag, 'update', function (data) { return componentUpdate(tag, data, expressions); });\n  define(tag, 'mixin', function () {\n    var mixins = [], len = arguments.length;\n    while ( len-- ) mixins[ len ] = arguments[ len ];\n\n    return componentMixin.apply(void 0, [ tag ].concat( mixins ));\n  });\n  define(tag, 'mount', function () { return componentMount(tag, dom, expressions, opts); });\n  define(tag, 'unmount', function (mustKeepRoot) { return tagUnmount(tag, mustKeepRoot, expressions); });\n\n  return tag\n}\n\n/**\n * Mount a tag creating new Tag instance\n * @param   { Object } root - dom node where the tag will be mounted\n * @param   { String } tagName - name of the riot tag we want to mount\n * @param   { Object } opts - options to pass to the Tag instance\n * @param   { Object } ctx - optional context that will be used to extend an existing class ( used in riot.Tag )\n * @returns { Tag } a new Tag instance\n */\nfunction mount$1(root, tagName, opts, ctx) {\n  var impl = __TAG_IMPL[tagName];\n  var implClass = __TAG_IMPL[tagName].class;\n  var context = ctx || (implClass ? create(implClass.prototype) : {});\n  // cache the inner HTML to fix #855\n  var innerHTML = root._innerHTML = root._innerHTML || root.innerHTML;\n  var conf = extend({ root: root, opts: opts, context: context }, { parent: opts ? opts.parent : null });\n  var tag;\n\n  if (impl && root) { tag = createTag(impl, conf, innerHTML); }\n\n  if (tag && tag.mount) {\n    tag.mount(true);\n    // add this tag to the virtualDom variable\n    if (!contains(__TAGS_CACHE, tag)) { __TAGS_CACHE.push(tag); }\n  }\n\n  return tag\n}\n\n\n\nvar tags = Object.freeze({\n\tarrayishAdd: arrayishAdd,\n\tgetTagName: getName,\n\tinheritParentProps: inheritParentProps,\n\tmountTo: mount$1,\n\tselectTags: query,\n\tarrayishRemove: arrayishRemove,\n\tgetTag: get,\n\tinitChildTag: initChild,\n\tmoveChildTag: moveChild,\n\tmakeReplaceVirtual: makeReplaceVirtual,\n\tgetImmediateCustomParentTag: getImmediateCustomParent,\n\tmakeVirtual: makeVirtual,\n\tmoveVirtual: moveVirtual,\n\tunmountAll: unmountAll,\n\tcreateIfDirective: createIfDirective,\n\tcreateRefDirective: createRefDirective\n});\n\n/**\n * Riot public api\n */\nvar settings$1 = settings;\nvar util = {\n  tmpl: tmpl,\n  brackets: brackets,\n  styleManager: styleManager,\n  vdom: __TAGS_CACHE,\n  styleNode: styleManager.styleNode,\n  // export the riot internal utils as well\n  dom: dom,\n  check: check,\n  misc: misc,\n  tags: tags\n};\n\n// export the core props/methods\nvar Tag$1 = Tag;\nvar tag$1 = tag;\nvar tag2$1 = tag2;\nvar mount$2 = mount;\nvar mixin$1 = mixin;\nvar update$2 = update$1;\nvar unregister$1 = unregister;\nvar version$1 = version;\nvar observable$2 = observable;\n\nvar riot$1 = extend({}, core, {\n  observable: observable,\n  settings: settings$1,\n  util: util,\n})\n\nexports.settings = settings$1;\nexports.util = util;\nexports.Tag = Tag$1;\nexports.tag = tag$1;\nexports.tag2 = tag2$1;\nexports.mount = mount$2;\nexports.mixin = mixin$1;\nexports.update = update$2;\nexports.unregister = unregister$1;\nexports.version = version$1;\nexports.observable = observable$2;\nexports.default = riot$1;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n","/* Range Coder.  Inspired by rangecod.c from rngcod13.zip from\n *    http://www.compressconsult.com/rangecoder/\n * This JavaScript version is:\n *    Copyright (c) 2013 C. Scott Ananian.\n */\n\n// Uses 32-bit integer math.  Hopefully the JavaScript runtime figures\n// that out. ;)\n// see https://github.com/kripken/emscripten/wiki/LLVM-Types-in-JavaScript\n// for some hints on doing 32-bit unsigned match in JavaScript.\n// One key is the use of \">>>0\" to change a signed result to unsigned.\nvar CODE_BITS = 32;\nvar Top_value = Math.pow(2, CODE_BITS-1);\nvar SHIFT_BITS = (CODE_BITS - 9);\nvar EXTRA_BITS = ((CODE_BITS-2) % 8 + 1);\nvar Bottom_value = (Top_value >>> 8);\n\nvar MAX_INT = Math.pow(2, CODE_BITS) - 1;\n\n/* it is highly recommended that the total frequency count is less  */\n/* than 1 << 19 to minimize rounding effects.                       */\n/* the total frequency count MUST be less than 1<<23                */\n\n\nvar RangeCoder = function(stream) {\n    this.low = 0; /* low end of interval */\n    this.range = Top_value; /* length of interval */\n    this.buffer = 0; /* buffer for input/output */\n    this.help = 0; /* bytes_to_follow / intermediate value */\n    this.bytecount = 0; /* counter for output bytes */\n    this.stream = stream;\n};\n\n/* Do the normalization before we need a defined state, instead of\n    * after messing it up.  This simplifies starting and ending. */\nvar enc_normalize = function(rc, outputStream) {\n    while (rc.range <= Bottom_value) { /* do we need renormalization? */\n        if (rc.low < (0xFF << SHIFT_BITS)) {//no carry possible, so output\n            outputStream.writeByte(rc.buffer);\n            for (; rc.help; rc.help--)\n                outputStream.writeByte(0xFF);\n            rc.buffer = (rc.low >>> SHIFT_BITS) & 0xFF;\n        } else if (rc.low & Top_value) { /* carry now, no future carry */\n            outputStream.writeByte(rc.buffer+1);\n            for (; rc.help; rc.help--)\n                outputStream.writeByte(0x00);\n            rc.buffer = (rc.low >>> SHIFT_BITS) & 0xFF;\n        } else {\n            rc.help++;\n            if (rc.help > MAX_INT)\n                throw new Error(\"Too many bytes outstanding, \"+\n                                \"file too large!\");\n        }\n        rc.range = (rc.range << 8) >>> 0;/*ensure result remains positive*/\n        rc.low = ((rc.low << 8) & (Top_value - 1)) >>> 0; /* unsigned */\n        rc.bytecount++;\n    }\n};\n\n/* Start the encoder                                         */\n/* c is written as the first byte in the datastream.\n    * one could do w/o, but then you have an additional if per output byte */\nRangeCoder.prototype.encodeStart = function(c, initlength) {\n    this.low = 0;\n    this.range = Top_value;\n    this.buffer = c;\n    this.help = 0;\n    this.bytecount = initlength;\n};\n\n/* Encode a symbol using frequencies                         */\n/* rc is the range coder to be used                          */\n/* sy_f is the interval length (frequency of the symbol)     */\n/* lt_f is the lower end (frequency sum of < symbols)        */\n/* tot_f is the total interval length (total frequency sum)  */\n/* or (faster): tot_f = (code_value)1<<shift                             */\nRangeCoder.prototype.encodeFreq = function(sy_f, lt_f, tot_f) {\n    enc_normalize(this, this.stream);\n    var r = (this.range / tot_f) >>> 0; // note coercion to integer\n    var tmp = r * lt_f;\n    this.low += tmp;\n    if ((lt_f + sy_f) < tot_f) {\n        this.range = r * sy_f;\n    } else {\n        this.range -= tmp;\n    }\n};\nRangeCoder.prototype.encodeShift = function(sy_f, lt_f, shift) {\n    enc_normalize(this, this.stream);\n    var r = this.range >>> shift;\n    var tmp = r * lt_f;\n    this.low += tmp;\n    if ((lt_f + sy_f) >>> shift) {\n        this.range -= tmp;\n    } else {\n        this.range = r * sy_f;\n    }\n};\n/* Encode a bit w/o modelling. */\nRangeCoder.prototype.encodeBit = function(b) {\n    this.encodeShift(1, b?1:0, 1);\n};\n/* Encode a byte w/o modelling. */\nRangeCoder.prototype.encodeByte = function(b) {\n    this.encodeShift(1, b, 8);\n};\n/* Encode a short w/o modelling. */\nRangeCoder.prototype.encodeShort = function(s) {\n    this.encodeShift(1, s, 16);\n};\n\n/* Finish encoding                                           */\n/* returns number of bytes written                           */\nRangeCoder.prototype.encodeFinish = function() {\n    var outputStream = this.stream;\n    enc_normalize(this, outputStream);\n    this.bytecount += 5;\n    var tmp = this.low >>> SHIFT_BITS;\n    if ((this.low & (Bottom_value-1)) >= ((this.bytecount&0xFFFFFF)>>>1)) {\n        tmp++;\n    }\n    if (tmp > 0xFF) { /* we have a carry */\n        outputStream.writeByte(this.buffer + 1);\n        for (; this.help; this.help--)\n            outputStream.writeByte(0x00);\n    } else { /* no carry */\n        outputStream.writeByte(this.buffer);\n        for (; this.help; this.help--)\n            outputStream.writeByte(0xFF);\n    }\n    outputStream.writeByte(tmp & 0xFF);\n    // XXX: i'm pretty sure these could be three arbitrary bytes\n    //      they are consumed by the decoder at the end\n    outputStream.writeByte((this.bytecount >>> 16) & 0xFF);\n    outputStream.writeByte((this.bytecount >>>  8) & 0xFF);\n    outputStream.writeByte((this.bytecount       ) & 0xFF);\n    return this.bytecount;\n};\n\n/* Start the decoder; you need to provide the *second* byte from the\n    * datastream. (The first byte was provided to startEncoding and is\n    * ignored by the decoder.)\n    */\nRangeCoder.prototype.decodeStart = function(skipInitialRead) {\n    var c = skipInitialRead ? 0 : this.stream.readByte();\n    if (typeof(c) !== 'number' || c < 0) {\n        return c; // EOF\n    }\n    this.buffer = this.stream.readByte();\n    this.low = this.buffer >>> (8 - EXTRA_BITS);\n    this.range = 1 << EXTRA_BITS;\n    return c;\n};\n\nvar dec_normalize = function(rc, inputStream) {\n    while (rc.range <= Bottom_value) {\n        rc.low = (rc.low << 8) | ((rc.buffer << EXTRA_BITS) & 0xFF);\n        /* rc.low could be negative here; don't fix it quite yet */\n        rc.buffer = inputStream.readByte();\n        rc.low |= rc.buffer >>> (8-EXTRA_BITS);\n        rc.low = rc.low >>> 0; /* fix it now */\n        rc.range = (rc.range << 8) >>> 0; /* ensure stays positive */\n    }\n};\n\n/* Calculate cumulative frequency for next symbol. Does NO update!*/\n/* rc is the range coder to be used                          */\n/* tot_f is the total frequency                              */\n/* or: totf is (code_value)1<<shift                                      */\n/* returns the <= cumulative frequency                         */\nRangeCoder.prototype.decodeCulFreq = function(tot_f) {\n    dec_normalize(this, this.stream);\n    this.help = (this.range / tot_f) >>> 0; // note coercion to integer\n    var tmp = (this.low / this.help) >>> 0; // again\n    return (tmp >= tot_f ? tot_f-1 : tmp);\n};\nRangeCoder.prototype.decodeCulShift = function(shift) {\n    dec_normalize(this, this.stream);\n    this.help = this.range >>> shift;\n    var tmp = (this.low / this.help) >>> 0; // coercion to unsigned\n    // shift is less than 31, so shift below will remain positive\n    return ((tmp>>>shift) ? (1<<shift)-1 : tmp);\n};\n\n/* Update decoding state                                     */\n/* rc is the range coder to be used                          */\n/* sy_f is the interval length (frequency of the symbol)     */\n/* lt_f is the lower end (frequency sum of < symbols)        */\n/* tot_f is the total interval length (total frequency sum)  */\nRangeCoder.prototype.decodeUpdate = function(sy_f, lt_f, tot_f) {\n    var tmp = this.help * lt_f; // should not overflow!\n    this.low -= tmp;\n    if (lt_f + sy_f < tot_f) {\n        this.range = (this.help * sy_f);\n    } else {\n        this.range -= tmp;\n    }\n};\n\n/* Decode a bit w/o modelling. */\nRangeCoder.prototype.decodeBit = function() {\n    var tmp = this.decodeCulShift(1);\n    this.decodeUpdate(1, tmp, 1<<1);\n    return tmp;\n};\n/* decode a byte w/o modelling */\nRangeCoder.prototype.decodeByte = function() {\n    var tmp = this.decodeCulShift(8);\n    this.decodeUpdate(1, tmp, 1<<8);\n    return tmp;\n};\n/* decode a short w/o modelling */\nRangeCoder.prototype.decodeShort = function() {\n    var tmp = this.decodeCulShift(16);\n    this.decodeUpdate(1, tmp, 1<<16);\n    return tmp;\n};\n\n/* Finish decoding */\nRangeCoder.prototype.decodeFinish = function() {\n    /* normalize to use up all bytes */\n    dec_normalize(this, this.stream);\n};\n\n/** Utility functions */\n\n// bitstream interface\nRangeCoder.prototype.writeBit = RangeCoder.prototype.encodeBit;\nRangeCoder.prototype.readBit = RangeCoder.prototype.decodeBit;\n\n// stream interface\nRangeCoder.prototype.writeByte = RangeCoder.prototype.encodeByte;\nRangeCoder.prototype.readByte = RangeCoder.prototype.decodeByte;\n\nmodule.exports = RangeCoder;\n","'use strict';\n\n// Object.freeze(), or a thunk if that method is not present in this\n// JavaScript environment.\n\nif (Object.freeze) {\n    module.exports = Object.freeze;\n} else {\n    module.exports = function(o) { return o; };\n}\n","/** Big-Endian Bit Stream, implemented on top of a (normal byte) stream. */\nconst Stream = require('./Stream');\n\nvar BitStream = function(stream) {\n    (function() {\n        var bufferByte = 0x100; // private var for readers\n        this.readBit = function() {\n            if ((bufferByte & 0xFF) === 0) {\n                var ch = stream.readByte();\n                if (ch === Stream.EOF) {\n                    this._eof = true;\n                    return ch; /* !!! */\n                }\n                bufferByte = (ch << 1) | 1;\n            }\n            var bit = (bufferByte & 0x100) ? 1 : 0;\n            bufferByte <<= 1;\n            return bit;\n        };\n        // seekable iff the provided stream is\n        this.seekBit = function(pos) {\n            var n_byte = pos >>> 3;\n            var n_bit = pos - (n_byte*8);\n            this.seek(n_byte);\n            this._eof = false;\n            this.readBits(n_bit);\n        };\n        this.tellBit = function() {\n            var pos = stream.tell() * 8;\n            var b = bufferByte;\n            while ((b & 0xFF) !== 0) {\n                pos--;\n                b <<= 1;\n            }\n            return pos;\n        };\n        // implement byte stream interface as well.\n        this.readByte = function() {\n            if ((bufferByte & 0xFF) === 0) {\n                return stream.readByte();\n            }\n            return this.readBits(8);\n        };\n        this.seek = function(pos) {\n            stream.seek(pos);\n            bufferByte = 0x100;\n        };\n    }).call(this);\n    (function() {\n        var bufferByte = 1; // private var for writers\n        this.writeBit = function(b) {\n            bufferByte <<= 1;\n            if (b) { bufferByte |= 1; }\n            if (bufferByte & 0x100) {\n                stream.writeByte(bufferByte & 0xFF);\n                bufferByte = 1;\n            }\n        };\n        // implement byte stream interface as well\n        this.writeByte = function(_byte) {\n            if (bufferByte===1) {\n                stream.writeByte(_byte);\n            } else {\n                stream.writeBits(8, _byte);\n            }\n        };\n        this.flush = function() {\n            while (bufferByte !== 1) {\n                this.writeBit(0);\n            }\n            if (stream.flush) { stream.flush(); }\n        };\n    }).call(this);\n};\n// inherit read/write methods from Stream.\nBitStream.EOF = Stream.EOF;\nBitStream.prototype = Object.create(Stream.prototype);\n// bit chunk read/write\nBitStream.prototype.readBits = function(n) {\n    var i, r = 0, b;\n    if (n > 31) {\n        r = this.readBits(n-16)*0x10000; // fp multiply, not shift\n        return r + this.readBits(16);\n    }\n    for (i = 0; i < n; i++) {\n        r <<= 1; // this could make a negative value if n>31\n        // bits read past EOF are all zeros!\n        if (this.readBit() > 0) { r++; }\n    }\n    return r;\n};\nBitStream.prototype.writeBits = function(n, value) {\n    if (n > 32) {\n        var low = (value & 0xFFFF);\n        var high = (value - low) / (0x10000); // fp division, not shift\n        this.writeBits(n-16, high);\n        this.writeBits(16, low);\n        return;\n    }\n    var i;\n    for (i = n-1; i >= 0; i--) {\n        this.writeBit( (value >>> i) & 1 );\n    }\n};\n\nmodule.exports = BitStream;\n","/** Simple \"lack of model\" -- just encode the bits directly.\n *  Useful especially with sparse spaces or Huffman coders where there's\n *  no obvious prediction to be made that will pay for itself.\n */\nconst BitStream = require('./BitStream');\nconst Util = require('./Util');\n\nvar NoModel = function(bitstream, size) {\n  this.bitstream = bitstream;\n  this.bits = Util.fls(size-1);\n};\nNoModel.factory = function(bitstream) {\n  return function(size) { return new NoModel(bitstream, size); };\n};\nNoModel.prototype.encode = function(symbol) {\n  var i;\n  for (i=this.bits-1; i>=0; i--) {\n    var b = (symbol >>> i) & 1;\n    this.bitstream.writeBit(b);\n  }\n};\nNoModel.prototype.decode = function() {\n  var i, r = 0;\n  for (i=this.bits-1; i>=0; i--) {\n    r <<= 1;\n    if (this.bitstream.readBit()) r++;\n  }\n  return r;\n};\n\n/** Brain-dead self-test. */\nNoModel.MAGIC = 'nomo';\nNoModel.compressFile = Util.compressFileHelper(NoModel.MAGIC, function(inStream, outStream, fileSize, props) {\n    var bitstream = new BitStream(outStream);\n    var model = new NoModel(bitstream, (fileSize<0) ? 257 : 256);\n    Util.compressWithModel(inStream, fileSize, model);\n    bitstream.flush();\n});\nNoModel.decompressFile = Util.decompressFileHelper(NoModel.MAGIC, function(inStream, outStream, fileSize) {\n    var bitstream = new BitStream(inStream);\n    var model = new NoModel(bitstream, (fileSize<0) ? 257 : 256);\n    Util.decompressWithModel(outStream, fileSize, model);\n});\n\nmodule.exports = NoModel;\n","/** Range coding model based on Fenwick trees for O(ln N) query/update. */\nconst RangeCoder = require('./RangeCoder');\nconst Stream = require('./Stream');\nconst Util = require('./Util');\n\n/** We store two probabilities in a U32, so max prob is going to be 0xFFFF */\nvar DEFAULT_MAX_PROB = 0xFF00;\nvar DEFAULT_INCREMENT= 0x0100;\n\nvar ESC_MASK = 0x0000FFFF, ESC_SHIFT = 0;\nvar SYM_MASK = 0xFFFF0000, SYM_SHIFT = 16;\nvar SCALE_MASK=0xFFFEFFFE;\n\nvar FenwickModel = function(coder, size, max_prob, increment) {\n    this.coder = coder;\n    this.numSyms = size + 1; // save space for an escape symbol\n    this.tree = Util.makeU32Buffer(this.numSyms*2);\n    this.increment = (+increment) || DEFAULT_INCREMENT;\n    this.max_prob = (+max_prob) || DEFAULT_MAX_PROB;\n    // sanity-check to prevent overflow.\n    console.assert((this.max_prob + (this.increment-1)) <= 0xFFFF);\n    console.assert(size <= 0xFFFF);\n    // record escape probability as 1.\n    var i;\n    for (i=0; i<size; i++) {\n        this.tree[this.numSyms + i] = // escape prob=1, sym prob = 0\n            (1 << ESC_SHIFT) | (0 << SYM_SHIFT);\n    }\n    this.tree[this.numSyms + i] = // escape prob = 0, sym prob = 1\n        (0 << ESC_SHIFT) | (this.increment << SYM_SHIFT);\n    this._sumTree();\n    // probability sums are in this.tree[1].  this.tree[0] is unused.\n};\nFenwickModel.factory = function(coder, max_prob, increment) {\n    return function(size) {\n        return new FenwickModel(coder, size, max_prob, increment);\n    };\n};\nFenwickModel.prototype.clone = function() {\n    var newModel = new FenwickModel(this.coder, this.size,\n                                    this.max_prob, this.increment);\n    var i;\n    for (i=1; i<this.tree.length; i++) {\n        newModel.tree[i] = this.tree[i];\n    }\n    return newModel;\n};\nFenwickModel.prototype.encode = function(symbol) {\n    var i = this.numSyms + symbol;\n    var sy_f = this.tree[i];\n    var mask = SYM_MASK, shift = SYM_SHIFT;\n    var update = (this.increment << SYM_SHIFT);\n\n    if ((sy_f & SYM_MASK) === 0) { // escape!\n        this.encode(this.numSyms-1);\n        mask = ESC_MASK;\n        update -= (1<<ESC_SHIFT); // not going to escape no mo'\n        shift = ESC_SHIFT;\n    } else if (symbol === (this.numSyms-1) &&\n            ((this.tree[1] & ESC_MASK) >>> ESC_SHIFT) === 1) {\n        // this is the last escape, zero it out\n        update = -this.tree[i];\n    }\n    // sum up the proper lt_f\n    var lt_f = 0;\n    while (i > 1) {\n        var isRight = (i & 1);\n        var parent = (i >>> 1);\n        // if we're the right child, we need to\n        // add the prob from the left child\n        if (isRight) {\n            lt_f += this.tree[2*parent];\n        }\n        // update sums\n        this.tree[i] += update; // increase sym / decrease esc\n        i = parent;\n    }\n    var tot_f = this.tree[1];\n    this.tree[1] += update; // update prob in root\n    sy_f = (sy_f & mask) >>> shift;\n    lt_f = (lt_f & mask) >>> shift;\n    tot_f =(tot_f& mask) >>> shift;\n    this.coder.encodeFreq(sy_f, lt_f, tot_f);\n    // rescale?\n    if ((( this.tree[1] & SYM_MASK ) >>> SYM_SHIFT) >= this.max_prob) {\n        this._rescale();\n    }\n};\nFenwickModel.prototype._decode = function(isEscape) {\n    var mask = SYM_MASK, shift = SYM_SHIFT;\n    var update = (this.increment << SYM_SHIFT);\n    if (isEscape) {\n        mask = ESC_MASK;\n        update -= (1 << ESC_SHIFT);\n        shift = ESC_SHIFT;\n    }\n    var tot_f = (this.tree[1] & mask) >>> shift;\n    var prob = this.coder.decodeCulFreq(tot_f);\n    // travel down the tree looking for this\n    var i = 1, lt_f = 0;\n    while (i < this.numSyms) {\n        this.tree[i] += update;\n        // look at probability in left child.\n        var leftProb = (this.tree[2*i] & mask) >>> shift;\n        i *= 2;\n        if ((prob-lt_f) >= leftProb) {\n            lt_f += leftProb;\n            i++; // take the right child.\n        }\n    }\n    var symbol = i - this.numSyms;\n    var sy_f = (this.tree[i] & mask) >>> shift;\n    this.tree[i] += update;\n    this.coder.decodeUpdate(sy_f, lt_f, tot_f);\n    // was this the last escape?\n    if (symbol === (this.numSyms-1) &&\n        ((this.tree[1] & ESC_MASK) >>> ESC_SHIFT) === 1) {\n        update = -this.tree[i]; // zero it out\n        while (i >= 1) {\n            this.tree[i] += update;\n            i = (i >>> 1); // parent\n        }\n    }\n    // rescale?\n    if ((( this.tree[1] & SYM_MASK ) >>> SYM_SHIFT) >= this.max_prob) {\n        this._rescale();\n    }\n    return symbol;\n};\nFenwickModel.prototype.decode = function() {\n    var symbol = this._decode(false); // not escape\n    if (symbol === (this.numSyms-1)) {\n        // this was an escape!\n        symbol = this._decode(true); // an escape!\n    }\n    return symbol;\n};\nFenwickModel.prototype._rescale = function() {\n    var i, prob, noEscape = true;\n    // scale symbols (possible causing them to escape)\n    for (i=0; i < this.numSyms-1; i++) {\n        prob = this.tree[this.numSyms + i];\n        if ((prob & ESC_MASK) !== 0) {\n            // this symbol escapes\n            noEscape = false;\n            continue;\n        }\n        prob = (prob & SCALE_MASK) >>> 1;\n        if (prob === 0) {\n            // this symbol newly escapes\n            prob = (1 << ESC_SHIFT);\n            noEscape = false;\n        }\n        this.tree[this.numSyms + i] = prob;\n    }\n    // scale the escape symbol\n    prob = this.tree[this.numSyms + i];\n    prob = (prob & SCALE_MASK) >>> 1;\n    // prob should be zero if there are no escaping symbols, otherwise\n    // it must be at least 1.\n    if (noEscape) { prob = 0; }\n    else if (prob === 0) { prob = (1 << SYM_SHIFT); }\n    this.tree[this.numSyms + i] = prob;\n    // sum it all up afresh\n    this._sumTree();\n};\nFenwickModel.prototype._sumTree = function() {\n    var i;\n    // sum it all. (we know we won't overflow)\n    for (i=this.numSyms - 1; i > 0; i--) {\n        this.tree[i] = this.tree[2*i] + this.tree[2*i + 1];\n    }\n};\n\nFenwickModel.MAGIC = 'fenw';\n/** Simple order-0 compressor, as self-test. */\nFenwickModel.compressFile = Util.compressFileHelper(FenwickModel.MAGIC, function(inStream, outStream, fileSize, props, finalByte) {\n    var range = new RangeCoder(outStream);\n    range.encodeStart(finalByte, 1);\n    var model = new FenwickModel(range, (fileSize<0) ? 257 : 256);\n    Util.compressWithModel(inStream, fileSize, model);\n    range.encodeFinish();\n}, true);\n\n/** Simple order-0 decompresser, as self-test. */\nFenwickModel.decompressFile = Util.decompressFileHelper(FenwickModel.MAGIC, function(inStream, outStream, fileSize) {\n    var range = new RangeCoder(inStream);\n    range.decodeStart(true/*already read the final byte*/);\n    var model = new FenwickModel(range, (fileSize<0) ? 257 : 256);\n    Util.decompressWithModel(outStream, fileSize, model);\n    range.decodeFinish();\n});\n\nmodule.exports = FenwickModel;\n","/** Simple (log n)(n) distance model. */\nconst Util = require('./Util');\n\n// lengthBitsModelFactory will be called with arguments 2, 4, 8, 16, etc\n// and must return an appropriate model or coder.\nvar LogDistanceModel = function(size, extraStates,\n                                lgDistanceModelFactory,\n                                lengthBitsModelFactory) {\n    var i;\n    var bits = Util.fls(size-1);\n    this.extraStates = +extraStates || 0;\n    this.lgDistanceModel = lgDistanceModelFactory(1 + bits + extraStates);\n    // this.distanceModel[n] used for distances which are n-bits long,\n    // but only n-1 bits are encoded: the top bit is known to be one.\n    this.distanceModel = [];\n    for (i=2 ; i <= bits; i++) {\n        var numBits = i - 1;\n        this.distanceModel[i] = lengthBitsModelFactory(1<<numBits);\n    }\n};\n/* you can give this model arguments between 0 and (size-1), or else\n    a negative argument which is one of the 'extra states'. */\nLogDistanceModel.prototype.encode = function(distance) {\n    if (distance < 2) { // small distance or an 'extra state'\n        this.lgDistanceModel.encode(distance + this.extraStates);\n        return;\n    }\n    var lgDistance = Util.fls(distance);\n    console.assert(distance & (1<<(lgDistance-1))); // top bit is set\n    console.assert(lgDistance >= 2);\n    this.lgDistanceModel.encode(lgDistance + this.extraStates);\n    // now encode the rest of the bits.\n    var rest = distance & ((1 << (lgDistance-1)) - 1);\n    this.distanceModel[lgDistance].encode(rest);\n};\nLogDistanceModel.prototype.decode = function() {\n    var lgDistance = this.lgDistanceModel.decode() - this.extraStates;\n    if (lgDistance < 2) {\n        return lgDistance; // this is a small distance or an 'extra state'\n    }\n    var rest = this.distanceModel[lgDistance].decode();\n    return (1 << (lgDistance-1)) + rest;\n};\nmodule.exports = LogDistanceModel;\n","/** Deferred-sum model, suitable for small ( ~ 256 ) ranges. */\n// See http://cbloom.com/src/defsum.zip\n//     http://cbloom.com/papers/context.pdf\nconst RangeCoder = require('./RangeCoder');\nconst Stream = require('./Stream');\nconst Util = require('./Util');\n\nvar LOG_PROB_TOTAL = 8;\nvar PROB_TOTAL = 1 << LOG_PROB_TOTAL;\nvar MAX_ESCAPE_COUNT = 40;\n\nvar DefSumModel = function(coder, size, isDecoder) {\n  var i;\n  console.assert(size < 300); // not meant for sparse\n  var ESCAPE = this.numSyms = size;\n  this.coder = coder;\n  this.prob = Util.makeU16Buffer(size+2); /* size + ESC + 1 */\n  this.escape = Util.makeU16Buffer(size+1);  /* size + 1*/\n  this.update = Util.makeU16Buffer(size+1); /* size + ESC */\n  this.prob[ESCAPE+1] = PROB_TOTAL;\n  for (i=0; i<=this.numSyms; i++) {\n    this.escape[i] = i;\n  }\n  this.updateCount = 0;\n  this.updateThresh = PROB_TOTAL - Math.floor(PROB_TOTAL / 2);\n  if (!isDecoder) { return; }\n  // extra tables for fast decoding\n  this.probToSym = Util.makeU16Buffer(PROB_TOTAL);\n  this.escProbToSym = Util.makeU16Buffer(this.numSyms);\n  for (i=0; i<PROB_TOTAL; i++) {\n    this.probToSym[i] = ESCAPE;\n  }\n  for (i=0; i<this.numSyms; i++) {\n    this.escProbToSym[i] = i;\n  }\n};\nDefSumModel.factory = function(coder, isDecoder) {\n  return function(size) { return new DefSumModel(coder, size, isDecoder); };\n};\nDefSumModel.prototype._update = function(symbol, isDecoder) {\n  if (symbol === this.numSyms) {\n    // some special cases for the escape character\n    if (this.update[symbol] >= MAX_ESCAPE_COUNT) { return; } // hard limit\n    // don't let an escape character trigger an update, because then the\n    // escaped character might find itself unescaped after the tables have\n    // been updated!\n    if (this.updateCount >= (this.updateThresh - 1)) { return; }\n  }\n  this.update[symbol]++;\n  this.updateCount++;\n  // is it time to transfer the updated probabilities?\n  if (this.updateCount < this.updateThresh) {\n    return; //defer update\n  }\n  var cumProb, cumEscProb, odd, i, j, k;\n  this.escape[0] = this.prob[0] = cumProb = cumEscProb = odd = 0;\n  for (i=0; i < this.numSyms+1; i++) {\n    var newProb = ((this.prob[i+1]-this.prob[i]) >>> 1) + this.update[i];\n    if (newProb) {\n      // live 'un\n      this.prob[i] = cumProb;\n      cumProb += newProb;\n      if (newProb & 1) { odd++; }\n      this.escape[i] = cumEscProb;\n    } else {\n      // this symbol will escape\n      this.prob[i] = cumProb;\n      this.escape[i] = cumEscProb;\n      cumEscProb++;\n    }\n  }\n  this.prob[i] = cumProb;\n  console.assert(cumProb === PROB_TOTAL);\n  /* how many updates will be required after current probs are halved? */\n  this.updateThresh = PROB_TOTAL - Math.floor((cumProb-odd) / 2);\n  /* reset the update table */\n  for (i=0; i < (this.numSyms + 1); i++) {\n    this.update[i] = 0;\n  }\n  this.update[this.numSyms] = 1; // ensure that escape never goes away\n  this.updateCount = 1;\n  /* compute decode table, if this is a decoder */\n  if (!isDecoder) { return; }\n  for (i=0, j=0, k=0; i<(this.numSyms+1); i++) {\n    var probLimit = this.prob[i+1];\n    for (; j<probLimit; j++) {\n      this.probToSym[j] = i;\n    }\n    var escProbLimit = this.escape[i+1];\n    for (; k<escProbLimit; k++) {\n      this.escProbToSym[k] = i;\n    }\n  }\n};\nDefSumModel.prototype.encode = function(symbol) {\n  var lt_f = this.prob[symbol];\n  var sy_f = this.prob[symbol+1] - lt_f;\n  console.assert(this.prob[this.numSyms+1] === PROB_TOTAL);\n  if (sy_f) {\n    this.coder.encodeShift(sy_f, lt_f, LOG_PROB_TOTAL);\n    return this._update(symbol);\n  }\n  // escape!\n  console.assert(symbol !== this.numSyms); // catch infinite recursion\n  this.encode(this.numSyms); // guaranteed non-zero probability\n  // code symbol as literal, taking advantage of reduced escape range.\n  lt_f = this.escape[symbol];\n  sy_f = this.escape[symbol+1] - lt_f;\n  var tot_f = this.escape[this.numSyms];\n  this.coder.encodeFreq(sy_f, lt_f, tot_f);\n  return this._update(symbol);\n};\nDefSumModel.prototype.decode = function() {\n  var prob = this.coder.decodeCulShift(LOG_PROB_TOTAL);\n  var symbol = this.probToSym[prob];\n  var lt_f = this.prob[symbol];\n  var sy_f = this.prob[symbol+1] - lt_f;\n  this.coder.decodeUpdate(sy_f, lt_f, PROB_TOTAL);\n  this._update(symbol, true);\n  if (symbol !== this.numSyms) {\n    return symbol;\n  }\n  // escape!\n  var tot_f = this.escape[this.numSyms];\n  prob = this.coder.decodeCulFreq(tot_f);\n  symbol = this.escProbToSym[prob];\n  lt_f = this.escape[symbol];\n  sy_f = this.escape[symbol+1] - lt_f;\n  this.coder.decodeUpdate(sy_f, lt_f, tot_f);\n  this._update(symbol, true);\n  return symbol;\n};\n\nDefSumModel.MAGIC='dfsm';\n/** Simple order-0 compressor, as self-test. */\nDefSumModel.compressFile = Util.compressFileHelper(DefSumModel.MAGIC, function(inStream, outStream, fileSize, props, finalByte) {\n  var range = new RangeCoder(outStream);\n  range.encodeStart(finalByte, 1);\n  var model = new DefSumModel(range, (fileSize<0) ? 257 : 256);\n  Util.compressWithModel(inStream, fileSize, model);\n  range.encodeFinish();\n},true);\n/** Simple order-0 decompresser, as self-test. */\nDefSumModel.decompressFile = Util.decompressFileHelper(DefSumModel.MAGIC, function(inStream, outStream, fileSize) {\n  var range = new RangeCoder(inStream);\n  range.decodeStart(true/*already read the final byte*/);\n  var model = new DefSumModel(range, (fileSize<0) ? 257 : 256, true);\n  Util.decompressWithModel(outStream, fileSize, model);\n  range.decodeFinish();\n});\n\nmodule.exports = DefSumModel;\n","/* Adaptive Huffman code, using Vitter's algorithm ported from\n * vitter.c at http://code.google.com/p/compression-code/downloads/list\n * The original code was placed in the public domain, and so I\n * also place this JavaScript port in the public domain.\n *   -- C. Scott Ananian <cscott@cscott.net>, 2013\n * ps. some truly grotty C code in the originally, faithfully ported to\n *     evil comma-operator-using, assignment-in-if-condition JavaScript.\n */\nconst BitStream = require('./BitStream');\nconst Util = require('./Util');\n\n//  This code is adapted from Professor Vitter's\n//  article, Design and Analysis of Dynamic Huffman Codes,\n//  which appeared in JACM October 1987\n\n//  A design trade-off has been made to simplify the\n//  code:  a node's block is determined dynamically,\n//  and the implicit tree structure is maintained,\n//  e.g. explicit node numbers are also implicit.\n\n//  Dynamic Huffman table weight ranking\n//  is maintained per Professor Vitter's\n//  invariant (*) for algorithm FGK:\n\n//  leaves precede internal nodes of the\n//  same weight in a non-decreasing ranking\n//  of weights using implicit node numbers:\n\n//  1) leaves slide over internal nodes, internal nodes\n//  swap over groups of leaves, leaves are swapped\n//  into group leader position, but two internal\n//  nodes never change positions relative\n//  to one another.\n\n//  2) weights are incremented by 2:\n//  leaves always have even weight values;\n//  internal nodes always have odd values.\n\n//  3) even node numbers are always right children;\n//  odd numbers are left children in the tree.\n\n//  node 2 * HuffSize - 1 is always the tree root;\n//  node HuffEsc is the escape node;\n\n//  the tree is initialized by creating an\n//  escape node as the root.\n\n//  each new leaf symbol is paired with a new escape\n//  node into the previous escape node in the tree,\n//  until the last symbol which takes over the\n//  tree position of the escape node, and\n//  HuffEsc is left at zero.\n\n//  overall table size: 2 * HuffSize\n\n//  huff_init(alphabet_size, potential symbols used)\n//  huff_encode(next_symbol)\n//  next_symbol = huff_decode()\n\n//  huff_scale(by_bits) -- scale weights and re-balance tree\n\nvar HTable = function(up, down, symbol, weight) {\n    this.up = up; // next node up the tree\n    this.down = down; // pair of down nodes\n    this.symbol = symbol;       // node symbol value\n    this.weight = weight;       // node weight\n};\nHTable.prototype.clone = function() {\n  return new HTable(this.up, this.down, this.symbol, this.weight);\n};\nHTable.prototype.set = function(htable) {\n  this.up = htable.up;\n  this.down = htable.down;\n  this.symbol = htable.symbol;\n  this.weight = htable.weight;\n};\n\n//  initialize an adaptive coder\n//  for alphabet size, and count\n//  of nodes to be used\nvar Huffman = function(size, root, bitstream, max_weight) {\n  var i;\n  //  default: all alphabet symbols are used\n\n  console.assert(size && typeof(size)==='number');\n  if( !root || root > size )\n      root = size;\n\n  //  create the initial escape node\n  //  at the tree root\n\n  if ( root <<= 1 ) {\n      root--;\n  }\n\n  // create root+1 htables (coding table)\n  // XXX this could be views on a backing Uint32 array?\n  this.table = [];\n  for (i=0; i<=root; i++) {\n    this.table[i] = new HTable(0,0,0,0);\n  }\n\n  // this.map => mapping for symbols to nodes\n  this.map = [];\n  // this.size => the alphabet size\n  if( this.size = size ) {\n    for (i=0; i<size; i++) {\n      this.map[i] = 0;\n    }\n  }\n\n  // this.esc  => the current tree height\n  // this.root => the root of the tree\n  this.esc = this.root = root;\n\n  if (bitstream) {\n    this.readBit = bitstream.readBit.bind(bitstream);\n    this.writeBit = bitstream.writeBit.bind(bitstream);\n  }\n  this.max_weight = max_weight; // may be null or undefined\n}\n// factory interface\nHuffman.factory = function(bitstream, max_weight) {\n  return function(size) {\n    return new Huffman(size, size, bitstream, max_weight);\n  };\n};\n\n\n// split escape node to incorporate new symbol\n\nHuffman.prototype.split = function(symbol) {\n  var pair, node;\n\n  //  is the tree already full???\n\n  if( pair = this.esc ) {\n    this.esc--;\n  } else {\n    console.assert(false);\n    return 0;\n  }\n\n  //  if this is the last symbol, it moves into\n  //  the escape node's old position, and\n  //  this.esc is set to zero.\n\n  //  otherwise, the escape node is promoted to\n  //  parent a new escape node and the new symbol.\n\n  if( node = this.esc ) {\n    this.table[pair].down = node;\n    this.table[pair].weight = 1;\n    this.table[node].up = pair;\n    this.esc--;\n  } else {\n    pair = 0;\n    node = 1;\n  }\n\n  //  initialize the new symbol node\n\n  this.table[node].symbol = symbol;\n  this.table[node].weight = 0;\n  this.table[node].down = 0;\n  this.map[symbol] = node;\n\n  //  initialize a new escape node.\n\n  this.table[this.esc].weight = 0;\n  this.table[this.esc].down = 0;\n  this.table[this.esc].up = pair;\n  return node;\n};\n\n//  swap leaf to group leader position\n//  return symbol's new node\n\nHuffman.prototype.leader = function(node) {\n  var weight = this.table[node].weight;\n  var leader = node, prev, symbol;\n\n  while( weight === this.table[leader + 1].weight ) {\n    leader++;\n  }\n\n  if( leader === node ) {\n    return node;\n  }\n\n  // swap the leaf nodes\n\n  symbol = this.table[node].symbol;\n  prev = this.table[leader].symbol;\n\n  this.table[leader].symbol = symbol;\n  this.table[node].symbol = prev;\n  this.map[symbol] = leader;\n  this.map[prev] = node;\n  return leader;\n};\n\n//  slide internal node up over all leaves of equal weight;\n//  or exchange leaf with next smaller weight internal node\n\n//  return node's new position\n\nHuffman.prototype.slide = function(node) {\n  var next = node;\n  var swap;\n\n  swap = this.table[next++].clone();\n\n  // if we're sliding an internal node, find the\n  // highest possible leaf to exchange with\n\n  if( swap.weight & 1 ) {\n    while( swap.weight > this.table[next + 1].weight ) {\n      next++;\n    }\n  }\n\n  //  swap the two nodes\n\n  this.table[node].set(this.table[next]);\n  this.table[next].set(swap);\n\n  this.table[next].up = this.table[node].up;\n  this.table[node].up = swap.up;\n\n  //  repair the symbol map and tree structure\n\n  if( swap.weight & 1 ) {\n    this.table[swap.down].up = next;\n    this.table[swap.down - 1].up = next;\n    this.map[this.table[node].symbol] = node;\n  } else {\n    this.table[this.table[node].down - 1].up = node;\n    this.table[this.table[node].down].up = node;\n    this.map[swap.symbol] = next;\n  }\n\n  return next;\n};\n\n//  increment symbol weight and re balance the tree.\n\nHuffman.prototype.increment = function(node) {\n  var up;\n\n  //  obviate swapping a parent with its child:\n  //    increment the leaf and proceed\n  //    directly to its parent.\n\n  //  otherwise, promote leaf to group leader position in the tree\n\n  if( this.table[node].up === node + 1 ) {\n    this.table[node].weight += 2;\n    node++;\n  } else {\n    node = this.leader (node);\n  }\n\n  //  increase the weight of each node and slide\n  //  over any smaller weights ahead of it\n  //  until reaching the root\n\n  //  internal nodes work upwards from\n  //  their initial positions; while\n  //  symbol nodes slide over first,\n  //  then work up from their final\n  //  positions.\n\n  while( this.table[node].weight += 2, up = this.table[node].up ) {\n    while( this.table[node].weight > this.table[node + 1].weight ) {\n        node = this.slide (node);\n    }\n\n    if( this.table[node].weight & 1 ) {\n        node = up;\n    } else {\n        node = this.table[node].up;\n    }\n  }\n\n  /* Re-scale if necessary. */\n  if (this.max_weight) {\n    if (this.table[this.root].weight >= this.max_weight) {\n      this.scale(1);\n    }\n  }\n};\n\n//  scale all weights and re-balance the tree\n\n//  zero weight nodes are removed from the tree\n//  by sliding them out the left of the rank list\n\nHuffman.prototype.scale = function(bits) {\n  var node = this.esc, weight, prev;\n\n  //  work up the tree from the escape node\n  //  scaling weights by the value of bits\n\n  while( ++node <= this.root ) {\n    //  recompute the weight of internal nodes;\n    //  slide down and out any unused ones\n\n    if( this.table[node].weight & 1 ) {\n      if( weight = this.table[this.table[node].down].weight & ~1 ) {\n        weight += this.table[this.table[node].down - 1].weight | 1;\n      }\n\n      //  remove zero weight leaves by incrementing HuffEsc\n      //  and removing them from the symbol map.  take care\n\n    } else if( !(weight = this.table[node].weight >> bits & ~1) ) {\n      if( this.map[this.table[node].symbol] = 0, this.esc++ ) {\n        this.esc++;\n      }\n    }\n\n    // slide the scaled node back down over any\n    // previous nodes with larger weights\n\n    this.table[node].weight = weight;\n    prev = node;\n\n    while( weight < this.table[--prev].weight ) {\n      this.slide(prev);\n    }\n  }\n\n  // prepare a new escape node\n\n  this.table[this.esc].down = 0;\n};\n\n//  send the bits for an escaped symbol\n\nHuffman.prototype.sendid = function(symbol) {\n  var empty = 0, max;\n\n  //  count the number of empty symbols\n  //  before the symbol in the table\n\n  while( symbol-- ) {\n    if( !this.map[symbol] ) {\n      empty++;\n    }\n  }\n\n  //  send LSB of this count first, using\n  //  as many bits as are required for\n  //  the maximum possible count\n\n  if( max = this.size - Math.floor((this.root - this.esc) / 2) - 1 ) {\n    do {\n      this.writeBit(empty & 1);\n      empty >>= 1;\n    } while( max >>= 1 );\n  }\n};\n\n//  encode the next symbol\n\nHuffman.prototype.encode = function(symbol) {\n  var emit = 1, bit;\n  var up, idx, node;\n\n  if( symbol < this.size ) {\n    node = this.map[symbol];\n  } else {\n    console.assert(false);\n    return;\n  }\n\n  //  for a new symbol, direct the receiver to the escape node\n  //  but refuse input if table is already full.\n\n  if( !(idx = node) ) {\n    if( !(idx = this.esc) ) {\n      return;\n    }\n  }\n\n  //  accumulate the code bits by\n  //  working up the tree from\n  //  the node to the root\n\n  while( up = this.table[idx].up ) {\n    emit <<= 1; emit |= idx & 1; idx = up;\n  }\n\n  //  send the code, root selector bit first\n\n  while( bit = emit & 1, emit >>= 1 ) {\n    this.writeBit(bit);\n  }\n\n  //  send identification and incorporate\n  //  new symbols into the tree\n\n  if( !node ) {\n    this.sendid(symbol);\n    node = this.split(symbol);\n  }\n\n  //  adjust and re-balance the tree\n\n  this.increment(node);\n};\n\n//  read the identification bits\n//  for an escaped symbol\n\nHuffman.prototype.readid = function() {\n  var empty = 0, bit = 1, max, symbol;\n\n  //  receive the symbol, LSB first, reading\n  //  only the number of bits necessary to\n  //  transmit the maximum possible symbol value\n\n  if( max = this.size - Math.floor((this.root - this.esc) / 2) - 1 ) {\n    do {\n      empty |= this.readBit() ? bit : 0;\n      bit <<= 1;\n    } while( max >>= 1 );\n  }\n\n  //  the count is of unmapped symbols\n  //  in the table before the new one\n\n  for( symbol = 0; symbol < this.size; symbol++ ) {\n    if( !this.map[symbol] ) {\n      if( !empty-- ) {\n        return symbol;\n      }\n    }\n  }\n\n  //  oops!  our count is too big, either due\n  //  to a bit error, or a short node count\n  //  given to huff_init.\n\n  console.assert(false);\n  return 0;\n};\n\n//  decode the next symbol\n\nHuffman.prototype.decode = function() {\n  var node = this.root;\n  var symbol, down;\n\n  //  work down the tree from the root\n  //  until reaching either a leaf\n  //  or the escape node.  A one\n  //  bit means go left, a zero\n  //  means go right.\n\n  while( down = this.table[node].down ) {\n    if( this.readBit() ) {\n      node = down - 1;  // the left child precedes the right child\n    } else {\n      node = down;\n    }\n  }\n\n  //  sent to the escape node???\n  //  refuse to add to a full tree\n\n  if( node === this.esc ) {\n    if( this.esc ) {\n      symbol = this.readid ();\n      node = this.split (symbol);\n    } else {\n      console.assert(false);\n      return 0;\n    }\n  } else {\n    symbol = this.table[node].symbol;\n  }\n\n  //  increment weights and re-balance\n  //  the coding tree\n\n  this.increment (node);\n  return symbol;\n};\n\n// stand alone compressor, mostly for testing\nHuffman.MAGIC = 'huff';\nHuffman.compressFile = Util.compressFileHelper(Huffman.MAGIC, function(input, output, size, props) {\n  var bitstream = new BitStream(output);\n\n  var alphabetSize = 256;\n  if (size < 0) { alphabetSize++; }\n  var huff = new Huffman(257, alphabetSize, bitstream, 8191);\n  Util.compressWithModel(input, size, huff);\n  bitstream.flush();\n});\n\n// stand alone decompresser, again for testing\nHuffman.decompressFile = Util.decompressFileHelper(Huffman.MAGIC, function(input, output, size) {\n  var bitstream = new BitStream(input);\n\n  var alphabetSize = 256;\n  if (size < 0) { alphabetSize++; }\n  var huff = new Huffman(257, alphabetSize, bitstream, 8191);\n  Util.decompressWithModel(output, size, huff);\n});\n\nmodule.exports = Huffman;\n","/** A simple context-1 model. */\nconst BitStream = require('./BitStream');\nconst Huffman = require('./Huffman');\nconst Util = require('./Util');\n\nvar Context1Model = function(modelFactory, contextSize, alphabetSize) {\n  var i;\n  this.literalModel = [];\n  // even if there's an EOF symbol, we don't need a context for it!\n  for (i=0; i<contextSize; i++) {\n    this.literalModel[i] = modelFactory(alphabetSize);\n  }\n};\nContext1Model.prototype.encode = function(ch, context) {\n  this.literalModel[context].encode(ch);\n};\nContext1Model.prototype.decode = function(context) {\n  return this.literalModel[context].decode();\n};\n\n/** Simple self-test. */\nContext1Model.MAGIC='ctx1';\nContext1Model.compressFile = Util.compressFileHelper(Context1Model.MAGIC, function(inStream, outStream, fileSize, props) {\n  var bitstream = new BitStream(outStream);\n  var alphabetSize = 256;\n  if (fileSize < 0) { alphabetSize++; }\n  var coder = Huffman.factory(bitstream, 8191);\n  var model = new Context1Model(coder, 256, alphabetSize);\n  var lastchar = 0x20;\n  var modelp = {\n    encode: function(symbol) {\n      model.encode(symbol, lastchar);\n      lastchar = symbol;\n    }\n  };\n  Util.compressWithModel(inStream, fileSize, modelp);\n  bitstream.flush();\n});\nContext1Model.decompressFile = Util.decompressFileHelper(Context1Model.MAGIC, function(inStream, outStream, fileSize) {\n  var bitstream = new BitStream(inStream);\n  var alphabetSize = 256;\n  if (fileSize < 0) { alphabetSize++; }\n  var coder = Huffman.factory(bitstream, 8191);\n  var model = new Context1Model(coder, 256, alphabetSize);\n  var lastchar = 0x20;\n  var modelp = {\n    decode: function() {\n      var symbol = model.decode(lastchar);\n      lastchar = symbol;\n      return symbol;\n    }\n  };\n  Util.decompressWithModel(outStream, fileSize, modelp);\n});\n\nmodule.exports = Context1Model;\n","/** Burrows-Wheeler transform, computed with the Induced Sorting Suffix Array\n *  construction mechanism (sais).  Code is a port of:\n *    https://sites.google.com/site/yuta256/sais\n *  which is:\n *    Copyright (c) 2008-2010 Yuta Mori All Rights Reserved.\n *  and licensed under an MIT/X11 license.  I generally looked at both\n *  the C and the Java implementations to guide my work.\n *\n * This JavaScript port is:\n *    Copyright (c) 2013 C. Scott Ananian\n * and licensed under GPLv2; see the README at the top level of this package.\n */\nconst freeze = require('./freeze');\nconst Util = require('./Util');\n\nvar ASSERT = console.assert.bind(console);\n\n// we're dispensing with the \"arbitrary alphabet\" stuff of the source\n// and just using Uint8Arrays.\n\n/** Find the start or end of each bucket. */\nvar getCounts = function(T, C, n, k) {\n    var i;\n    for (i = 0; i < k; i++) { C[i] = 0; }\n    for (i = 0; i < n; i++) { C[T[i]]++; }\n};\nvar getBuckets = function(C, B, k, end) {\n    var i, sum = 0;\n    if (end) {\n        for (i = 0; i < k; i++) { sum += C[i]; B[i] = sum; }\n    } else {\n        for (i = 0; i < k; i++) { sum += C[i]; B[i] = sum - C[i]; }\n    }\n};\n\n/** Sort all type LMS suffixes */\nvar LMSsort = function(T, SA, C, B, n, k) {\n    var b, i, j;\n    var c0, c1;\n    /* compute SAl */\n    if (C === B) { getCounts(T, C, n, k); }\n    getBuckets(C, B, k, false); /* find starts of buckets */\n    j = n - 1;\n    b = B[c1 = T[j]];\n    j--;\n    SA[b++] = (T[j] < c1) ? ~j : j;\n    for (i = 0; i < n; i++) {\n        if ((j = SA[i]) > 0) {\n            ASSERT(T[j] >= T[j+1]);\n            if ((c0 = T[j]) !== c1) { B[c1] = b; b = B[c1 = c0]; }\n            ASSERT(i < b);\n            j--;\n            SA[b++] = (T[j] < c1) ? ~j : j;\n            SA[i] = 0;\n        } else if (j < 0) {\n            SA[i] = ~j;\n        }\n    }\n    /* compute SAs */\n    if (C === B) { getCounts(T, C, n, k); }\n    getBuckets(C, B, k, 1); /* find ends of buckets */\n    for (i = n-1, b = B[c1 = 0]; i >= 0; i--) {\n        if ((j = SA[i]) > 0) {\n            ASSERT(T[j] <= T[j+1]);\n            if ((c0 = T[j]) !== c1) { B[c1] = b; b = B[c1 = c0]; }\n            ASSERT(b <= i);\n            j--;\n            SA[--b] = (T[j] > c1) ? ~(j+1) : j;\n            SA[i] = 0;\n        }\n    }\n};\n\nvar LMSpostproc = function(T, SA, n, m) {\n    var i, j, p, q, plen, qlen, name;\n    var c0, c1;\n    var diff;\n\n    /* compact all the sorted substrings into the first m items of SA\n        * 2*m must not be larger than n (provable) */\n    ASSERT(n > 0);\n    for (i = 0; (p = SA[i]) < 0; i++) { SA[i] = ~p; ASSERT((i+1) < n); }\n    if (i < m) {\n        for (j = i, i++; ; i++) {\n            ASSERT(i < n);\n            if ((p = SA[i]) < 0) {\n                SA[j++] = ~p; SA[i] = 0;\n                if (j === m) { break; }\n            }\n        }\n    }\n\n    /* store the length of all substrings */\n    c0 = T[i = j = n - 1];\n    do { c1 = c0; } while ( ((--i) >= 0 ) && ((c0=T[i]) >= c1) );\n    for (; i >= 0; ) {\n        do { c1 = c0; } while ( ((--i) >= 0 ) && ((c0=T[i]) <= c1) );\n        if (i >= 0) {\n            SA[m + ((i + 1) >>> 1)] = j - i; j = i + 1;\n            do { c1 = c0; } while ( ((--i) >= 0 ) && ((c0=T[i]) >= c1) );\n        }\n    }\n\n    /* find the lexicographic names of all substrings */\n    for (i = 0, name = 0, q = n, qlen = 0; i < m; i++) {\n        p = SA[i]; plen = SA[m + (p >>> 1)]; diff = true;\n        if ((plen === qlen) && ((q + plen) < n)) {\n            for (j = 0; (j < plen) && (T[p + j] === T[q + j]); ) { j++; }\n            if (j === plen) { diff = false; }\n        }\n        if (diff) { name++; q = p; qlen = plen; }\n        SA[m + (p >>> 1)] = name;\n    }\n\n    return name;\n};\n\n/* compute SA and BWT */\nvar induceSA = function(T, SA, C, B, n, k) {\n    var b, i, j;\n    var c0, c1;\n    /* compute SAl */\n    if (C === B) { getCounts(T, C, n, k); }\n    getBuckets(C, B, k, false); /* find starts of buckets */\n    j = n - 1;\n    b = B[c1 = T[j]];\n    SA[b++] = ((j > 0) && (T[j-1] < c1)) ? ~j : j;\n    for (i = 0; i < n; i++) {\n        j = SA[i]; SA[i] = ~j;\n        if (j > 0) {\n            j--;\n            ASSERT( T[j] >= T[j + 1] );\n            if ((c0 = T[j]) !== c1) { B[c1]  = b; b = B[c1=c0]; }\n            ASSERT( i < b );\n            SA[b++] = ((j > 0) && (T[j-1] < c1)) ? ~j : j;\n        }\n    }\n    /* compute SAs */\n    if (C === B) { getCounts(T, C, n, k); }\n    getBuckets(C, B, k, true); /* find ends of buckets */\n    for (i = n-1, b = B[c1 = 0]; i >= 0; i--) {\n        if ((j = SA[i]) > 0) {\n            j--;\n            ASSERT( T[j] <= T[j + 1] );\n            if ((c0 = T[j]) !== c1) { B[c1] = b; b = B[c1 = c0]; }\n            ASSERT( b <= i );\n            SA[--b] = ((j === 0) || (T[j - 1] > c1)) ? ~j : j;\n        } else {\n            SA[i] = ~j;\n        }\n    }\n};\n\nvar computeBWT = function(T, SA, C, B, n, k) {\n    var b, i, j, pidx = -1;\n    var c0, c1;\n    /* compute SAl */\n    if (C === B) { getCounts(T, C, n, k); }\n    getBuckets(C, B, k, false); /* find starts of buckets */\n    j = n - 1;\n    b = B[c1 = T[j]];\n    SA[b++] = ((j > 0) && (T[j - 1] < c1)) ? ~j : j;\n    for (i = 0; i < n; i++) {\n        if ((j=SA[i]) > 0) {\n            j--;\n            ASSERT( T[j] >= T[j+1] );\n            SA[i] = ~(c0 = T[j]);\n            if (c0 !== c1) { B[c1] = b; b = B[c1 = c0]; }\n            ASSERT( i < b );\n            SA[b++] = ((j > 0) && (T[j - 1] < c1)) ? ~j : j;\n        } else if (j !== 0) {\n            SA[i] = ~j;\n        }\n    }\n    /* compute SAs */\n    if (C === B) { getCounts(T, C, n, k); }\n    getBuckets(C, B, k, true); /* find ends of buckets */\n    for (i = n-1, b = B[c1 = 0]; i >= 0; i--) {\n        if ((j = SA[i]) > 0) {\n            j--;\n            ASSERT( T[j] <= T[j+1] );\n            SA[i] = c0 = T[j];\n            if (c0 !== c1) { B[c1] = b; b = B[c1 = c0]; }\n            ASSERT( b <= i );\n            SA[--b] = ((j > 0) && (T[j-1] > c1)) ? (~T[j-1]) : j;\n        } else if (j !== 0) {\n            SA[i] = ~j;\n        } else {\n            pidx = i;\n        }\n    }\n    return pidx;\n};\n\n/* find the suffix array SA of T[0..n-1] in {0..k-1}^n\n    use a working space (excluding T and SA) of at most 2n+O(1) for a\n    constant alphabet */\nvar SA_IS = function(T, SA, fs, n, k, isbwt) {\n    var C, B, RA;\n    var i, j, b, c, m, p, q, name, pidx = 0, newfs;\n    var c0, c1;\n    var flags = 0;\n\n    // allocate temporary storage [CSA]\n    if (k <= 256) {\n        C = Util.makeS32Buffer(k);\n        if (k <= fs) { B = SA.subarray(n + fs - k); flags = 1; }\n        else { B = Util.makeS32Buffer(k); flags = 3; }\n    } else if (k <= fs) {\n        C = SA.subarray(n + fs - k);\n        if (k <= (fs - k)) { B = SA.subarray(n + fs - k * 2); flags = 0; }\n        else if (k <= 1024) { B = Util.makeS32Buffer(k); flags = 2; }\n        else { B = C; flags = 8; }\n    } else {\n        C = B = Util.makeS32Buffer(k);\n        flags = 4 | 8;\n    }\n\n    /* stage 1: reduce the problem by at least 1/2\n        sort all the LMS-substrings */\n    getCounts(T, C, n, k);\n    getBuckets(C, B, k, true); /* find ends of buckets */\n    for (i = 0; i < n; i++) { SA[i] = 0; }\n    b = -1; i = n - 1; j = n; m = 0; c0 = T[n - 1];\n    do { c1 = c0; } while ((--i >= 0) && ((c0 = T[i]) >= c1));\n    for (; i >= 0 ;) {\n        do { c1 = c0; } while ((--i >= 0) && ((c0 = T[i]) <= c1));\n        if ( i >= 0 ) {\n            if ( b >= 0 ) { SA[b] = j; }\n            b = --B[c1];\n            j = i;\n            ++m;\n            do { c1 = c0; } while ((--i >= 0) && ((c0 = T[i]) >= c1));\n        }\n    }\n\n    if (m > 1) {\n        LMSsort(T, SA, C, B, n, k);\n        name = LMSpostproc(T, SA, n, m);\n    } else if (m === 1) {\n        SA[b] = j + 1;\n        name = 1;\n    } else {\n        name = 0;\n    }\n\n    /* stage 2: solve the reduced problem\n        recurse if names are not yet unique */\n    if(name < m) {\n        if((flags & 4) !== 0) { C = null; B = null; }\n        if((flags & 2) !== 0) { B = null; }\n        newfs = (n + fs) - (m * 2);\n        if((flags & (1 | 4 | 8)) === 0) {\n            if((k + name) <= newfs) { newfs -= k; }\n            else { flags |= 8; }\n        }\n        ASSERT( (n >>> 1) <= (newfs + m) );\n        for (i = m + (n >>> 1) - 1, j = m * 2 + newfs - 1; m <= i; i--) {\n            if(SA[i] !== 0) { SA[j--] = SA[i] - 1; }\n        }\n        RA = SA.subarray(m + newfs);\n        SA_IS(RA, SA, newfs, m, name, false);\n        RA = null;\n\n        i = n - 1; j = m * 2 - 1; c0 = T[n - 1];\n        do { c1 = c0; } while ((--i >= 0) && ((c0 = T[i]) >= c1));\n        for (; i >= 0 ;) {\n            do { c1 = c0; } while ((--i >= 0) && ((c0 = T[i]) <= c1));\n            if ( i >= 0 ) {\n                SA[j--] = i + 1;\n                do { c1 = c0; } while ((--i >= 0) && ((c0 = T[i]) >= c1));\n            }\n        }\n\n        for (i = 0; i < m; i++) { SA[i] = SA[m + SA[i]]; }\n        if((flags & 4) !== 0) { C = B = Util.makeS32Buffer(k); }\n        if((flags & 2) !== 0) { B = Util.makeS32Buffer(k); }\n    }\n\n    /* stage 3: induce the result for the original problem */\n    if((flags & 8) !== 0) { getCounts(T, C, n, k); }\n    /* put all left-most S characters into their buckets */\n    if (m > 1) {\n        getBuckets(C, B, k, true); /* find ends of buckets */\n        i = m - 1; j = n; p = SA[m - 1]; c1 = T[p];\n        do {\n            q = B[c0 = c1];\n            while (q < j) { SA[--j] = 0; }\n            do {\n                SA[--j] = p;\n                if(--i < 0) { break; }\n                p = SA[i];\n            } while((c1 = T[p]) === c0);\n        } while (i >= 0 );\n        while ( j > 0 ) { SA[--j] = 0; }\n    }\n    if (!isbwt) { induceSA(T, SA, C, B, n, k); }\n    else { pidx = computeBWT(T, SA, C, B, n, k); }\n    C = null; B = null;\n    return pidx;\n};\n\nvar BWT = Object.create(null);\n/** SA should be a Int32Array (signed!); T can be any typed array.\n *  alphabetSize is optional if T is an Uint8Array or Uint16Array. */\nBWT.suffixsort = function(T, SA, n, alphabetSize) {\n    ASSERT( T && SA && T.length >= n && SA.length >= n );\n    if (n <= 1) {\n        if (n === 1) { SA[0] = 0; }\n        return 0;\n    }\n    if (!alphabetSize) {\n        if (T.BYTES_PER_ELEMENT === 1) { alphabetSize = 256; }\n        else if (T.BYTES_PER_ELEMENT === 2) { alphabetSize = 65536; }\n        else throw new Error('Need to specify alphabetSize');\n    }\n    ASSERT( alphabetSize > 0 );\n    if (T.BYTES_PER_ELEMENT) {\n        ASSERT( alphabetSize <= (1 << (T.BYTES_PER_ELEMENT*8) ) );\n    }\n    return SA_IS(T, SA, 0, n, alphabetSize, false);\n};\n/** Burrows-Wheeler Transform.\n    A should be Int32Array (signed!); T can be any typed array.\n    U is the same type as T (it is used for output).\n    alphabetSize is optional if T is an Uint8Array or Uint16Array.\n    ASSUMES STRING IS TERMINATED WITH AN EOF CHARACTER.\n*/\nBWT.bwtransform = function(T, U, A, n, alphabetSize) {\n    var i, pidx;\n    ASSERT( T && U && A );\n    ASSERT( T.length >= n && U.length >= n && A.length >= n );\n    if (n <= 1) {\n        if (n === 1) { U[0] = T[0]; }\n        return n;\n    }\n    if (!alphabetSize) {\n        if (T.BYTES_PER_ELEMENT === 1) { alphabetSize = 256; }\n        else if (T.BYTES_PER_ELEMENT === 2) { alphabetSize = 65536; }\n        else throw new Error('Need to specify alphabetSize');\n    }\n    ASSERT( alphabetSize > 0 );\n    if (T.BYTES_PER_ELEMENT) {\n        ASSERT( alphabetSize <= (1 << (T.BYTES_PER_ELEMENT*8) ) );\n    }\n    pidx = SA_IS(T, A, 0, n, alphabetSize, true);\n    U[0] = T[n - 1];\n    for (i = 0; i < pidx ; i++) { U[i + 1] = A[i]; }\n    for (i += 1; i < n; i++) { U[i] = A[i]; }\n    return pidx + 1;\n};\n/** Reverses transform above. (ASSUMED STRING IS TERMINATED WITH EOF.) */\nBWT.unbwtransform = function(T, U, LF, n, pidx) {\n    var C = Util.makeU32Buffer(256);\n    var i, t;\n    for (i=0; i<256; i++) { C[i] = 0; }\n    for (i=0; i<n; i++) { LF[i] = C[T[i]]++; }\n    for (i=0, t=0; i<256; i++) { t += C[i]; C[i] = t - C[i]; }\n    for (i=n-1, t=0; i>=0; i--) {\n        t = LF[t] + C[U[i]=T[t]];\n        t += (t<pidx) ? 1 : 0;\n    }\n    C = null;\n};\n\n/** Burrows-Wheeler Transform.\n    A should be Int32Array (signed!); T can be any typed array.\n    U is the same type as T (it is used for output).\n    alphabetSize is optional if T is an Uint8Array or Uint16Array.\n    ASSUMES STRING IS CYCLIC.\n    (XXX: this is twice as inefficient as I'd like! [CSA])\n*/\nBWT.bwtransform2 = function(T, U, n, alphabetSize) {\n    var i, j, pidx = 0;\n    ASSERT( T && U );\n    ASSERT( T.length >= n && U.length >= n );\n    if (n <= 1) {\n        if (n === 1) { U[0] = T[0]; }\n        return 0;\n    }\n    if (!alphabetSize) {\n        if (T.BYTES_PER_ELEMENT === 1) { alphabetSize = 256; }\n        else if (T.BYTES_PER_ELEMENT === 2) { alphabetSize = 65536; }\n        else throw new Error('Need to specify alphabetSize');\n    }\n    ASSERT( alphabetSize > 0 );\n    if (T.BYTES_PER_ELEMENT) {\n        ASSERT( alphabetSize <= (1 << (T.BYTES_PER_ELEMENT*8) ) );\n    }\n    // double length of T\n    var TT;\n    if (T.length >= n*2) {\n        TT = T; // do it in place if possible\n    } else if (alphabetSize <= 256) {\n        TT = Util.makeU8Buffer(n*2);\n    } else if (alphabetSize <= 65536) {\n        TT = Util.makeU16Buffer(n*2);\n    } else {\n        TT = Util.makeU32Buffer(n*2);\n    }\n    if (TT!==T) {\n        for (i=0; i<n; i++) { TT[i] = T[i]; }\n    }\n    for (i=0; i<n; i++) { TT[n+i] = TT[i]; }\n    // sort doubled string\n    var A = Util.makeS32Buffer(n*2);\n    SA_IS(TT, A, 0, n*2, alphabetSize, false);\n    for (i=0, j=0; i<2*n; i++) {\n        var s = A[i];\n        if (s < n) {\n            if (s === 0) { pidx = j; }\n            if (--s < 0) { s = n-1; }\n            U[j++] = T[s];\n        }\n    }\n    ASSERT(j===n);\n    return pidx;\n};\n\nmodule.exports = freeze(BWT);\n","<person-edit>\n\t<style>\n\t\tperson-edit {\n\t\t\tmargin: 3px;\n\t\t\tdisplay: block;\n\t\t}\n\t\ta {\n\t\t\ttext-align: left;\n\t\t\tcolor: purple;\n\t\t}\n\t</style>\n\t<input type=\"text\" value={opts.person.name} oninput={handleName}/> <br>\n\t<input type=\"number\" value={opts.person.phone} oninput={handleNumber}/>\n\t<script>\n\t\tvar self = this;\n\t\thandleName(e) {\n\t\t\tself.opts.person.name = e.target.value;\n\t\t}\n\t\thandleNumber(e) {\n\t\t\tif(e.target.value.toString().length > 11) {\n\t\t\t\te.target.value = e.target.value.substr(0, 11);\n\t\t\t}\n\t\t\tif(isNaN(parseInt(e.target.value.length, 10))) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tself.opts.person.phone = e.target.value;\n\t\t}\n\t</script>\n</person-edit>","/** Simple range coding model w/ escape, suitable for sparse symbol sets.\n *  Uses a move-to-front list, which is simple and relatively performant,\n *  but slows down a lot if you want to try to model escapes more precisely\n *  (which is why this feature is disabled by default).\n */\nconst RangeCoder = require('./RangeCoder');\nconst Stream = require('./Stream');\nconst Util = require('./Util');\n\nvar DEFAULT_MAX_PROB = 0xFF00;\nvar DEFAULT_INCREMENT= 0x0100;\n\nvar NUMERIC_SORT = function(a, b) { return a - b; };\n\nvar MTFModel = function(coder, size, max_prob, increment, betterEscape) {\n    this.coder = coder;\n    this.increment = (+increment) || DEFAULT_INCREMENT;\n    this.max_prob = (+max_prob) || DEFAULT_MAX_PROB;\n    console.assert((this.max_prob + (this.increment-1)) <= 0xFFFF);\n    this.sym = Util.makeU16Buffer(size+1);\n    this.prob= Util.makeU16Buffer(size+2);\n    this.sym[0] = size; // escape code\n    this.prob[0]= 0;\n    this.seenSyms = 1;\n    // total probability always found in this.prob[this.seenSyms]\n    this.prob[this.seenSyms] = this.increment;\n    this.numSyms = size;\n    if (betterEscape) {\n        this.sortedSeen = [size];\n    }\n};\nMTFModel.factory = function(coder, max_prob, increment, betterEscape) {\n    return function(size) {\n        return new MTFModel(coder, size, max_prob, increment, betterEscape);\n    };\n};\nMTFModel.prototype.clone = function() {\n    var newModel = new MTFModel(this.coder, this.numSyms, this.max_prob,\n                                this.increment, !!this.sortedSeen);\n    var i;\n    for (i=0; i<this.seenSyms; i++) {\n        newModel.sym[i] = this.sym[i];\n        newModel.prob[i] = this.prob[i];\n    }\n    newModel.prob[i] = this.prob[i]; // total probability\n    newModel.seenSyms = this.seenSyms;\n    if (this.sortedSeen) {\n        newModel.sortedSeen = this.sortedSeen.slice(0);\n    }\n    return newModel;\n};\nMTFModel.prototype._update = function(symbol, index, sy_f) {\n    var j, tot_f;\n    // move this symbol to the end\n    for (j=index; j<this.seenSyms-1; j++) {\n        this.sym[j] = this.sym[j+1];\n        this.prob[j] = this.prob[j+1] - sy_f;\n    }\n    if (index < this.seenSyms) {\n        this.sym[j] = symbol;\n        this.prob[j] = this.prob[j+1] - sy_f;\n        // increase frequency for this symbol, and total freq at same time\n        this.prob[this.seenSyms] = tot_f =\n            this.prob[this.seenSyms] + this.increment;\n        if (symbol === this.numSyms && this.seenSyms >= this.numSyms) {\n            // this is the last time we'll see an escape! remove it.\n            tot_f = this.prob[--this.seenSyms];\n            if (this.sortedSeen) { this.sortedSeen.length--; }\n        }\n    } else { // add to the end\n        tot_f = this.prob[this.seenSyms];\n        this.sym[index] = symbol;\n        this.prob[index] = tot_f;\n        tot_f += this.increment;\n        this.prob[++this.seenSyms] = tot_f;\n        if (this.sortedSeen) {\n            this.sortedSeen.push(symbol);\n            // hopefully sort is very fast on a mostly-sorted array\n            this.sortedSeen.sort(NUMERIC_SORT);\n        }\n    }\n    if (tot_f >= this.max_prob) { this._rescale(); }\n    return;\n};\nMTFModel.prototype._rescale = function() {\n    var i, j, total=0;\n    var noEscape = true;\n    if (this.sortedSeen) { this.sortedSeen.length = 0; }\n    for(i=0, j=0; i<this.seenSyms; i++) {\n        var sym = this.sym[i];\n        var sy_f = this.prob[i+1] - this.prob[i];\n        sy_f >>>= 1;\n        if (sy_f > 0) {\n            if (sym === this.numSyms) {\n                noEscape = false;\n            }\n            this.sym[j] = sym;\n            this.prob[j++] = total;\n            total += sy_f;\n            if (this.sortedSeen) { this.sortedSeen.push(sym); }\n        }\n    }\n    this.prob[j] = total;\n    this.seenSyms = j;\n    if (this.sortedSeen) {\n        this.sortedSeen.sort(NUMERIC_SORT);\n    }\n    // don't allow escape to go to zero prob if we still need it\n    if (noEscape && this.seenSyms < this.numSyms) {\n        // NOTE this adds this.increment to escape freq; the FenwickModel\n        //      just adds one.\n        this._update(this.numSyms/*escape*/, this.seenSyms/*at end*/);\n    }\n};\nMTFModel.prototype.decode = function() {\n    var tot_f = this.prob[this.seenSyms];\n    var prob = this.coder.decodeCulFreq(tot_f);\n    // we're expecting to find the probability near the \"most recent\" side\n    // of our array\n    var i;\n    for (i=this.seenSyms-1; i>=0; i--) {\n        if (this.prob[i] <= prob /*&& prob < this.prob[i+1]*/)\n            break;\n    }\n    console.assert(i>=0);\n    var symbol = this.sym[i];\n    var lt_f = this.prob[i];\n    var sy_f = this.prob[i + 1] - lt_f;\n    this.coder.decodeUpdate(sy_f, lt_f, tot_f);\n    this._update(symbol, i, sy_f);\n    if (symbol === this.numSyms) {\n        /* this is an escape */\n        /* decode the literal */\n        sy_f = 1;\n        tot_f = this.numSyms;\n        if (this.sortedSeen) {\n            // do a slower, but more precise decoding of the literal\n            // by excluding the already-seen symbols.\n            var seen = this.sortedSeen;\n            tot_f = this.numSyms - this.seenSyms;\n            if (seen[seen.length-1] === this.numSyms) { tot_f++; }\n            symbol = lt_f = this.coder.decodeCulFreq(tot_f);\n            for (i=0; i < seen.length && seen[i] <= symbol ; i++) {\n                symbol++;\n            }\n        } else {\n            symbol = lt_f = this.coder.decodeCulFreq(tot_f);\n        }\n        this.coder.decodeUpdate(sy_f, lt_f, tot_f);\n        this._update(symbol, this.seenSyms);\n    }\n    return symbol;\n};\nMTFModel.prototype.encode = function(symbol) {\n    // look for symbol, from most-recent to oldest\n    var i, sy_f, lt_f, tot_f;\n    for (i=this.seenSyms-1; i>=0; i--) {\n        if (symbol === this.sym[i]) {\n            // ok, found it.\n            lt_f = this.prob[i];\n            sy_f = this.prob[i + 1] - lt_f;\n            tot_f = this.prob[this.seenSyms];\n            this.coder.encodeFreq(sy_f, lt_f, tot_f);\n            return this._update(symbol, i, sy_f);\n        }\n    }\n    // couldn't find this symbol.  encode as escape.\n    console.assert(symbol !== this.numSyms); // catch infinite recursion\n    this.encode(this.numSyms); // guaranteed to be found in the table.\n    // code symbol as literal\n    sy_f = 1;\n    lt_f = symbol;\n    tot_f = this.numSyms;\n    if (this.sortedSeen) {\n        // do a slower, but more precise encoding of the literal\n        // by excluding the already-seen symbols.\n        var seen = this.sortedSeen;\n        tot_f -= this.seenSyms;\n        if (seen[seen.length-1] === this.numSyms) { tot_f++; }\n        for (i=0; i < seen.length && seen[i] < symbol; i++) {\n            lt_f--;\n        }\n    }\n    this.coder.encodeFreq(sy_f, lt_f, tot_f);\n    // now add symbol to the end.\n    return this._update(symbol, this.seenSyms);\n};\n\nMTFModel.MAGIC = 'mtfm';\n/** Simple order-0 compressor, as self-test. */\nMTFModel.compressFile = Util.compressFileHelper(MTFModel.MAGIC, function(inStream, outStream, fileSize, props, finalByte) {\n  var range = new RangeCoder(outStream);\n  range.encodeStart(finalByte, 1);\n  var model = new MTFModel(range, (fileSize<0) ? 257 : 256);\n  Util.compressWithModel(inStream, fileSize, model);\n  range.encodeFinish();\n}, true);\n\n/** Simple order-0 decompresser, as self-test. */\nMTFModel.decompressFile = Util.decompressFileHelper(MTFModel.MAGIC, function(inStream, outStream, fileSize) {\n  var range = new RangeCoder(inStream);\n  range.decodeStart(true/*we already read the 'free' byte*/);\n  var model = new MTFModel(range, (fileSize<0) ? 257 : 256);\n  Util.decompressWithModel(outStream, fileSize, model);\n  range.decodeFinish();\n});\n\nmodule.exports = MTFModel;\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction placeHoldersCount (b64) {\n  var len = b64.length\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n}\n\nfunction byteLength (b64) {\n  // base64 is 4/3 + up to two characters of the original data\n  return (b64.length * 3 / 4) - placeHoldersCount(b64)\n}\n\nfunction toByteArray (b64) {\n  var i, l, tmp, placeHolders, arr\n  var len = b64.length\n  placeHolders = placeHoldersCount(b64)\n\n  arr = new Arr((len * 3 / 4) - placeHolders)\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len\n\n  var L = 0\n\n  for (i = 0; i < l; i += 4) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n    arr[L++] = (tmp >> 16) & 0xFF\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  if (placeHolders === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[L++] = tmp & 0xFF\n  } else if (placeHolders === 1) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp = ((uint8[i] << 16) & 0xFF0000) + ((uint8[i + 1] << 8) & 0xFF00) + (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var output = ''\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    output += lookup[tmp >> 2]\n    output += lookup[(tmp << 4) & 0x3F]\n    output += '=='\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n    output += lookup[tmp >> 10]\n    output += lookup[(tmp >> 4) & 0x3F]\n    output += lookup[(tmp << 2) & 0x3F]\n    output += '='\n  }\n\n  parts.push(output)\n\n  return parts.join('')\n}\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n","var compressjs = require('compressjs');\nvar algorithm = compressjs.Lzp3;\nvar base64js = require('base64-js');\nmodule.exports = {\n\tmakePatient: function (str) {\n\t\tvar bytes = base64js.toByteArray(str);\n        var decoded = (new TextDecoder('utf-8')).decode(bytes);\n        var decompressed = algorithm.decompressFile(compressed);\n        var jsonStr = new Buffer(decompressed).toString('utf8');\n        return JSON.parse(jsonStr);\n\t},\n\tmakeString: function(patient) {\n\t\tvar str = JSON.stringify(patient);\n        var encoder = new TextEncoder('utf-8');\n        var buffer = encoder.encode(str);\n        var compressed = algorithm.compressFile(buffer);\n        var newStr = base64js.fromByteArray(compressed);\n        return newStr;\n\t}\n}","<info-edit>\n\t<div>\n\t\t<textarea style=\"width: 80%; height: 500px;\" onkeypress={handleInput} value={opts.patient.info}></textarea>\n\t</div>\n\t<script>\n\t\tvar self = this;\n\t\thandleInput(e) {\n\t\t\tself.opts.patient.info = e.target.value;\n\t\t}\n\t</script>\n</info-edit>","<conditions-edit>\n\t<style>\n\t\tdiv.condition {\n\t\t\tdisplay: flex;\n\t\t\tflex-direction: row;\n\t\t}\n\t\tbutton.add {\n\t\t\tposition: absolute;\n            bottom: 40px;\n            right: 40px;\n            width: 80px;\n            height: 80px;\n\t\t}\n\t</style>\n\t<div each={name, i in opts.conditions} class=\"condition\">\n\t\t<input type=\"text\" value={name} />\n\t\t<button class=\"del\" onclick={delCondition(i)}>X</button>\n    </div>\n    <button onclick={addCondition} class=\"add\">+</button>\n    <script>\n        var self = this;\n        addCondition() {\n            self.opts.conditions.push(\"Insert issue here\");\n        }\n        delCondition(i) {\n            return function () {\n                self.opts.conditions.splice(i, 1);\n            }\n        }\n\t</script>\n</conditions-edit>","require('./person-edit.tag');\n<contacts-edit>\n    <style>\n        div.person {\n            display: flex;\n            flex-direction: row;\n        }\n        button.add {\n            position: absolute;\n            bottom: 40px;\n            right: 40px;\n            width: 80px;\n            height: 80px;\n        }\n    </style>\n    <div each={person, index in opts.people} class=\"person\" >\n        <person-edit person={person}/>\n        <button class=\"del\" onclick={delPerson(index)}>X</button>\n    </div>\n    <button onclick={addPerson} class=\"add\">+</button>\n    <script>\n        var self = this;\n        addPerson() {\n            self.opts.people.push({\n                name: 'John Doe',\n                phone: '0000000000'\n            })\n        }\n        delPerson(i) {\n            return function () {\n                self.opts.people.splice(i, 1);\n            }\n        }\n    </script>\n</contacts-edit>","require('./person-edit.tag');\nrequire('./contacts-edit.tag');\nrequire('./conditions-edit.tag');\nrequire('./info-edit.tag');\n<app-edit>\n    <style>\n        app-edit {\n            width: 100%;\n            height: 100%;\n            flex-direction: column;\n            display: flex;\n            overflow: hidden;\n        }\n        #content {\n            flex: 1;\n            background-color: lightgrey;\n            padding-left: 20px;\n            overflow: auto;\n            position: relative;\n            top: 0px;\n            left: 0px;\n        }\n        #content > * {\n            display: none;\n        }\n        ul li {\n            list-style-type: none;\n        }\n        ul {\n            margin: 0px;\n            padding: 0px;\n            background-color: blue;\n            display: flex;\n            height: 80px;\n        }\n        li {\n            height: 100%;\n            color: white;\n            display: block;\n            margin: 0px;\n            display: block;\n            width: 80px;\n        }\n        span.spacer {\n            flex: 1;\n        }\n        li > a {\n            display: block;\n            width: 100%;\n            height: 100%;\n            color: white;\n            text-align: center;            \n        }\n        li > button {\n            display: block;\n            width: 80px;;\n            height: 100%;\n            text-align: center;\n        }\n        .selectedButton {\n            background-color: lightblue;\n            border-top: 1px solid red;\n            padding-top: 2px;\n        }\n    </style>\n    <div id=\"content\">\n        <person-edit id=\"self\" person={patient.self} />\n        <contacts-edit id=\"contacts\" people={patient.contacts} />\n        <conditions-edit id=\"conditions\" conditions={patient.conditions} />\n        <info-edit id=\"info\" patient={patient} /> <!--Need object reference for dynamic edits-->\n    </div>\n    <ul>\n        <span class=\"spacer\"/>\n        <li><a onclick={route} id=\"selfButton\">Self</a></li>\n        <li><a onclick={route} id=\"contactsButton\">Contacts</a></li>\n        <li><a onclick={route} id=\"conditionsButton\">Conditions</a></li>\n        <li><a onclick={route} id=\"infoButton\">Info</a></li>\n        <span class=\"spacer\"/>\n        <li><button onclick={submitPatient}>=&gt;</button></li>\n    </ul>\n    <script>\n        var self = this;\n        var patientcoder = require('../patientcoder');\n        var selected;\n        route (e) {\n            if(selected) {\n                document.getElementById(selected+'Button').classList.toggle('selectedButton');\n                document.getElementById(selected).style.display = \"none\";\n            }\n            var id = e.target.textContent.toLowerCase().trim();\n            selected = id;\n            document.getElementById(selected+'Button').classList.toggle('selectedButton');\n            document.getElementById(selected).style.display = \"block\";\n        }\n        self.on('mount', function () {\n            document.getElementById('selfButton').click();\n            self.update();\n        });\n         self.patient = {\n            self: {\n                name: \"Bob bob\",\n                phone: \"1234567890\"\n            },\n            contacts: [\n                {\n                    name: \"Jim jim\",\n                    phone: \"1237894560\"\n                },\n                {\n                    name: \"Joe joe\",\n                    phone: \"1231231234\"\n                }\n            ],\n            conditions: [\n                \"peanut allergy\",\n                \"addiction to dank memes\"\n            ],\n            info: \"my favorite pie tastes like pumpkins\"\n        };\n        submitPatient () {\n            var str = patientcoder.makeString(self.patient);\n            Android.submitPatient(str);\n        }\n    </script>\n</app-edit>","/* *Very* simple de/compression utility, based on simple_c and simple_d from\n * rngcod13.zip at http://www.compressconsult.com/rangecoder/\n * Really just a demonstration/test of the rangecoder.\n */\nconst RangeCoder = require('./RangeCoder');\nconst Stream = require('./Stream');\nconst Util = require('./Util');\n\nvar MAX_BLOCK_SIZE = 1<<17;\n\nvar Simple = Object.create(null);\nSimple.MAGIC = 'smpl';\nSimple.compressFile = Util.compressFileHelper(Simple.MAGIC, function(input, output, size, props, finalByte) {\n    var encoder = new RangeCoder(output);\n    encoder.encodeStart(finalByte, 1);\n\n    // read a block\n    var block = Util.makeU8Buffer(MAX_BLOCK_SIZE);\n    var counts = [];\n    var blockLength = 0, sawEOF = false;\n\n    var readBlock = function() {\n        var pos = 0;\n        // initialize counts\n        for (pos=0; pos < 256; pos++) {\n            counts[pos] = 0;\n        }\n        if (sawEOF) {\n            blockLength = 0;\n            return;\n        }\n        for (pos=0; pos < MAX_BLOCK_SIZE; ) {\n            var c = input.readByte();\n            if (c===Stream.EOF) {\n                sawEOF = true;\n                break;\n            }\n            block[pos++] = c;\n            counts[c]++;\n            // bail if some count reaches maximum\n            if (counts[c]===0xFFFF) {\n                break;\n            }\n        }\n        blockLength = pos;\n    };\n\n    while (true) {\n        var i;\n        readBlock();\n        if (sawEOF && blockLength===0) {\n            break;\n        }\n        // indicate that there's another block comin'\n        encoder.encodeBit(true);\n        // write all the statistics\n        for (i=0; i<256; i++) {\n            encoder.encodeShort(counts[i]);\n        }\n        // convert counts to cumulative counts\n        counts[256] = blockLength;\n        for (i=256; i; i--) {\n            counts[i-1] = counts[i] - counts[i-1];\n        }\n        // encode the symbols using the probability table.\n        for (i=0; i<blockLength; i++) {\n            var ch = block[i];\n            encoder.encodeFreq(counts[ch+1]-counts[ch], counts[ch],\n                                counts[256]);\n        }\n    }\n    // write a stop bit\n    encoder.encodeBit(false);\n    // done!\n    encoder.encodeFinish();\n}, true);\nSimple.decompressFile = Util.decompressFileHelper(Simple.MAGIC, function(input, output, size) {\n    var decoder = new RangeCoder(input);\n    decoder.decodeStart(true/*we already read the 'free' byte*/);\n    while (decoder.decodeBit()) {\n        var i, counts = [];\n        // read all the statistics\n        for (i=0; i<256; i++) {\n            counts[i] = decoder.decodeShort();\n        }\n        // compute cumulative stats & total block size\n        var blocksize = 0;\n        for (i=0; i<256; i++) {\n            var tmp = counts[i];\n            counts[i] = blocksize;\n            blocksize += tmp;\n        }\n        counts[256] = blocksize;\n\n        for (i=0; i<blocksize; i++) {\n            var cf = decoder.decodeCulFreq(blocksize);\n            // inefficient way to look up the symbol.\n            var symbol;\n            for (symbol=0; symbol<256; symbol++)\n                // careful, there are length-0 ranges\n                // (where counts[symbol]===counts[symbol+1])\n                if (counts[symbol]<=cf && cf < counts[symbol+1])\n                    break;\n            var ch = symbol;\n            decoder.decodeUpdate(counts[symbol+1] - counts[symbol],\n                                    counts[symbol], blocksize);\n            output.writeByte(symbol);\n        }\n    }\n    decoder.decodeFinish();\n});\nmodule.exports = Simple;\n","/** Particularly simple-minded implementation of PPM compression. */\nconst RangeCoder = require('./RangeCoder');\nconst Util = require('./Util');\n\nvar MAX_CONTEXT = 5;\nvar LOG_WINDOW_SIZE = 18;\nvar WINDOW_SIZE = 1 << LOG_WINDOW_SIZE;\n\nvar Window = function() {\n  this.buffer = Util.makeU8Buffer(WINDOW_SIZE);\n  this.pos = 0;\n  this.firstPass = true;\n  for (var i=0; i<MAX_CONTEXT; i++) {\n    this.put('cSaCsA'.charCodeAt(i%6));\n  }\n};\nWindow.prototype.put = function(_byte) {\n  this.buffer[this.pos++] = _byte;\n  if (this.pos >= WINDOW_SIZE) { this.pos = 0; this.firstPass = false; }\n  return _byte;\n};\nWindow.prototype.get = function(pos) {\n  return this.buffer[pos & (WINDOW_SIZE-1)];\n};\n// the context ending just before 'pos'\nWindow.prototype.context = function(pos, n) {\n  var c = [], i;\n  pos = (pos - n) & (WINDOW_SIZE-1);\n  for (i=0; i<n; i++) {\n    c.push(this.buffer[pos++]);\n    if (pos >= WINDOW_SIZE) { pos = 0; }\n  }\n  return String.fromCharCode.apply(String, c);\n};\n\nvar DMM_INCREMENT = 0x100, DMM_MAX_PROB = 0xFF00;\n\nvar PPM = function(coder, size) {\n  this.window = new Window();\n  this.contexts = Object.create(null);\n  // brain-dead '-1' context, using full exclusion\n  var Cm1Context = function() { };\n  Cm1Context.prototype.encode = function(symbol, exclude) {\n    var i, lt_f = 0;\n    for (i=0; i<symbol; i++) {\n      if (!exclude[i]) {\n        lt_f++;\n      }\n    }\n    var tot_f = size - exclude.total;\n    coder.encodeFreq(1, lt_f, tot_f);\n  };\n  Cm1Context.prototype.decode = function(exclude) {\n    var i, symbol, lt_f;\n    var tot_f = size - exclude.total;\n    symbol = lt_f = coder.decodeCulFreq(tot_f);\n    for (i=0; i<=symbol; i++) {\n      if (exclude[i]) {\n        symbol++;\n      }\n    }\n    coder.decodeUpdate(1, lt_f, tot_f);\n    return symbol;\n  };\n  this.cm1coder = new Cm1Context();\n\n  var DenseMTFModel = function() {\n    this.sym = [size];\n    this.prob= [0, DMM_INCREMENT];\n    this.refcount = 0;\n  };\n  DenseMTFModel.prototype._rescale = function() {\n    var seenSyms = this.sym.length;\n    var i, j, total=0;\n    var noEscape = true;\n    for(i=0, j=0; i<seenSyms; i++) {\n      var sym = this.sym[i];\n      var sy_f = this.prob[i+1] - this.prob[i];\n      sy_f >>>= 1;\n      if (sy_f > 0) {\n        if (sym === size) {\n          noEscape = false;\n        }\n        this.sym[j] = sym;\n        this.prob[j++] = total;\n        total += sy_f;\n      }\n    }\n    this.prob[j] = total;\n    seenSyms = this.sym.length = j;\n    this.prob.length = seenSyms + 1;\n    // don't allow escape to go to zero prob if we still need it\n    if (noEscape && seenSyms < size) {\n      total = this._update(size/*escape*/, seenSyms/*at end*/, 0, 1);\n    }\n    return total;\n  };\n  DenseMTFModel.prototype.update = function(symbol, incr) {\n    // find symbol\n    var i=0;\n    for (i=0; i<this.sym.length; i++) {\n      if (this.sym[i] === symbol) {\n        return this._update(symbol, i, this.prob[i+1] - this.prob[i], incr);\n      }\n    }\n    // symbol escaped\n    return this._update(symbol, i, 0, incr);\n  };\n  DenseMTFModel.prototype._update = function(symbol, index, sy_f, incr) {\n    var seenSyms = this.sym.length;\n    var i, j, tot_f;\n    // move this symbol to the end\n    for (j=index; j<seenSyms-1; j++) {\n      this.sym[j] = this.sym[j+1];\n      this.prob[j] = this.prob[j+1] - sy_f;\n    }\n    // \"method D\" -- if we add a new escaped symbol, escape & the symbol\n    // both increase by 1/2.\n    if (index < seenSyms) {\n      this.sym[j] = symbol;\n      this.prob[j] = this.prob[j+1] - sy_f;\n      // increase frequency for this symbol, and total freq at same time\n      this.prob[seenSyms] = tot_f =\n        this.prob[seenSyms] + incr;\n    } else { // add to the end\n      tot_f = this.prob[seenSyms];\n      this.sym[index] = symbol;\n      this.prob[index] = tot_f;\n      tot_f += incr;\n      this.prob[++seenSyms] = tot_f;\n      // remove probability of escape if table just filled up\n      if (this.sym.length > size) {\n        for (i=0; i<seenSyms; i++) {\n          if (size === this.sym[i]) {\n            // found it.\n            this._update(size, i, this.prob[i+1] - this.prob[i], -1);\n            this.sym.length--;\n            this.prob.length--;\n            tot_f = this.prob[this.prob.length-1];\n          }\n        }\n      }\n    }\n    if (tot_f >= DMM_MAX_PROB) { tot_f = this._rescale(); }\n    return tot_f;\n  };\n  DenseMTFModel.prototype.encode = function(symbol, exclude) {\n    // look for symbol, from most-recent to oldest\n    var i, j, sy_f, lt_f, tot_f, seenSyms = this.sym.length;\n    var ex_seen = 0, ex_lt_f = 0, ex_tot_f = 0, ex_sy_f;\n    for (i=seenSyms-1; i>=0; i--) {\n      lt_f = this.prob[i];\n      sy_f = this.prob[i + 1] - lt_f;\n      if (symbol === this.sym[i]) {\n        // ok, found it.\n        // count up the rest of the probabilities\n        for (j=i-1; j>=0 && ex_seen < exclude.total; j--) {\n          if (exclude[this.sym[j]]) {\n            ex_seen += 1;\n            ex_sy_f = this.prob[j+1] - this.prob[j];\n            ex_lt_f += ex_sy_f;\n            ex_tot_f += ex_sy_f;\n          }\n        }\n        tot_f = this.prob[seenSyms];\n        // adjust by excluded symbols\n        lt_f -= ex_lt_f;\n        tot_f -= ex_tot_f;\n        coder.encodeFreq(sy_f, lt_f, tot_f);\n        if (symbol === size) { // only update table for escapes\n          this._update(symbol, i, sy_f, DMM_INCREMENT/2);\n          return false; // escape.\n        } // otherwise we'll do update later\n        return true; // encoded character!\n      } else if (exclude[this.sym[i]]) {\n        ex_seen += 1;\n        ex_tot_f += sy_f;\n      }\n    }\n    // couldn't find this symbol.  encode as escape.\n    this.encode(size, exclude);\n    // add symbols to exclusion table\n    console.assert(this.sym[this.sym.length-1] === size);//escape\n    for (i=0; i<this.sym.length-1; i++) {\n      if (!exclude[this.sym[i]]) {\n        exclude[this.sym[i]] = true;\n        exclude.total++;\n      }\n    }\n  };\n  DenseMTFModel.prototype.decode = function(exclude) {\n    var seenSyms = this.sym.length;\n    var tot_f = this.prob[seenSyms];\n    var ex_seen = 0, ex_lt_f = 0, ex_tot_f = 0, ex_sy_f;\n    var i;\n    for (i=seenSyms-1; i>=0 && ex_seen < exclude.total; i--) {\n      if (exclude[this.sym[i]]) {\n        ex_seen += 1;\n        ex_tot_f += this.prob[i+1] - this.prob[i];\n      }\n    }\n    var prob = coder.decodeCulFreq(tot_f - ex_tot_f) + ex_tot_f;\n    // we're expecting to find the probability near the \"most recent\" side\n    // of our array\n    ex_lt_f = ex_tot_f;\n    for (i=seenSyms-1; i>=0; i--) {\n      if (exclude[this.sym[i]]) {\n        ex_sy_f = this.prob[i+1] - this.prob[i];\n        ex_lt_f -= ex_sy_f;\n        prob -= ex_sy_f;\n      } else if (this.prob[i] <= prob /*&& prob < this.prob[i+1]*/)\n        break;\n    }\n    console.assert(i>=0);\n    var symbol = this.sym[i];\n    var lt_f = this.prob[i];\n    var sy_f = this.prob[i + 1] - lt_f;\n    coder.decodeUpdate(sy_f, lt_f - ex_lt_f, tot_f - ex_tot_f);\n    // defer update\n    if (symbol < size) { return symbol; }\n    // an escape\n    this._update(symbol, i, sy_f, DMM_INCREMENT/2);\n    // add symbols to exclusion table\n    console.assert(this.sym[this.sym.length-1] === size);//escape\n    for (i=0; i<this.sym.length-1; i++) {\n      if (!exclude[this.sym[i]]) {\n        exclude[this.sym[i]] = true;\n        exclude.total++;\n      }\n    }\n    return -1;\n  };\n  this.newContext = function(initialSymbol) {\n    return new DenseMTFModel();\n  };\n  this.newExclude = function() {\n    var result = Object.create(null);\n    result.total = 0; // no excluded symbols (yet)\n    return result;\n  };\n  // set up some initial contexts\n  (function() {\n    var i, j;\n    for (i=0; i<MAX_CONTEXT; i++) {\n      for (j=0; j<=i; j++) {\n        var cc = this.window.context(j+((MAX_CONTEXT-1)-i), j);\n        if (!this.contexts[cc]) { this.contexts[cc] = this.newContext(); }\n        this.contexts[cc].refcount++;\n      }\n    }\n  }).call(this);\n};\nPPM.prototype.update = function(symbol, contextString, matchLevel) {\n  // slide up the contexts, updating them\n  var model, c, cc;\n  for (c=0; c <= MAX_CONTEXT; c++) {\n    cc = contextString.slice(MAX_CONTEXT - c);\n    model = this.contexts[cc];\n    if (!model) {\n      model = this.contexts[cc] = this.newContext();\n    }\n    if (c >= matchLevel) {\n      // only update useful contexts\n      model.update(symbol, DMM_INCREMENT / 2);\n    }\n    // refcount all contexts, whether used/updated or not\n    model.refcount++;\n  }\n  // now garbage-collect old contexts\n  contextString = this.window.context(this.window.pos + MAX_CONTEXT,\n                                      MAX_CONTEXT);\n  var firstPass = this.window.firstPass;\n  for (c=MAX_CONTEXT; c>=0 && !firstPass; c--) {\n    cc = contextString.slice(0, c);\n    model = this.contexts[cc];\n    console.assert(model);\n    if ((--model.refcount) <= 0) {\n      console.assert(cc !== ''); // don't allow context-0 to be gc'ed!\n      delete this.contexts[cc];\n    }\n  }\n  // ok, advance window.\n  this.window.put(symbol);\n};\nPPM.prototype.decode = function() {\n  var contextString = this.window.context(this.window.pos, MAX_CONTEXT);\n  var exclude = this.newExclude();\n  var model, c, cc, symbol;\n  for (c=MAX_CONTEXT; c>=0; c--) {\n    cc = contextString.slice(MAX_CONTEXT - c);\n    model = this.contexts[cc];\n    if (model) {\n      symbol = model.decode(exclude);\n      if (symbol >= 0) {\n        this.update(symbol, contextString, c);\n        return symbol;\n      }\n    }\n  }\n  // still no match, fall back to context -1\n  symbol = this.cm1coder.decode(exclude);\n  this.update(symbol, contextString, c);\n  return symbol;\n};\nPPM.prototype.encode = function(symbol) {\n  var contextString = this.window.context(this.window.pos, MAX_CONTEXT);\n  var exclude = this.newExclude();\n  var c;\n  for (c=MAX_CONTEXT; c>=0; c--) {\n    var cc = contextString.slice(MAX_CONTEXT - c);\n    var model = this.contexts[cc];\n    if (model) {\n      var success = model.encode(symbol, exclude);\n      if (success) {\n        this.update(symbol, contextString, c);\n        return;\n      }\n    }\n  }\n  // fall back to context -1 (but still use exclusion table)\n  this.cm1coder.encode(symbol, exclude);\n  this.update(symbol, contextString, c);\n  return;\n};\n\nPPM.MAGIC = 'ppm2';\nPPM.compressFile = Util.compressFileHelper(PPM.MAGIC, function(inStream, outStream, fileSize, props, finalByte) {\n  var range = new RangeCoder(outStream);\n  range.encodeStart(finalByte, 1);\n  var model = new PPM(range, (fileSize<0) ? 257 : 256);\n  Util.compressWithModel(inStream, fileSize, model);\n  range.encodeFinish();\n}, true);\nPPM.decompressFile = Util.decompressFileHelper(PPM.MAGIC, function(inStream, outStream, fileSize) {\n  var range = new RangeCoder(inStream);\n  range.decodeStart(true/*we already read the 'free' byte*/);\n  var model = new PPM(range, (fileSize<0) ? 257 : 256);\n  Util.decompressWithModel(outStream, fileSize, model);\n  range.decodeFinish();\n});\n\nmodule.exports = PPM;\n","/* Implementation of LZP3(ish), with an adaptive Huffman code or a range\n * coder (instead of LZP3's original static Huffman code).\n * See: http://www.cbloom.com/papers/lzp.pdf\n */\nconst BitStream = require('./BitStream');\nconst Context1Model = require('./Context1Model');\nconst DefSumModel = require('./DefSumModel');\nconst FenwickModel = require('./FenwickModel');\nconst Huffman = require('./Huffman');\nconst LogDistanceModel = require('./LogDistanceModel');\nconst NoModel = require('./NoModel');\nconst RangeCoder = require('./RangeCoder');\nconst Stream = require('./Stream');\nconst Util = require('./Util');\n\nvar Lzp3 = Object.create(null);\nLzp3.MAGIC = 'lzp3';\n\n// use Huffman coder (fast) or else use range coder (slow)\nvar USE_HUFFMAN_CODE = false;\n// use deferred-sum model, which is supposed to be faster (but compresses worse)\nvar USE_DEFSUM = false;\n// when to give up attempting to model the length\nvar LENGTH_MODEL_CUTOFF = 256;\nvar MODEL_MAX_PROB = 0xFF00;\nvar MODEL_INCREMENT = 0x100;\n\n// Constants was used for compress/decompress function.\nvar CTXT4_TABLE_SIZE = 1 << 16;\nvar CTXT3_TABLE_SIZE = 1 << 12;\nvar CTXT2_TABLE_SIZE = 1 << 16;\nvar CONTEXT_LEN = 4;\nvar LOG_WINDOW_SIZE = 20;\nvar WINDOW_SIZE = 1 << LOG_WINDOW_SIZE;\nvar MAX_MATCH_LEN = WINDOW_SIZE-1;\nvar MATCH_LEN_CONTEXTS = 16;\n\nvar MAX32 = 0xFFFFFFFF;\nvar MAX24 = 0x00FFFFFF;\nvar MAX16 = 0x0000FFFF;\nvar MAX8  = 0x000000FF;\n\n\nvar Window = function(maxSize) {\n  this.buffer = Util.makeU8Buffer(Math.min(maxSize+4, WINDOW_SIZE));\n  this.pos = 0;\n  // context-4 hash table.\n  this.ctxt4 = Util.makeU32Buffer(CTXT4_TABLE_SIZE);\n  // context-3 hash table\n  this.ctxt3 = Util.makeU32Buffer(CTXT3_TABLE_SIZE);\n  // context-2 table (not really a hash any more)\n  this.ctxt2 = Util.makeU32Buffer(CTXT2_TABLE_SIZE);\n  // initial context\n  this.put(0x63); this.put(0x53); this.put(0x61); this.put(0x20);\n};\nWindow.prototype.put = function(_byte) {\n  this.buffer[this.pos++] = _byte;\n  if (this.pos >= WINDOW_SIZE) { this.pos = 0; }\n  return _byte;\n};\nWindow.prototype.get = function(pos) {\n  return this.buffer[pos & (WINDOW_SIZE-1)];\n};\nWindow.prototype.context = function(pos, n) {\n  var c = 0, i;\n  pos = (pos - n) & (WINDOW_SIZE-1);\n  for (i=0; i<n; i++) {\n    c = (c << 8) | this.buffer[pos++];\n    if (pos >= WINDOW_SIZE) { pos = 0; }\n  }\n  return c;\n};\n// if matchLen !== 0, update the index; otherwise get index value.\nWindow.prototype.getIndex = function(s, matchLen) {\n  var c = this.context(s, 4);\n  // compute context hashes\n  var h4 = ((c>>>15) ^ c) & (CTXT4_TABLE_SIZE-1);\n  var h3 = ((c>>>11) ^ c) & (CTXT3_TABLE_SIZE-1);\n  var h2 = c & MAX16;\n  // check order-4 context\n  var p = 0, checkc;\n  // only do context confirmation if matchLen==0 (that is, if we're not just\n  // doing an update)\n  if (matchLen===0) {\n    p = this.ctxt4[h4];\n    if (p !== 0 && c !== this.context(p-1, 4)) {\n      p = 0; // context confirmation failed\n    }\n    if (p === 0) {\n      // check order-3 context\n      p = this.ctxt3[h3];\n      if (p !== 0 && (c & MAX24) !== this.context(p-1, 3)) {\n        p = 0; // context confirmation failed\n      }\n      if (p === 0) {\n        // check order-2 context\n        p = this.ctxt2[h2];\n        if (p !== 0 && (c && MAX16) !== this.context(p-1, 2)) {\n          p = 0; // context confirmation failed\n        }\n      }\n    }\n  }\n  // update context index\n  if (matchLen) { matchLen--; }\n  this.ctxt4[h4] = this.ctxt3[h3] = this.ctxt2[h2] =\n    (s | (matchLen << LOG_WINDOW_SIZE)) + 1;\n  // return lookup result.\n  return p;\n};\n\n/**\n * Compress using modified LZP3 algorithm.  Instead of using static\n * Huffman coding, we use an adaptive Huffman code or range encoding.\n */\nLzp3.compressFile = Util.compressFileHelper(Lzp3.MAGIC, function(inStream, outStream, fileSize, props) {\n  // sliding window & hash table\n  var window = new Window( (fileSize>=0) ? fileSize : WINDOW_SIZE );\n\n  var coderFactory, sparseCoderFactory, flush;\n\n  if (USE_HUFFMAN_CODE) {\n    // Huffman contexts\n    outStream.writeByte(0x80); // mark that this is Huffman coded.\n    var bitstream = new BitStream(outStream);\n    flush = bitstream.flush.bind(bitstream);\n    coderFactory = Huffman.factory(bitstream, MAX16);\n    sparseCoderFactory = NoModel.factory(bitstream);\n\n  } else { // range encoder\n    var range = new RangeCoder(outStream);\n    range.encodeStart(0x00, 0); // 0x00 == range encoded\n\n    coderFactory = FenwickModel.factory(range, MODEL_MAX_PROB, MODEL_INCREMENT);\n    if (USE_DEFSUM) {\n      coderFactory = DefSumModel.factory(range, false /* encoder */);\n    }\n    // switch sparseCoderFactory to a NoModel when size > cutoff\n    var noCoderFactory = NoModel.factory(range);\n    sparseCoderFactory = function(size) {\n      if (size > LENGTH_MODEL_CUTOFF) {\n        return noCoderFactory(size);\n      }\n      return coderFactory(size);\n    };\n    flush = function() { range.encodeFinish(); };\n  }\n\n  var huffLiteral= new Context1Model(coderFactory, 256,\n                                     (fileSize<0) ? 257 : 256);\n  var huffLen = [], i;\n  for (i=0; i<MATCH_LEN_CONTEXTS; i++) {\n    huffLen[i] = new LogDistanceModel(MAX_MATCH_LEN+1, 1,\n                                      coderFactory, sparseCoderFactory);\n  }\n\n  var inSize = 0, s, matchContext = 0;\n  while (inSize !== fileSize) {\n    var ch = inStream.readByte();\n    s = window.pos;\n    var p = window.getIndex(s, 0);\n    if (p !== 0) {\n      // great, a match! how long is it?\n      p--; // p=0 is used for 'not here'. p=1 really means WINDOW_SIZE\n      var prevMatchLen = (p >>> LOG_WINDOW_SIZE) + 1;\n      var matchLen = 0;\n      while (window.get(p + matchLen) === ch && matchLen < MAX_MATCH_LEN) {\n        matchLen++;\n        window.put(ch);\n        ch = inStream.readByte();\n      }\n      // code match length; match len = 0 means \"literal\"\n      // use \"extra state\" -1 to mean \"same as previous match length\"\n      if (prevMatchLen===matchLen) {\n        huffLen[matchContext&(MATCH_LEN_CONTEXTS-1)].encode(-1);\n      } else {\n        huffLen[matchContext&(MATCH_LEN_CONTEXTS-1)].encode(matchLen);\n      }\n      // update hash with this match\n      window.getIndex(s, matchLen);\n      inSize += matchLen;\n      matchContext <<= 1;\n      if (matchLen > 0) { matchContext |= 1; }\n      // XXX: LZMA uses a special \"delta match\" context here if matchLen==0\n      // XXX: it also uses the offset as context for the length (or vice-versa)\n    }\n    // always encode a literal after a match\n    var context1 = window.get(window.pos-1);\n    if (ch===Stream.EOF) {\n      if (fileSize < 0) {\n        huffLiteral.encode(256, context1);\n      }\n      break;\n    }\n    huffLiteral.encode(ch, context1);\n    window.put(ch);\n    inSize++;\n  }\n  if (flush) flush();\n});\n\n/**\n * Decompress using modified LZP3 algorithm.\n */\nLzp3.decompressFile = Util.decompressFileHelper(Lzp3.MAGIC, function(inStream, outStream, fileSize) {\n  var flags = inStream.readByte();\n  var use_huffman_code = !!(flags & 0x80);\n\n  // sliding window & hash table\n  var window = new Window( (fileSize>=0) ? fileSize : WINDOW_SIZE );\n\n  var coderFactory, sparseCoderFactory, finish;\n\n  if (use_huffman_code) {\n    // Huffman contexts\n    var bitstream = new BitStream(inStream);\n    coderFactory = Huffman.factory(bitstream, MAX16);\n    sparseCoderFactory = NoModel.factory(bitstream);\n  } else { // range encoder\n    var range = new RangeCoder(inStream);\n    range.decodeStart(true/* skip initial read */);\n    coderFactory = FenwickModel.factory(range, MODEL_MAX_PROB, MODEL_INCREMENT);\n    if (USE_DEFSUM) {\n      coderFactory = DefSumModel.factory(range, true /* decoder */);\n    }\n    // switch sparseCoderFactory to a NoModel when size > cutoff\n    var noCoderFactory = NoModel.factory(range);\n    sparseCoderFactory = function(size) {\n      if (size > LENGTH_MODEL_CUTOFF) {\n        return noCoderFactory(size);\n      }\n      return coderFactory(size);\n    };\n    finish = function() { range.decodeFinish(); };\n  }\n\n  var huffLiteral= new Context1Model(coderFactory, 256,\n                                     (fileSize<0) ? 257 : 256);\n  var huffLen = [], i;\n  for (i=0; i<MATCH_LEN_CONTEXTS; i++) {\n    huffLen[i] = new LogDistanceModel(MAX_MATCH_LEN+1, 1,\n                                      coderFactory, sparseCoderFactory);\n  }\n\n  var s, ch, outSize = 0, matchContext = 0;\n  while (outSize !== fileSize) {\n    s = window.pos;\n    var p = window.getIndex(s, 0);\n    if (p !== 0) {\n      p--; // p=0 is used for 'not here'. p=1 really means WINDOW_SIZE\n      var prevMatchLen = (p >>> LOG_WINDOW_SIZE) + 1;\n      var matchLen = huffLen[matchContext&(MATCH_LEN_CONTEXTS-1)].decode();\n      if (matchLen < 0) { matchLen = prevMatchLen; }\n      // copy characters!\n      for (i=0; i<matchLen; i++) {\n        ch = window.get(p + i);\n        outStream.writeByte(window.put(ch));\n      }\n      window.getIndex(s, matchLen);\n      outSize += matchLen;\n      matchContext <<= 1;\n      if (matchLen > 0) matchContext |= 1;\n    }\n    // literal always follows match (or failed match)\n    if (outSize === fileSize) {\n      break; // EOF\n    }\n    var context1 = window.get(window.pos-1);\n    ch = huffLiteral.decode(context1);\n    if (ch === 256) {\n      break; // EOF\n    }\n    outStream.writeByte(window.put(ch));\n    outSize++;\n  }\n  if (finish) finish();\n});\n\n\nmodule.exports = Lzp3;\n","/* Tweaked version of LZJB, using range coder. */\nconst Context1Model = require('./Context1Model');\nconst FenwickModel = require('./FenwickModel');\nconst LogDistanceModel = require('./LogDistanceModel');\nconst NoModel = require('./NoModel');\nconst RangeCoder = require('./RangeCoder');\nconst Stream = require('./Stream');\nconst Util = require('./Util');\n\nvar LzjbR = Object.create(null);\nLzjbR.MAGIC = 'lzjR';\n\n// Constants was used for compress/decompress function.\nvar NBBY = 8,\n    MATCH_BITS = 6,\n    MATCH_MIN = 3,\n    MATCH_MAX = ((1 << MATCH_BITS) + (MATCH_MIN - 1)),\n    OFFSET_MASK = ((1 << (16 - MATCH_BITS)) - 1),\n    LEMPEL_SIZE_BASE = 1024;\nvar LENGTH_MODEL_CUTOFF = 32;\n\n\n/**\n * Compress using modified LZJB algorithm.  Instead of using the simple\n * 9-bit literal / 17-bit match format of the original, use a range\n * coder for the literal/match bit and for the offset and length.\n */\nLzjbR.compressFile = Util.compressFileHelper(LzjbR.MAGIC, function(inStream, outStream, fileSize, props, finalByte) {\n    var sstart, dstart = [], slen,\n        src = 0, dst = 0,\n        cpy, copymap,\n        mlen, offset,\n        hash, hp,\n        lempel,\n        i, j;\n\n    // in an improvement over the original C implementation of LZJB, we expand\n    // the hash table to track a number of potential matches, not just the\n    // most recent.  This doesn't require any changes to the decoder.\n    var LEMPEL_SIZE = LEMPEL_SIZE_BASE;\n    var EXPAND = 1; // default to original C impl\n    if (typeof(props)==='number') {\n        LEMPEL_SIZE *= 2;\n        props = Math.max(1, Math.min(9, props)) - 1;\n        EXPAND = 1<<Math.floor(props/2);\n        if (props&1) EXPAND = Math.round(EXPAND * 1.5);\n        if (props >=2 && props <= 4) EXPAND++;\n    }\n\n    var encoder = new RangeCoder(outStream);\n    encoder.encodeStart(finalByte, 1);\n\n    // use Uint16Array if available (zero-filled)\n    lempel = Util.makeU16Buffer(LEMPEL_SIZE * EXPAND);\n\n    var window = Util.makeU8Buffer(OFFSET_MASK+1);\n    var windowpos = 0;\n    var winput = function(_byte) {\n        window[windowpos++] = _byte;\n        if (windowpos >= window.length) {\n            windowpos = 0;\n        }\n        return _byte;\n    };\n\n    var unbuffer = [];\n    var get = function() {\n        if (unbuffer.length)\n            return unbuffer.pop();\n        return inStream.readByte();\n    };\n    var unget = function(_byte) {\n        unbuffer.push(_byte);\n    };\n\n    var matchpossibility = [];\n    var MATCH = 256;\n    var EOF_SYM = 257;\n    var noModelFactory = NoModel.factory(encoder);\n    var modelFactory = FenwickModel.factory(encoder, 0xFF00, 0x100);\n    var literalModel = new Context1Model(modelFactory, 256,\n                                         ((fileSize<0) ? EOF_SYM : MATCH) + 1);\n    var sparseModelFactory = function(size) {\n        if (size <= LENGTH_MODEL_CUTOFF) { return modelFactory(size); }\n        return noModelFactory(size);\n    };\n    var lenModel = new LogDistanceModel((MATCH_MAX-MATCH_MIN)+1, 0,\n                                        modelFactory, sparseModelFactory);\n    var posModel = new LogDistanceModel(OFFSET_MASK+1, 1,\n                                        modelFactory, sparseModelFactory);\n    var lastChar = 0x20, lastOffset = 0;\n    while (true) {\n        var initialPos = windowpos;\n        var c1 = get();\n        if (c1 === Stream.EOF) break;\n\n        var c2 = get();\n        if (c2 === Stream.EOF) {\n            literalModel.encode(winput(c1), lastChar); // literal, not a match\n            break;\n        }\n        var c3 = get();\n        if (c3 === Stream.EOF) {\n            literalModel.encode(winput(c1), lastChar); // literal, not a match\n            unget(c2); lastChar = c1;\n            continue;\n        }\n\n        hash = (c1 << 16) + (c2 << 8) + c3;\n        hash ^= (hash >> 9);\n        hash += (hash >> 5);\n        hash ^= c1;\n        hp = (hash & (LEMPEL_SIZE - 1)) * EXPAND;\n        matchpossibility.length = 0;\n        for (j=0; j<EXPAND; j++) {\n            offset = (windowpos - lempel[hp+j]) & OFFSET_MASK;\n            cpy = window.length + windowpos - offset;\n            var w1 = window[cpy & OFFSET_MASK];\n            var w2 = window[(cpy+1) & OFFSET_MASK];\n            var w3 = window[(cpy+2) & OFFSET_MASK];\n            // if offset is small, we might not have copied the tentative\n            // bytes into the window yet.  (Note that offset=0 really means\n            // offset=(OFFSET_MASK+1).)\n            if (offset==1) { w2 = c1; w3 = c2; }\n            else if (offset==2) { w3 = c1; }\n            if (c1 === w1 && c2 === w2 && c3 === w3) {\n                matchpossibility.push(offset);\n            }\n        }\n        // store this location in the hash, move the others over to make room\n        // oldest match drops off\n        for (j=EXPAND-1; j>0; j--)\n            lempel[hp+j] = lempel[hp+j-1];\n        lempel[hp] = windowpos;\n        // did we find any matches?\n        if (matchpossibility.length === 0) {\n            literalModel.encode(winput(c1), lastChar); // literal, not a match\n            unget(c3);\n            unget(c2);\n            lastChar = c1;\n        } else {\n            literalModel.encode(MATCH, lastChar); // a match!\n            // find the longest of the possible matches\n            winput(c1); winput(c2); winput(c3); lastChar = c3;\n            var c4 = get(), last = matchpossibility[0];\n            var base = window.length + windowpos;\n            for (mlen = MATCH_MIN; mlen < MATCH_MAX; mlen++, base++) {\n                if (c4 === Stream.EOF) break;\n                for (j=0; j < matchpossibility.length; ) {\n                    var w4 = window[(base - matchpossibility[j]) & OFFSET_MASK];\n                    if (c4 !== w4) {\n                        last = matchpossibility[j];\n                        matchpossibility.splice(j, 1);\n                    } else {\n                        j++;\n                    }\n                }\n                if (matchpossibility.length===0) break; // no more matches\n                winput(c4); lastChar = c4;\n                c4 = get();\n            }\n            if (matchpossibility.length !== 0) {\n                // maximum length match, rock on!\n                last = matchpossibility[0];\n            }\n            unget(c4);\n\n            // encode match length\n            // XXX we could get a bit more compression if we allowed\n            // the length to predict the offset (or vice-versa)\n            lenModel.encode(mlen - MATCH_MIN);\n            offset = (initialPos - last) & OFFSET_MASK;\n            if (offset === lastOffset) {\n                posModel.encode(-1); // common case!\n            } else {\n                posModel.encode(offset);\n                lastOffset = offset;\n            }\n        }\n    }\n    if (fileSize < 0) {\n        literalModel.encode(EOF_SYM, lastChar); // end of file (streaming)\n    }\n    encoder.encodeFinish();\n}, true);\n\n/**\n * Decompress using modified LZJB algorithm.\n */\nLzjbR.decompressFile = Util.decompressFileHelper(LzjbR.MAGIC, function(inStream, outStream, outSize) {\n    var sstart, dstart = [], slen,\n        src = 0, dst = 0,\n        cpy, copymap,\n        mlen, offset,\n        i, c;\n\n    var window = Util.makeU8Buffer(OFFSET_MASK+1);\n    var windowpos = 0;\n\n    var decoder = new RangeCoder(inStream);\n    decoder.decodeStart(true/* we already read the 'free' byte*/);\n\n    var MATCH = 256;\n    var EOF_SYM = 257;\n    var noModelFactory = NoModel.factory(decoder);\n    var modelFactory = FenwickModel.factory(decoder, 0xFF00, 0x100);\n    var literalModel = new Context1Model(modelFactory, 256,\n                                         ((outSize<0) ? EOF_SYM : MATCH) + 1);\n    var sparseModelFactory = function(size) {\n        if (size <= LENGTH_MODEL_CUTOFF) { return modelFactory(size); }\n        return noModelFactory(size);\n    };\n    var lenModel = new LogDistanceModel((MATCH_MAX-MATCH_MIN)+1, 0,\n                                        modelFactory, sparseModelFactory);\n    var posModel = new LogDistanceModel(OFFSET_MASK+1, 1,\n                                        modelFactory, sparseModelFactory);\n    var lastChar = 0x20, lastOffset = 0;\n    while (outSize !== 0) {\n        c = literalModel.decode(lastChar);\n        if (c === EOF_SYM) {\n            break;\n        } else if (c === MATCH) {\n            mlen = lenModel.decode() + MATCH_MIN;\n            cpy = posModel.decode();\n            if (cpy<0) { cpy = lastOffset; }\n            else       { lastOffset = cpy; }\n            if (outSize >= 0) outSize -= mlen;\n            while (--mlen >= 0) {\n                c = lastChar = window[windowpos++] = window[cpy++];\n                outStream.writeByte(c);\n                if (windowpos >= window.length) { windowpos=0; }\n                if (cpy >= window.length) { cpy = 0; }\n            }\n        } else {\n            outStream.writeByte(c);\n            window[windowpos++] = lastChar = c;\n            if (windowpos >= window.length) { windowpos=0; }\n            if (outSize >= 0) outSize--;\n        }\n    }\n    decoder.decodeFinish();\n});\n\nmodule.exports = LzjbR;\n","/* LZJB compression: http://en.wikipedia.org/wiki/LZJB */\nconst Stream = require('./Stream');\nconst Util = require('./Util');\n\n/**\n$Id: Iuppiter.js 3026 2010-06-23 10:03:13Z Bear $\n\nCopyright (c) 2010 Nuwa Information Co., Ltd, and individual contributors.\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n  1. Redistributions of source code must retain the above copyright notice,\n     this list of conditions and the following disclaimer.\n\n  2. Redistributions in binary form must reproduce the above copyright\n     notice, this list of conditions and the following disclaimer in the\n     documentation and/or other materials provided with the distribution.\n\n  3. Neither the name of Nuwa Information nor the names of its contributors\n     may be used to endorse or promote products derived from this software\n     without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n$Author: Bear $\n$Date: 2010-06-23 18:03:13 +0800 (星期三, 23 六月 2010) $\n$Revision: 3026 $\n*/\n\nvar Lzjb = Object.create(null);\nLzjb.MAGIC = 'lzjb';\n\n// Constants was used for compress/decompress function.\nvar NBBY = 8,\n    MATCH_BITS = 6,\n    MATCH_MIN = 3,\n    MATCH_MAX = ((1 << MATCH_BITS) + (MATCH_MIN - 1)),\n    OFFSET_MASK = ((1 << (16 - MATCH_BITS)) - 1),\n    LEMPEL_SIZE_BASE = 1024;\nvar EOF = Stream.EOF;\n\n// set C_COMPAT to true if you need to decompress with the (untweaked) C lzjb\n// implementation, which breaks if offset==0; the javascript\n// implementation uses 0 to indicate an offset of OFFSET_MASK+1.\nvar C_COMPAT = true;\n\n/**\n * Compress string or byte array using fast and efficient algorithm.\n *\n * Because of weak of javascript's natural, many compression algorithm\n * become useless in javascript implementation. The main problem is\n * performance, even the simple Huffman, LZ77/78 algorithm will take many\n * many time to operate. We use LZJB algorithm to do that, it suprisingly\n * fulfills our requirement to compress string fastly and efficiently.\n *\n * Our implementation is based on\n * http://src.opensolaris.org/source/raw/onnv/onnv-gate/usr/src/uts/common/fs/zfs/lzjb.c\n * and\n * http://src.opensolaris.org/source/raw/onnv/onnv-gate/usr/src/uts/common/os/compress.c\n * It is licensed under CDDL.\n *\n * @param {Array|Uint8Array|Buffer|stream} input The stream or byte array\n *        that you want to compress.\n * @param {stream} output Optional output stream.\n * @return {Array|Uint8Array|Buffer} Compressed byte array, or 'output'\n */\nLzjb.compressFile = Util.compressFileHelper(Lzjb.MAGIC, function(inStream, outStream, fileSize, props) {\n    var sstart, dstart = [], slen,\n        src = 0, dst = 0,\n        cpy, copymap,\n        mlen, offset,\n        hash, hp,\n        lempel,\n        i, j;\n    var retval;\n\n    // in an improvement over the original C implementation, we expand\n    // the hash table to track a number of potential matches, not just the\n    // most recent.  This doesn't require any changes to the decoder.\n    // Sample impact on compression size (on wikipedia data):\n    //  EXPAND  Time     Size      Option\n    //    1   0m20.321s  50185613    -1\n    //    2   0m22.437s  46503301    -2\n    //    3   0m23.773s  45744564    -3\n    //    4   0m25.666s  45199866    -4\n    //    5   0m35.810s  44821413    -5\n    //    6   0m40.947s  44666638    -6\n    //    8   0m49.639s  44413865    -7\n    //   12   0m49.927s  44124825    -8\n    //   16   1m01.180s  43972515    -9\n    //   32   1m30.530s  43554099\n    //   64   2m14.504s  43005530\n    //  128   3m43.570s  42361718\n    //  256   6m38.681s  41684853\n    var LEMPEL_SIZE = LEMPEL_SIZE_BASE;\n    var EXPAND = 1; // default to original C impl\n    if (typeof(props)==='number') {\n        LEMPEL_SIZE *= 2;\n        props = Math.max(1, Math.min(9, props)) - 1;\n        EXPAND = 1<<Math.floor(props/2);\n        if (props&1) EXPAND = Math.round(EXPAND * 1.5);\n        if (props >=2 && props <= 4) EXPAND++;\n    }\n\n    // use Uint16Array if available (zero-filled)\n    lempel = Util.makeU16Buffer(LEMPEL_SIZE * EXPAND);\n\n    var window = Util.makeU8Buffer(OFFSET_MASK+1);\n    var windowpos = 0;\n    var winput = function(_byte) {\n        window[windowpos++] = _byte;\n        if (windowpos >= window.length) {\n            windowpos = 0;\n        }\n        return _byte;\n    };\n\n    var outwindow = Util.makeU8Buffer(17);\n    var outpos = 0;\n    var dumpout = function() {\n        var i;\n        for (i=0; i<outpos; i++) {\n            outStream.writeByte(outwindow[i]);\n        }\n        outpos = 0;\n    };\n\n    var unbuffer = [];\n    var get = function() {\n        if (unbuffer.length)\n            return unbuffer.pop();\n        return inStream.readByte();\n    };\n    var unget = function(_byte) {\n        unbuffer.push(_byte);\n    };\n\n    var copymask = 1 << (NBBY - 1);\n    var matchpossibility = [];\n    while (true) {\n        var c1 = get();\n        if (c1 === EOF) break;\n\n        if ((copymask <<= 1) == (1 << NBBY)) {\n            dumpout();\n            copymask = 1;\n            outwindow[0] = 0;\n            outpos = 1;\n        }\n\n        var c2 = get();\n        if (c2 === EOF) {\n            outwindow[outpos++] = winput(c1);\n            break;\n        }\n        var c3 = get();\n        if (c3 === EOF) {\n            outwindow[outpos++] = winput(c1);\n            unget(c2);\n            continue;\n        }\n\n        hash = (c1 << 16) + (c2 << 8) + c3;\n        hash ^= (hash >> 9);\n        hash += (hash >> 5);\n        hash ^= c1;\n        hp = (hash & (LEMPEL_SIZE - 1)) * EXPAND;\n        matchpossibility.length = 0;\n        for (j=0; j<EXPAND; j++) {\n            offset = (windowpos - lempel[hp+j]) & OFFSET_MASK;\n            cpy = window.length + windowpos - offset;\n            var w1 = window[cpy & OFFSET_MASK];\n            var w2 = window[(cpy+1) & OFFSET_MASK];\n            var w3 = window[(cpy+2) & OFFSET_MASK];\n            // if offset is small, we might not have copied the tentative\n            // bytes into the window yet.  (Note that offset=0 really means\n            // offset=(OFFSET_MASK+1).)\n            if (C_COMPAT && offset===0) {\n                w1 = c1 ^ 1; // ensure match will fail\n            } else if (offset==1) { w2 = c1; w3 = c2; }\n            else if (offset==2) { w3 = c1; }\n            if (c1 === w1 && c2 === w2 && c3 === w3) {\n                matchpossibility.push(offset);\n            }\n        }\n        // store this location in the hash, move the others over to make room\n        // oldest match drops off\n        for (j=EXPAND-1; j>0; j--)\n            lempel[hp+j] = lempel[hp+j-1];\n        lempel[hp] = windowpos;\n        // did we find any matches?\n        if (matchpossibility.length === 0) {\n            outwindow[outpos++] = winput(c1);\n            unget(c3);\n            unget(c2);\n        } else {\n            // find the longest of the possible matches\n            outwindow[0] |= copymask;\n            winput(c1); winput(c2); winput(c3);\n            var c4 = get(), last = matchpossibility[0];\n            var base = window.length + windowpos;\n            for (mlen = MATCH_MIN; mlen < MATCH_MAX; mlen++, base++) {\n                if (c4 === EOF) break;\n                for (j=0; j < matchpossibility.length; ) {\n                    var w4 = window[(base - matchpossibility[j]) & OFFSET_MASK];\n                    if (c4 !== w4) {\n                        last = matchpossibility[j];\n                        matchpossibility.splice(j, 1);\n                    } else {\n                        j++;\n                    }\n                }\n                if (matchpossibility.length===0) break; // no more matches\n                winput(c4);\n                c4 = get();\n            }\n            if (matchpossibility.length !== 0) {\n                // maximum length match, rock on!\n                last = matchpossibility[0];\n            }\n            unget(c4);\n\n            outwindow[outpos++] = ((mlen - MATCH_MIN) << (NBBY - MATCH_BITS)) |\n                (last >> NBBY);\n            outwindow[outpos++] = last & 0xFF;\n        }\n    }\n    dumpout();\n});\n\n/**\n * Decompress string or byte array using fast and efficient algorithm.\n *\n * Our implementation is based on\n * http://src.opensolaris.org/source/raw/onnv/onnv-gate/usr/src/uts/common/fs/zfs/lzjb.c\n * and\n * http://src.opensolaris.org/source/raw/onnv/onnv-gate/usr/src/uts/common/os/compress.c\n * It is licensed under CDDL.\n *\n * @param {Array|Uint8Array|Buffer|stream} input The stream or byte array\n *        that you want to decompress.\n * @param {stream} output Optional output stream.\n * @return {Array|Uint8Array|Buffer} Decompressed byte array, or 'output'\n */\nLzjb.decompressFile = Util.decompressFileHelper(Lzjb.MAGIC, function(inStream, outStream, outSize) {\n    var sstart, dstart = [], slen,\n        src = 0, dst = 0,\n        cpy, copymap,\n        mlen, offset,\n        i, c;\n    var retval;\n\n    var window = Util.makeU8Buffer(OFFSET_MASK+1);\n    var windowpos = 0;\n\n    var copymask = 1 << (NBBY - 1);\n\n    while (outSize !== 0) {\n        c = inStream.readByte();\n        if (c === EOF) break;\n\n        if ((copymask <<= 1) == (1 << NBBY)) {\n            copymask = 1;\n            copymap = c;\n            c = inStream.readByte();\n        }\n        if (copymap & copymask) {\n            mlen = (c >> (NBBY - MATCH_BITS)) + MATCH_MIN;\n            offset = ((c << NBBY) | inStream.readByte()) & OFFSET_MASK;\n            cpy = windowpos - offset;\n            if (cpy < 0) cpy += window.length;\n            if (outSize >= 0) outSize -= mlen;\n            while (--mlen >= 0) {\n                c = window[windowpos++] = window[cpy++];\n                outStream.writeByte(c);\n                if (windowpos >= window.length) { windowpos=0; }\n                if (cpy >= window.length) { cpy = 0; }\n            }\n        } else {\n            outStream.writeByte(c);\n            window[windowpos++] = c;\n            if (windowpos >= window.length) { windowpos=0; }\n            if (outSize >= 0) outSize--;\n        }\n    }\n});\n\nmodule.exports = Lzjb;\n","/**\n * Implementation of Dynamic Markov Compression, using byte-oriented\n * nodes/transitions.\n *\n * Currently no model-shrinking is done, so be careful trying to use\n * this on large inputs!\n *\n * Notes for the future / TO DO:\n *\n * Add node merging to Dmc:\n *  - once (total states traversed / total node count) exceeds a certain value\n *    - find the median node w/rt total visits\n *    - combine all nodes w/ less visits into a single node, with transitions\n *      to node[0] - node[255] (initial context-1 states)\n *      - initially transition counts are zero?  or summed from components?\n *        needs to be summed so kirchoff principle holds\n *    - halve the edge counts of all nodes, to provide for adaptation\n *      - enforce property that all nodes point \"higher\" except for\n *        links to nodes 0-255.  So we can resum all nodes in one pass,\n *        after resetting all node.sum to zero. X YES because we know\n *        what the total sum must be, so we can arrange to scale to maintain\n *        proper sum. XXX what about node 0-255? XXX maybe just clear all\n *        edge counts XXX\n *\n * Fix buglet: ensure that kirchoff principle *exactly* holds by\n * paying attention to rounding when we distribute edge counts.  track\n * highest edge and give (desiredSum - newSum) extra counts to that\n * outgoing edge? add one to each nonzero edge until all gone?\n *\n * Split 'to' nodes when to.sum grows too high -- only if we're\n * highest incoming edge?  Fix bug again here with saturating counts;\n * we can't ignore counts w/o violating kirchoff principle, so we need\n * to clone it.  Maybe start trying to clone early (before our counter\n * saturates) so we have a better chance of cloning on the high\n * incoming edge? XXX we don't track incoming edges.  XXX so just\n * clone when we visit.\n */\nconst MTFModel = require('./MTFModel');\nconst RangeCoder = require('./RangeCoder');\nconst Stream = require('./Stream');\nconst Util = require('./Util');\n\n// nm = no model cloning, MAX_TRANS_CNT=0xFF, MAX_MODEL_PROB=0xFFFF\n// nm2 = \"                            0xFFFF                 0xFFFF\n// nm3 = \"                             0xFFF                 0x0FFF\n// nm4 = \"                            0xFFFF                   0xFF\n// cl1 = model cloning, MAX_TRANS_CNT=0xFFFF  MAX_MODEL_PROB=0xFF\n// cl2 = model cloning, MAX_TRANS_CNT=  0xFF  MAX_MODEL_PROB=0xFF\n// cl3 = model cloning, MAX_TRANS_CNT=0xFFFF  MAX_MODEL_PROB=0xFFFF\nvar MAX_TRANS_CNT = 0xFFFF;\nvar DEFAULT_MIN_CNT1 = 8;\nvar DEFAULT_MIN_CNT2 = 128;\nvar MODEL_PROB_MAX = 0xFF00;\nvar MODEL_PROB_INCR= 0x0100;\nvar CLONE_MODELS=false;\nvar PRINT_STATS=false; // for quick benchmarking\n\n// XXX need to limit growth of model (throw away and retrain if model\n//     gets too large)\n\nvar Dmc = Object.create(null);\nDmc.MAGIC = 'dmc!';\n\nvar MarkovNode = function(coder, size, optModel) {\n  this.out = [];\n  this.model = optModel ? optModel.clone() :\n    new MTFModel(coder, size, MODEL_PROB_MAX, MODEL_PROB_INCR);\n  this.count = Util.makeU16Buffer(size);\n  this.sum = 0;\n};\nMarkovNode.prototype.clone = function(coder, size) {\n  var i;\n  var newNode = new MarkovNode(coder, size, CLONE_MODELS ? this.model : null);\n  for (i=0; i<size; i++) {\n    newNode.out[i] = this.out[i];\n  }\n  return newNode;\n};\n\nvar MarkovModel = function(coder, size, MIN_CNT1, MIN_CNT2) {\n  var i, j;\n  // initial model is 'size' states, completely linked.\n  this.coder = coder;\n  this.size = size;\n  this.MIN_CNT1 = MIN_CNT1 || DEFAULT_MIN_CNT1;\n  this.MIN_CNT2 = MIN_CNT2 || DEFAULT_MIN_CNT2;\n  this.nodes = [];\n  for (i=0; i<size; i++) {\n    this.nodes[i] = new MarkovNode(coder, size);\n  }\n  // now link nodes\n  for (i=0; i<size; i++) {\n    for (j=0; j<size; j++) {\n      this.nodes[i].out[j] = this.nodes[j];\n    }\n  }\n  // select an arbitrary node as the start state.\n  this.current = this.nodes[0];\n};\nMarkovModel.prototype.maybeSplit = function(from, symbol, to) {\n  var trans_cnt = from.count[symbol];\n  var next_cnt = to.sum;\n  var i;\n  if ( (trans_cnt <= this.MIN_CNT1) ||\n       (next_cnt - trans_cnt <= this.MIN_CNT2) ) {\n    return to; // no split\n  }\n\n  // split this guy!\n  var newNode = to.clone(this.coder, this.size);\n  this.nodes.push(newNode);\n  from.out[symbol] = newNode;\n  // distribute transition counts among new and cloned node\n  newNode.sum = to.sum = 0;\n  for (i=0; i<this.size; i++) {\n    newNode.count[i] = to.count[i] * trans_cnt / next_cnt;\n    newNode.sum += newNode.count[i];\n    to.count[i] -= newNode.count[i];\n    to.sum += to.count[i];\n  }\n\n  return newNode;\n};\nMarkovModel.prototype.encode = function(symbol) {\n  var from = this.current;\n  from.model.encode(symbol);\n  var to = from.out[symbol];\n  if (from.count[symbol] !== MAX_TRANS_CNT) {\n      from.count[symbol]++;\n      from.sum++;\n  }\n  this.current = this.maybeSplit(from, symbol, to);\n};\nMarkovModel.prototype.decode = function() {\n  var from = this.current;\n  var symbol = from.model.decode();\n  var to = from.out[symbol];\n  if (from.count[symbol] !== MAX_TRANS_CNT) {\n      from.count[symbol]++;\n      from.sum++;\n  }\n  this.current = this.maybeSplit(from, symbol, to);\n  return symbol;\n};\n\nDmc.compressFile = Util.compressFileHelper(Dmc.MAGIC, function(inStream, outStream, fileSize, props) {\n\n  props = props || {};\n  var MIN_CNT1 = (+props.m) || DEFAULT_MIN_CNT1;\n  var MIN_CNT2 = (+props.n) || DEFAULT_MIN_CNT2;\n  Util.writeUnsignedNumber(outStream, MIN_CNT1);\n  Util.writeUnsignedNumber(outStream, MIN_CNT2);\n\n  var range = new RangeCoder(outStream);\n  range.encodeStart(0xCA, 0);\n\n  var mm = new MarkovModel(range, (fileSize<0) ? 257 : 256,\n                           MIN_CNT1, MIN_CNT2);\n  var inSize = 0;\n  while (inSize !== fileSize) {\n    var ch = inStream.readByte();\n    if (ch===Stream.EOF) {\n      mm.encode(256); // end of stream\n      break;\n    }\n    mm.encode(ch);\n    inSize++;\n  }\n  var outSize = range.encodeFinish();\n  if (PRINT_STATS) {\n    console.log('M1', mm.MIN_CNT1, 'M2', mm.MIN_CNT2,\n                'states', mm.nodes.length, 'size', outSize);\n  }\n});\n\nDmc.decompressFile = Util.decompressFileHelper(Dmc.MAGIC, function(inStream, outStream, fileSize) {\n\n  var MIN_CNT1 = Util.readUnsignedNumber(inStream);\n  var MIN_CNT2 = Util.readUnsignedNumber(inStream);\n\n  var range = new RangeCoder(inStream);\n  range.decodeStart();\n\n  var mm = new MarkovModel(range, (fileSize<0) ? 257 : 256,\n                           MIN_CNT1, MIN_CNT2);\n  var outSize = 0;\n  while (outSize !== fileSize) {\n    var ch = mm.decode();\n    if (ch===256) {\n      break; // EOF\n    }\n    outStream.writeByte(ch);\n    outSize++;\n  }\n  range.decodeFinish();\n});\n\nmodule.exports = Dmc;\n","/**\n * An in-place, length restricted Canonical Huffman code length allocator\n *\n * Based on the algorithm proposed by R. L. Milidiú, A. A. Pessoa and\n * E. S. Laber in \"In-place Length-Restricted Prefix Coding\" (see:\n * http://www-di.inf.puc-rio.br/~laber/public/spire98.ps) and\n * incorporating additional ideas from the implementation of \"shcodec\"\n * by Simakov Alexander (see: http://webcenter.ru/~xander/)\n *\n * This JavaScript implementation ported from HuffmanAllocator.java from\n *   https://code.google.com/p/jbzip2\n * which is:\n *\n *   Copyright (c) 2011 Matthew Francis\n *\n *   Permission is hereby granted, free of charge, to any person\n *   obtaining a copy of this software and associated documentation\n *   files (the \"Software\"), to deal in the Software without\n *   restriction, including without limitation the rights to use,\n *   copy, modify, merge, publish, distribute, sublicense, and/or sell\n *   copies of the Software, and to permit persons to whom the\n *   Software is furnished to do so, subject to the following\n *   conditions:\n *\n *   The above copyright notice and this permission notice shall be\n *   included in all copies or substantial portions of the Software.\n *\n *   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n *   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n *   OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n *   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n *   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n *   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n *   FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n *   OTHER DEALINGS IN THE SOFTWARE.\n *\n * This JavaScript implementation is:\n *   Copyright (c) 2013 C. Scott Ananian\n * with the same licensing terms as Matthew Francis' original implementation.\n */\nconst freeze = require('./freeze');\nconst Util = require('./Util');\n\n/**\n * FIRST() function\n * @param array The code length array\n * @param i The input position\n * @param nodesToMove The number of internal nodes to be relocated\n * @return The smallest {@code k} such that {@code nodesToMove <= k <= i} and\n *         {@code i <= (array[k] % array.length)}\n */\nvar first = function(array, i, nodesToMove) {\nvar length = array.length;\nvar limit = i;\nvar k = array.length - 2;\n\nwhile ((i >= nodesToMove) && ((array[i] % length) > limit)) {\n    k = i;\n    i -= (limit - i + 1);\n}\ni = Math.max (nodesToMove - 1, i);\n\nwhile (k > (i + 1)) {\n    var temp = (i + k) >> 1;\n    if ((array[temp] % length) > limit) {\n    k = temp;\n    } else {\n    i = temp;\n    }\n}\n\nreturn k;\n};\n\n/**\n * Fills the code array with extended parent pointers\n * @param array The code length array\n */\nvar setExtendedParentPointers = function(array) {\nvar length = array.length;\n\narray[0] += array[1];\n\nvar headNode, tailNode, topNode, temp;\nfor (headNode = 0, tailNode = 1, topNode = 2;\n        tailNode < (length - 1);\n        tailNode++) {\n    if ((topNode >= length) || (array[headNode] < array[topNode])) {\n    temp = array[headNode];\n    array[headNode++] = tailNode;\n    } else {\n    temp = array[topNode++];\n    }\n\n    if ((topNode >= length) ||\n        ((headNode < tailNode) && (array[headNode] < array[topNode]))) {\n    temp += array[headNode];\n    array[headNode++] = tailNode + length;\n    } else {\n    temp += array[topNode++];\n    }\n\n    array[tailNode] = temp;\n}\n};\n\n/**\n * Finds the number of nodes to relocate in order to achieve a given code\n * length limit\n * @param array The code length array\n * @param maximumLength The maximum bit length for the generated codes\n * @return The number of nodes to relocate\n */\nvar findNodesToRelocate = function(array, maximumLength) {\nvar currentNode = array.length - 2;\nvar currentDepth;\nfor (currentDepth = 1;\n        (currentDepth < (maximumLength - 1)) && (currentNode > 1);\n        currentDepth++) {\n    currentNode =  first (array, currentNode - 1, 0);\n}\n\nreturn currentNode;\n};\n\n\n/**\n * A final allocation pass with no code length limit\n * @param array The code length array\n */\nvar allocateNodeLengths = function(array) {\nvar firstNode = array.length - 2;\nvar nextNode = array.length - 1;\nvar currentDepth, availableNodes, lastNode, i;\n\nfor (currentDepth = 1, availableNodes = 2;\n        availableNodes > 0;\n        currentDepth++) {\n    lastNode = firstNode;\n    firstNode = first (array, lastNode - 1, 0);\n\n    for (i = availableNodes - (lastNode - firstNode); i > 0; i--) {\n    array[nextNode--] = currentDepth;\n    }\n\n    availableNodes = (lastNode - firstNode) << 1;\n}\n};\n\n/**\n * A final allocation pass that relocates nodes in order to achieve a\n * maximum code length limit\n * @param array The code length array\n * @param nodesToMove The number of internal nodes to be relocated\n * @param insertDepth The depth at which to insert relocated nodes\n */\nvar allocateNodeLengthsWithRelocation = function(array, nodesToMove,\n                                                insertDepth) {\nvar firstNode = array.length - 2;\nvar nextNode = array.length - 1;\nvar currentDepth = (insertDepth == 1) ? 2 : 1;\nvar nodesLeftToMove = (insertDepth == 1) ? nodesToMove - 2 : nodesToMove;\nvar availableNodes, lastNode, offset, i;\n\nfor (availableNodes = currentDepth << 1;\n        availableNodes > 0;\n        currentDepth++) {\n    lastNode = firstNode;\n    firstNode = (firstNode <= nodesToMove) ? firstNode : first (array, lastNode - 1, nodesToMove);\n\n    offset = 0;\n    if (currentDepth >= insertDepth) {\n    offset = Math.min (nodesLeftToMove, 1 << (currentDepth - insertDepth));\n    } else if (currentDepth == (insertDepth - 1)) {\n    offset = 1;\n    if ((array[firstNode]) == lastNode) {\n        firstNode++;\n    }\n    }\n\n    for (i = availableNodes - (lastNode - firstNode + offset); i > 0; i--) {\n    array[nextNode--] = currentDepth;\n    }\n\n    nodesLeftToMove -= offset;\n    availableNodes = (lastNode - firstNode + offset) << 1;\n}\n};\n\n/**\n * Allocates Canonical Huffman code lengths in place based on a sorted\n * frequency array\n * @param array On input, a sorted array of symbol frequencies; On output,\n *              an array of Canonical Huffman code lengths\n * @param maximumLength The maximum code length. Must be at least\n *                      {@code ceil(log2(array.length))}\n */\n// public\nvar allocateHuffmanCodeLengths = function(array, maximumLength) {\nswitch (array.length) {\ncase 2:\n    array[1] = 1;\ncase 1:\n    array[0] = 1;\n    return;\n}\n\n/* Pass 1 : Set extended parent pointers */\nsetExtendedParentPointers (array);\n\n/* Pass 2 : Find number of nodes to relocate in order to achieve\n    *          maximum code length */\nvar nodesToRelocate = findNodesToRelocate (array, maximumLength);\n\n/* Pass 3 : Generate code lengths */\nif ((array[0] % array.length) >= nodesToRelocate) {\n    allocateNodeLengths (array);\n} else {\n    var insertDepth = maximumLength - (Util.fls(nodesToRelocate - 1));\n    allocateNodeLengthsWithRelocation (array, nodesToRelocate, insertDepth);\n}\n};\n\nmodule.exports = freeze({\n    allocateHuffmanCodeLengths: allocateHuffmanCodeLengths\n});\n","/* CRC32, used in Bzip2 implementation.\n * This is a port of CRC32.java from the jbzip2 implementation at\n *   https://code.google.com/p/jbzip2\n * which is:\n *   Copyright (c) 2011 Matthew Francis\n *\n *   Permission is hereby granted, free of charge, to any person\n *   obtaining a copy of this software and associated documentation\n *   files (the \"Software\"), to deal in the Software without\n *   restriction, including without limitation the rights to use,\n *   copy, modify, merge, publish, distribute, sublicense, and/or sell\n *   copies of the Software, and to permit persons to whom the\n *   Software is furnished to do so, subject to the following\n *   conditions:\n *\n *   The above copyright notice and this permission notice shall be\n *   included in all copies or substantial portions of the Software.\n *\n *   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n *   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n *   OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n *   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n *   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n *   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n *   FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n *   OTHER DEALINGS IN THE SOFTWARE.\n * This JavaScript implementation is:\n *   Copyright (c) 2013 C. Scott Ananian\n * with the same licensing terms as Matthew Francis' original implementation.\n */\nconst Util = require('./Util');\n\n/**\n * A static CRC lookup table\n */\n  var crc32Lookup = Util.arraycopy(Util.makeU32Buffer(256), [\n  0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9, 0x130476dc, 0x17c56b6b, 0x1a864db2, 0x1e475005,\n  0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61, 0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd,\n  0x4c11db70, 0x48d0c6c7, 0x4593e01e, 0x4152fda9, 0x5f15adac, 0x5bd4b01b, 0x569796c2, 0x52568b75,\n  0x6a1936c8, 0x6ed82b7f, 0x639b0da6, 0x675a1011, 0x791d4014, 0x7ddc5da3, 0x709f7b7a, 0x745e66cd,\n  0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039, 0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5,\n  0xbe2b5b58, 0xbaea46ef, 0xb7a96036, 0xb3687d81, 0xad2f2d84, 0xa9ee3033, 0xa4ad16ea, 0xa06c0b5d,\n  0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49, 0xc7361b4c, 0xc3f706fb, 0xceb42022, 0xca753d95,\n  0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1, 0xe13ef6f4, 0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d,\n  0x34867077, 0x30476dc0, 0x3d044b19, 0x39c556ae, 0x278206ab, 0x23431b1c, 0x2e003dc5, 0x2ac12072,\n  0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16, 0x018aeb13, 0x054bf6a4, 0x0808d07d, 0x0cc9cdca,\n  0x7897ab07, 0x7c56b6b0, 0x71159069, 0x75d48dde, 0x6b93dddb, 0x6f52c06c, 0x6211e6b5, 0x66d0fb02,\n  0x5e9f46bf, 0x5a5e5b08, 0x571d7dd1, 0x53dc6066, 0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,\n  0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e, 0xbfa1b04b, 0xbb60adfc, 0xb6238b25, 0xb2e29692,\n  0x8aad2b2f, 0x8e6c3698, 0x832f1041, 0x87ee0df6, 0x99a95df3, 0x9d684044, 0x902b669d, 0x94ea7b2a,\n  0xe0b41de7, 0xe4750050, 0xe9362689, 0xedf73b3e, 0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2,\n  0xc6bcf05f, 0xc27dede8, 0xcf3ecb31, 0xcbffd686, 0xd5b88683, 0xd1799b34, 0xdc3abded, 0xd8fba05a,\n  0x690ce0ee, 0x6dcdfd59, 0x608edb80, 0x644fc637, 0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb,\n  0x4f040d56, 0x4bc510e1, 0x46863638, 0x42472b8f, 0x5c007b8a, 0x58c1663d, 0x558240e4, 0x51435d53,\n  0x251d3b9e, 0x21dc2629, 0x2c9f00f0, 0x285e1d47, 0x36194d42, 0x32d850f5, 0x3f9b762c, 0x3b5a6b9b,\n  0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff, 0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623,\n  0xf12f560e, 0xf5ee4bb9, 0xf8ad6d60, 0xfc6c70d7, 0xe22b20d2, 0xe6ea3d65, 0xeba91bbc, 0xef68060b,\n  0xd727bbb6, 0xd3e6a601, 0xdea580d8, 0xda649d6f, 0xc423cd6a, 0xc0e2d0dd, 0xcda1f604, 0xc960ebb3,\n  0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7, 0xae3afba2, 0xaafbe615, 0xa7b8c0cc, 0xa379dd7b,\n  0x9b3660c6, 0x9ff77d71, 0x92b45ba8, 0x9675461f, 0x8832161a, 0x8cf30bad, 0x81b02d74, 0x857130c3,\n  0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640, 0x4e8ee645, 0x4a4ffbf2, 0x470cdd2b, 0x43cdc09c,\n  0x7b827d21, 0x7f436096, 0x7200464f, 0x76c15bf8, 0x68860bfd, 0x6c47164a, 0x61043093, 0x65c52d24,\n  0x119b4be9, 0x155a565e, 0x18197087, 0x1cd86d30, 0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec,\n  0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088, 0x2497d08d, 0x2056cd3a, 0x2d15ebe3, 0x29d4f654,\n  0xc5a92679, 0xc1683bce, 0xcc2b1d17, 0xc8ea00a0, 0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb, 0xdbee767c,\n  0xe3a1cbc1, 0xe760d676, 0xea23f0af, 0xeee2ed18, 0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4,\n  0x89b8fd09, 0x8d79e0be, 0x803ac667, 0x84fbdbd0, 0x9abc8bd5, 0x9e7d9662, 0x933eb0bb, 0x97ffad0c,\n  0xafb010b1, 0xab710d06, 0xa6322bdf, 0xa2f33668, 0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4\n]);\n\nvar CRC32 = function() {\n  /**\n   * The current CRC\n   */\n  var crc = 0xffffffff;\n\n  /**\n   * @return The current CRC\n   */\n  this.getCRC = function() {\n    return (~crc) >>> 0; // return an unsigned value\n  };\n\n  /**\n   * Update the CRC with a single byte\n   * @param value The value to update the CRC with\n   */\n  this.updateCRC = function(value) {\n    crc = (crc << 8) ^ crc32Lookup[((crc >>> 24) ^ value) & 0xff];\n  };\n\n  /**\n   * Update the CRC with a sequence of identical bytes\n   * @param value The value to update the CRC with\n   * @param count The number of bytes\n   */\n  this.updateCRCRun = function(value, count) {\n    while (count-- > 0) {\n      crc = (crc << 8) ^ crc32Lookup[((crc >>> 24) ^ value) & 0xff];\n    }\n  };\n};\nmodule.exports = CRC32;\n","/*\nAn implementation of Bzip2 de/compression, including the ability to\nseek within bzip2 data.\n\nCopyright (C) 2013 C. Scott Ananian\nCopyright (C) 2012 Eli Skeggs\nCopyright (C) 2011 Kevin Kwok\n\nThis library is free software; you can redistribute it and/or\nmodify it under the terms of the GNU Lesser General Public\nLicense as published by the Free Software Foundation; either\nversion 2.1 of the License, or (at your option) any later version.\n\nThis library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nLesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public\nLicense along with this library; if not, see\nhttp://www.gnu.org/licenses/lgpl-2.1.html\n\nAdapted from node-bzip, copyright 2012 Eli Skeggs.\nAdapted from bzip2.js, copyright 2011 Kevin Kwok (antimatter15@gmail.com).\n\nBased on micro-bunzip by Rob Landley (rob@landley.net).\n\nBased on bzip2 decompression code by Julian R Seward (jseward@acm.org),\nwhich also acknowledges contributions by Mike Burrows, David Wheeler,\nPeter Fenwick, Alistair Moffat, Radford Neal, Ian H. Witten,\nRobert Sedgewick, and Jon L. Bentley.\n\nBWT implementation based on work by Yuta Mori; see BWT.js for details.\n\nbzip2 compression code inspired by https://code.google.com/p/jbzip2\n*/\nconst freeze = require('./freeze');\nconst BitStream = require('./BitStream');\nconst BWT = require('./BWT');\nconst CRC32 = require('./CRC32');\nconst HuffmanAllocator = require('./HuffmanAllocator');\nconst Stream = require('./Stream');\nconst Util = require('./Util');\n\nvar MAX_HUFCODE_BITS = 20;\nvar MAX_SYMBOLS = 258;\nvar SYMBOL_RUNA = 0;\nvar SYMBOL_RUNB = 1;\nvar MIN_GROUPS = 2;\nvar MAX_GROUPS = 6;\nvar GROUP_SIZE = 50;\n\nvar WHOLEPI = 0x314159265359; // 48-bit integer\nvar SQRTPI =  0x177245385090; // 48-bit integer\n\nvar EOF = Stream.EOF;\n\nvar mtf = function(array, index) {\n  var src = array[index], i;\n  for (i = index; i > 0; i--) {\n    array[i] = array[i-1];\n  }\n  array[0] = src;\n  return src;\n};\n\nvar Err = {\n  OK: 0,\n  LAST_BLOCK: -1,\n  NOT_BZIP_DATA: -2,\n  UNEXPECTED_INPUT_EOF: -3,\n  UNEXPECTED_OUTPUT_EOF: -4,\n  DATA_ERROR: -5,\n  OUT_OF_MEMORY: -6,\n  OBSOLETE_INPUT: -7,\n  END_OF_BLOCK: -8\n};\nvar ErrorMessages = {};\nErrorMessages[Err.LAST_BLOCK] =            \"Bad file checksum\";\nErrorMessages[Err.NOT_BZIP_DATA] =         \"Not bzip data\";\nErrorMessages[Err.UNEXPECTED_INPUT_EOF] =  \"Unexpected input EOF\";\nErrorMessages[Err.UNEXPECTED_OUTPUT_EOF] = \"Unexpected output EOF\";\nErrorMessages[Err.DATA_ERROR] =            \"Data error\";\nErrorMessages[Err.OUT_OF_MEMORY] =         \"Out of memory\";\nErrorMessages[Err.OBSOLETE_INPUT] = \"Obsolete (pre 0.9.5) bzip format not supported.\";\n\nvar _throw = function(status, optDetail) {\n  var msg = ErrorMessages[status] || 'unknown error';\n  if (optDetail) { msg += ': '+optDetail; }\n  var e = new TypeError(msg);\n  e.errorCode = status;\n  throw e;\n};\n\nvar Bunzip = function(inputStream, outputStream) {\n  this.writePos = this.writeCurrent = this.writeCount = 0;\n\n  this._start_bunzip(inputStream, outputStream);\n};\nBunzip.prototype._init_block = function() {\n  var moreBlocks = this._get_next_block();\n  if ( !moreBlocks ) {\n    this.writeCount = -1;\n    return false; /* no more blocks */\n  }\n  this.blockCRC = new CRC32();\n  return true;\n};\n/* XXX micro-bunzip uses (inputStream, inputBuffer, len) as arguments */\nBunzip.prototype._start_bunzip = function(inputStream, outputStream) {\n  /* Ensure that file starts with \"BZh['1'-'9'].\" */\n  var buf = Util.makeU8Buffer(4);\n  if (inputStream.read(buf, 0, 4) !== 4 ||\n      String.fromCharCode(buf[0], buf[1], buf[2]) !== 'BZh')\n    _throw(Err.NOT_BZIP_DATA, 'bad magic');\n\n  var level = buf[3] - 0x30;\n  if (level < 1 || level > 9)\n    _throw(Err.NOT_BZIP_DATA, 'level out of range');\n\n  this.reader = new BitStream(inputStream);\n\n  /* Fourth byte (ascii '1'-'9'), indicates block size in units of 100k of\n     uncompressed data.  Allocate intermediate buffer for block. */\n  this.dbufSize = 100000 * level;\n  this.nextoutput = 0;\n  this.outputStream = outputStream;\n  this.streamCRC = 0;\n};\nBunzip.prototype._get_next_block = function() {\n  var i, j, k;\n  var reader = this.reader;\n  // this is get_next_block() function from micro-bunzip:\n  /* Read in header signature and CRC, then validate signature.\n     (last block signature means CRC is for whole file, return now) */\n  var h = reader.readBits(48);\n  if (h === SQRTPI) { // last block\n    return false; /* no more blocks */\n  }\n  if (h !== WHOLEPI)\n    _throw(Err.NOT_BZIP_DATA);\n  this.targetBlockCRC = reader.readBits(32);\n  this.streamCRC = (this.targetBlockCRC ^\n                    ((this.streamCRC << 1) | (this.streamCRC>>>31))) >>> 0;\n  /* We can add support for blockRandomised if anybody complains.  There was\n     some code for this in busybox 1.0.0-pre3, but nobody ever noticed that\n     it didn't actually work. */\n  if (reader.readBits(1))\n    _throw(Err.OBSOLETE_INPUT);\n  var origPointer = reader.readBits(24);\n  if (origPointer > this.dbufSize)\n    _throw(Err.DATA_ERROR, 'initial position out of bounds');\n  /* mapping table: if some byte values are never used (encoding things\n     like ASCII text), the compression code removes the gaps to have fewer\n     symbols to deal with, and writes a sparse bitfield indicating which\n     values were present.  We make a translation table to convert the symbols\n     back to the corresponding bytes. */\n  var t = reader.readBits(16);\n  var symToByte = Util.makeU8Buffer(256), symTotal = 0;\n  for (i = 0; i < 16; i++) {\n    if (t & (1 << (0xF - i))) {\n      var o = i * 16;\n      k = reader.readBits(16);\n      for (j = 0; j < 16; j++)\n        if (k & (1 << (0xF - j)))\n          symToByte[symTotal++] = o + j;\n    }\n  }\n\n  /* How many different Huffman coding groups does this block use? */\n  var groupCount = reader.readBits(3);\n  if (groupCount < MIN_GROUPS || groupCount > MAX_GROUPS)\n    _throw(Err.DATA_ERROR);\n  /* nSelectors: Every GROUP_SIZE many symbols we select a new Huffman coding\n     group.  Read in the group selector list, which is stored as MTF encoded\n     bit runs.  (MTF=Move To Front, as each value is used it's moved to the\n     start of the list.) */\n  var nSelectors = reader.readBits(15);\n  if (nSelectors === 0)\n    _throw(Err.DATA_ERROR);\n\n  var mtfSymbol = Util.makeU8Buffer(256);\n  for (i = 0; i < groupCount; i++)\n    mtfSymbol[i] = i;\n\n  var selectors = Util.makeU8Buffer(nSelectors); // was 32768...\n\n  for (i = 0; i < nSelectors; i++) {\n    /* Get next value */\n    for (j = 0; reader.readBits(1); j++)\n      if (j >= groupCount) _throw(Err.DATA_ERROR);\n    /* Decode MTF to get the next selector */\n    selectors[i] = mtf(mtfSymbol, j);\n  }\n\n  /* Read the Huffman coding tables for each group, which code for symTotal\n     literal symbols, plus two run symbols (RUNA, RUNB) */\n  var symCount = symTotal + 2;\n  var groups = [], hufGroup;\n  for (j = 0; j < groupCount; j++) {\n    var length = Util.makeU8Buffer(symCount), temp = Util.makeU16Buffer(MAX_HUFCODE_BITS + 1);\n    /* Read Huffman code lengths for each symbol.  They're stored in\n       a way similar to MTF; record a starting value for the first symbol,\n       and an offset from the previous value for every symbol after that. */\n    t = reader.readBits(5); // lengths\n    for (i = 0; i < symCount; i++) {\n      for (;;) {\n        if (t < 1 || t > MAX_HUFCODE_BITS) _throw(Err.DATA_ERROR);\n        /* If first bit is 0, stop.  Else second bit indicates whether\n           to increment or decrement the value. */\n        if(!reader.readBits(1))\n          break;\n        if(!reader.readBits(1))\n          t++;\n        else\n          t--;\n      }\n      length[i] = t;\n    }\n\n    /* Find largest and smallest lengths in this group */\n    var minLen,  maxLen;\n    minLen = maxLen = length[0];\n    for (i = 1; i < symCount; i++) {\n      if (length[i] > maxLen)\n        maxLen = length[i];\n      else if (length[i] < minLen)\n        minLen = length[i];\n    }\n\n    /* Calculate permute[], base[], and limit[] tables from length[].\n     *\n     * permute[] is the lookup table for converting Huffman coded symbols\n     * into decoded symbols.  base[] is the amount to subtract from the\n     * value of a Huffman symbol of a given length when using permute[].\n     *\n     * limit[] indicates the largest numerical value a symbol with a given\n     * number of bits can have.  This is how the Huffman codes can vary in\n     * length: each code with a value>limit[length] needs another bit.\n     */\n    hufGroup = {};\n    groups.push(hufGroup);\n    hufGroup.permute = Util.makeU16Buffer(MAX_SYMBOLS);\n    hufGroup.limit = Util.makeU32Buffer(MAX_HUFCODE_BITS + 2);\n    hufGroup.base = Util.makeU32Buffer(MAX_HUFCODE_BITS + 1);\n    hufGroup.minLen = minLen;\n    hufGroup.maxLen = maxLen;\n    /* Calculate permute[].  Concurrently, initialize temp[] and limit[]. */\n    var pp = 0;\n    for (i = minLen; i <= maxLen; i++) {\n      temp[i] = hufGroup.limit[i] = 0;\n      for (t = 0; t < symCount; t++)\n        if (length[t] === i)\n          hufGroup.permute[pp++] = t;\n    }\n    /* Count symbols coded for at each bit length */\n    for (i = 0; i < symCount; i++)\n      temp[length[i]]++;\n    /* Calculate limit[] (the largest symbol-coding value at each bit\n     * length, which is (previous limit<<1)+symbols at this level), and\n     * base[] (number of symbols to ignore at each bit length, which is\n     * limit minus the cumulative count of symbols coded for already). */\n    pp = t = 0;\n    for (i = minLen; i < maxLen; i++) {\n      pp += temp[i];\n      /* We read the largest possible symbol size and then unget bits\n         after determining how many we need, and those extra bits could\n         be set to anything.  (They're noise from future symbols.)  At\n         each level we're really only interested in the first few bits,\n         so here we set all the trailing to-be-ignored bits to 1 so they\n         don't affect the value>limit[length] comparison. */\n      hufGroup.limit[i] = pp - 1;\n      pp <<= 1;\n      t += temp[i];\n      hufGroup.base[i + 1] = pp - t;\n    }\n    hufGroup.limit[maxLen + 1] = Number.MAX_VALUE; /* Sentinel value for reading next sym. */\n    hufGroup.limit[maxLen] = pp + temp[maxLen] - 1;\n    hufGroup.base[minLen] = 0;\n  }\n  /* We've finished reading and digesting the block header.  Now read this\n     block's Huffman coded symbols from the file and undo the Huffman coding\n     and run length encoding, saving the result into dbuf[dbufCount++]=uc */\n\n  /* Initialize symbol occurrence counters and symbol Move To Front table */\n  var byteCount = Util.makeU32Buffer(256);\n  for (i = 0; i < 256; i++)\n    mtfSymbol[i] = i;\n  /* Loop through compressed symbols. */\n  var runPos = 0, dbufCount = 0, selector = 0, uc;\n  var dbuf = this.dbuf = Util.makeU32Buffer(this.dbufSize);\n  symCount = 0;\n  for (;;) {\n    /* Determine which Huffman coding group to use. */\n    if (!(symCount--)) {\n      symCount = GROUP_SIZE - 1;\n      if (selector >= nSelectors) { _throw(Err.DATA_ERROR); }\n      hufGroup = groups[selectors[selector++]];\n    }\n    /* Read next Huffman-coded symbol. */\n    i = hufGroup.minLen;\n    j = reader.readBits(i);\n    for (;;i++) {\n      if (i > hufGroup.maxLen) { _throw(Err.DATA_ERROR); }\n      if (j <= hufGroup.limit[i])\n        break;\n      j = (j << 1) | reader.readBits(1);\n    }\n    /* Huffman decode value to get nextSym (with bounds checking) */\n    j -= hufGroup.base[i];\n    if (j < 0 || j >= MAX_SYMBOLS) { _throw(Err.DATA_ERROR); }\n    var nextSym = hufGroup.permute[j];\n    /* We have now decoded the symbol, which indicates either a new literal\n       byte, or a repeated run of the most recent literal byte.  First,\n       check if nextSym indicates a repeated run, and if so loop collecting\n       how many times to repeat the last literal. */\n    if (nextSym === SYMBOL_RUNA || nextSym === SYMBOL_RUNB) {\n      /* If this is the start of a new run, zero out counter */\n      if (!runPos){\n        runPos = 1;\n        t = 0;\n      }\n      /* Neat trick that saves 1 symbol: instead of or-ing 0 or 1 at\n         each bit position, add 1 or 2 instead.  For example,\n         1011 is 1<<0 + 1<<1 + 2<<2.  1010 is 2<<0 + 2<<1 + 1<<2.\n         You can make any bit pattern that way using 1 less symbol than\n         the basic or 0/1 method (except all bits 0, which would use no\n         symbols, but a run of length 0 doesn't mean anything in this\n         context).  Thus space is saved. */\n      if (nextSym === SYMBOL_RUNA)\n        t += runPos;\n      else\n        t += 2 * runPos;\n      runPos <<= 1;\n      continue;\n    }\n    /* When we hit the first non-run symbol after a run, we now know\n       how many times to repeat the last literal, so append that many\n       copies to our buffer of decoded symbols (dbuf) now.  (The last\n       literal used is the one at the head of the mtfSymbol array.) */\n    if (runPos){\n      runPos = 0;\n      if (dbufCount + t > this.dbufSize) { _throw(Err.DATA_ERROR); }\n      uc = symToByte[mtfSymbol[0]];\n      byteCount[uc] += t;\n      while (t--)\n        dbuf[dbufCount++] = uc;\n    }\n    /* Is this the terminating symbol? */\n    if (nextSym > symTotal)\n      break;\n    /* At this point, nextSym indicates a new literal character.  Subtract\n       one to get the position in the MTF array at which this literal is\n       currently to be found.  (Note that the result can't be -1 or 0,\n       because 0 and 1 are RUNA and RUNB.  But another instance of the\n       first symbol in the MTF array, position 0, would have been handled\n       as part of a run above.  Therefore 1 unused MTF position minus\n       2 non-literal nextSym values equals -1.) */\n    if (dbufCount >= this.dbufSize) { _throw(Err.DATA_ERROR); }\n    i = nextSym - 1;\n    uc = mtf(mtfSymbol, i);\n    uc = symToByte[uc];\n    /* We have our literal byte.  Save it into dbuf. */\n    byteCount[uc]++;\n    dbuf[dbufCount++] = uc;\n  }\n  /* At this point, we've read all the Huffman-coded symbols (and repeated\n     runs) for this block from the input stream, and decoded them into the\n     intermediate buffer.  There are dbufCount many decoded bytes in dbuf[].\n     Now undo the Burrows-Wheeler transform on dbuf.\n     See http://dogma.net/markn/articles/bwt/bwt.htm\n  */\n  if (origPointer < 0 || origPointer >= dbufCount) { _throw(Err.DATA_ERROR); }\n  /* Turn byteCount into cumulative occurrence counts of 0 to n-1. */\n  j = 0;\n  for (i = 0; i < 256; i++) {\n    k = j + byteCount[i];\n    byteCount[i] = j;\n    j = k;\n  }\n  /* Figure out what order dbuf would be in if we sorted it. */\n  for (i = 0; i < dbufCount; i++) {\n    uc = dbuf[i] & 0xff;\n    dbuf[byteCount[uc]] |= (i << 8);\n    byteCount[uc]++;\n  }\n  /* Decode first byte by hand to initialize \"previous\" byte.  Note that it\n     doesn't get output, and if the first three characters are identical\n     it doesn't qualify as a run (hence writeRunCountdown=5). */\n  var pos = 0, current = 0, run = 0;\n  if (dbufCount) {\n    pos = dbuf[origPointer];\n    current = (pos & 0xff);\n    pos >>= 8;\n    run = -1;\n  }\n  this.writePos = pos;\n  this.writeCurrent = current;\n  this.writeCount = dbufCount;\n  this.writeRun = run;\n\n  return true; /* more blocks to come */\n};\n/* Undo burrows-wheeler transform on intermediate buffer to produce output.\n   If start_bunzip was initialized with out_fd=-1, then up to len bytes of\n   data are written to outbuf.  Return value is number of bytes written or\n   error (all errors are negative numbers).  If out_fd!=-1, outbuf and len\n   are ignored, data is written to out_fd and return is RETVAL_OK or error.\n*/\nBunzip.prototype._read_bunzip = function(outputBuffer, len) {\n    var copies, previous, outbyte;\n    /* james@jamestaylor.org: writeCount goes to -1 when the buffer is fully\n       decoded, which results in this returning RETVAL_LAST_BLOCK, also\n       equal to -1... Confusing, I'm returning 0 here to indicate no\n       bytes written into the buffer */\n  if (this.writeCount < 0) { return 0; }\n\n  var gotcount = 0;\n  var dbuf = this.dbuf, pos = this.writePos, current = this.writeCurrent;\n  var dbufCount = this.writeCount, outputsize = this.outputsize;\n  var run = this.writeRun;\n\n  while (dbufCount) {\n    dbufCount--;\n    previous = current;\n    pos = dbuf[pos];\n    current = pos & 0xff;\n    pos >>= 8;\n    if (run++ === 3){\n      copies = current;\n      outbyte = previous;\n      current = -1;\n    } else {\n      copies = 1;\n      outbyte = current;\n    }\n    this.blockCRC.updateCRCRun(outbyte, copies);\n    while (copies--) {\n      this.outputStream.writeByte(outbyte);\n      this.nextoutput++;\n    }\n    if (current != previous)\n      run = 0;\n  }\n  this.writeCount = dbufCount;\n  // check CRC\n  if (this.blockCRC.getCRC() !== this.targetBlockCRC) {\n    _throw(Err.DATA_ERROR, \"Bad block CRC \"+\n           \"(got \"+this.blockCRC.getCRC().toString(16)+\n           \" expected \"+this.targetBlockCRC.toString(16)+\")\");\n  }\n  return this.nextoutput;\n};\n\n/* Static helper functions */\nBunzip.Err = Err;\n// 'input' can be a stream or a buffer\n// 'output' can be a stream or a buffer or a number (buffer size)\nBunzip.decode = function(input, output, multistream) {\n  // make a stream from a buffer, if necessary\n  var inputStream = Util.coerceInputStream(input);\n  var o = Util.coerceOutputStream(output, output);\n  var outputStream = o.stream;\n\n  var bz = new Bunzip(inputStream, outputStream);\n  while (true) {\n    if ('eof' in inputStream && inputStream.eof()) break;\n    if (bz._init_block()) {\n      bz._read_bunzip();\n    } else {\n      var targetStreamCRC = bz.reader.readBits(32);\n      if (targetStreamCRC !== bz.streamCRC) {\n        _throw(Err.DATA_ERROR, \"Bad stream CRC \"+\n               \"(got \"+bz.streamCRC.toString(16)+\n               \" expected \"+targetStreamCRC.toString(16)+\")\");\n      }\n      if (multistream &&\n          'eof' in inputStream &&\n          !inputStream.eof()) {\n        // note that start_bunzip will also resync the bit reader to next byte\n        bz._start_bunzip(inputStream, outputStream);\n      } else break;\n    }\n  }\n  return o.retval;\n};\nBunzip.decodeBlock = function(input, pos, output) {\n  // make a stream from a buffer, if necessary\n  var inputStream = Util.coerceInputStream(input);\n  var o = Util.coerceOutputStream(output, output);\n  var outputStream = o.stream;\n  var bz = new Bunzip(inputStream, outputStream);\n  bz.reader.seekBit(pos);\n  /* Fill the decode buffer for the block */\n  var moreBlocks = bz._get_next_block();\n  if (moreBlocks) {\n    /* Init the CRC for writing */\n    bz.blockCRC = new CRC32();\n\n    /* Zero this so the current byte from before the seek is not written */\n    bz.writeCopies = 0;\n\n    /* Decompress the block and write to stdout */\n    bz._read_bunzip();\n    // XXX keep writing?\n  }\n  return o.retval;\n};\n/* Reads bzip2 file from stream or buffer `input`, and invoke\n * `callback(position, size)` once for each bzip2 block,\n * where position gives the starting position (in *bits*)\n * and size gives uncompressed size of the block (in *bytes*). */\nBunzip.table = function(input, callback, multistream) {\n  // make a stream from a buffer, if necessary\n  var inputStream = new Stream();\n  inputStream.delegate = Util.coerceInputStream(input);\n  inputStream.pos = 0;\n  inputStream.readByte = function() {\n    this.pos++;\n    return this.delegate.readByte();\n  };\n  inputStream.tell = function() { return this.pos; };\n  if (inputStream.delegate.eof) {\n    inputStream.eof = inputStream.delegate.eof.bind(inputStream.delegate);\n  }\n  var outputStream = new Stream();\n  outputStream.pos = 0;\n  outputStream.writeByte = function() { this.pos++; };\n\n  var bz = new Bunzip(inputStream, outputStream);\n  var blockSize = bz.dbufSize;\n  while (true) {\n    if ('eof' in inputStream && inputStream.eof()) break;\n\n    var position = bz.reader.tellBit();\n\n    if (bz._init_block()) {\n      var start = outputStream.pos;\n      bz._read_bunzip();\n      callback(position, outputStream.pos - start);\n    } else {\n      var crc = bz.reader.readBits(32); // (but we ignore the crc)\n      if (multistream &&\n          'eof' in inputStream &&\n          !inputStream.eof()) {\n        // note that start_bunzip will also resync the bit reader to next byte\n        bz._start_bunzip(inputStream, outputStream);\n        console.assert(bz.dbufSize === blockSize,\n                       \"shouldn't change block size within multistream file\");\n      } else break;\n    }\n  }\n};\n\n// create a Huffman tree from the table of frequencies\nvar StaticHuffman = function(freq, alphabetSize) {\n  // As in BZip2HuffmanStageEncoder.java (from jbzip2):\n  // The Huffman allocator needs its input symbol frequencies to be\n  // sorted, but we need to return code lengths in the same order as\n  // the corresponding frequencies are passed in.\n  // The symbol frequency and index are merged into a single array of\n  // integers - frequency in the high 23 bits, index in the low 9\n  // bits.\n  //     2^23 = 8,388,608 which is higher than the maximum possible\n  //            frequency for one symbol in a block\n  //     2^9 = 512 which is higher than the maximum possible\n  //            alphabet size (== 258)\n  // Sorting this array simultaneously sorts the frequencies and\n  // leaves a lookup that can be used to cheaply invert the sort\n  var i, mergedFreq = [];\n  for (i=0; i<alphabetSize; i++) {\n    mergedFreq[i] = (freq[i] << 9) | i;\n  }\n  mergedFreq.sort(function(a,b) { return a-b; });\n  var sortedFreq = mergedFreq.map(function(v) { return v>>>9; });\n  // allocate code lengths in place. (result in sortedFreq array)\n  HuffmanAllocator.allocateHuffmanCodeLengths(sortedFreq, MAX_HUFCODE_BITS);\n  // reverse the sort to put codes & code lengths in order of input symbols\n  this.codeLengths = Util.makeU8Buffer(alphabetSize);\n  for (i=0; i<alphabetSize; i++) {\n    var sym = mergedFreq[i] & 0x1FF;\n    this.codeLengths[sym] = sortedFreq[i];\n  }\n};\n// compute canonical Huffman codes, given code lengths\nStaticHuffman.prototype.computeCanonical = function() {\n  var alphabetSize = this.codeLengths.length;\n  // merge arrays; sort first by length then by symbol.\n  var i, merged = [];\n  for (i=0; i<alphabetSize; i++) {\n    merged[i] = (this.codeLengths[i] << 9) | i;\n  }\n  merged.sort(function(a,b) { return a-b; });\n  // use sorted lengths to assign codes\n  this.code = Util.makeU32Buffer(alphabetSize);\n  var code = 0, prevLen = 0;\n  for (i=0; i<alphabetSize; i++) {\n    var curLen = merged[i] >>> 9;\n    var sym = merged[i] & 0x1FF;\n    console.assert(prevLen <= curLen);\n    code <<= (curLen - prevLen);\n    this.code[sym] = code++;\n    prevLen = curLen;\n  }\n};\n// compute the cost of encoding the given range of symbols w/ this Huffman code\nStaticHuffman.prototype.cost = function(array, offset, length) {\n  var i, cost = 0;\n  for (i=0; i<length; i++) {\n    cost += this.codeLengths[array[offset+i]];\n  }\n  return cost;\n};\n// emit the bit lengths used by this Huffman code\nStaticHuffman.prototype.emit = function(outStream) {\n  // write the starting length\n  var i, currentLength = this.codeLengths[0];\n  outStream.writeBits(5, currentLength);\n  for (i=0; i<this.codeLengths.length; i++) {\n    var codeLength = this.codeLengths[i];\n    var value, delta;\n    console.assert(codeLength > 0 && codeLength <= MAX_HUFCODE_BITS);\n    if (currentLength < codeLength) {\n      value = 2; delta = codeLength - currentLength;\n    } else {\n      value = 3; delta = currentLength - codeLength;\n    }\n    while (delta-- > 0) {\n      outStream.writeBits(2, value);\n    }\n    outStream.writeBit(0);\n    currentLength = codeLength;\n  }\n};\n// encode the given symbol with this Huffman code\nStaticHuffman.prototype.encode = function(outStream, symbol) {\n  outStream.writeBits(this.codeLengths[symbol], this.code[symbol]);\n};\n\n// read a block for bzip2 compression.\nvar readBlock = function(inStream, block, length, crc) {\n  var pos = 0;\n  var lastChar = -1;\n  var runLength = 0;\n  while (pos < length) {\n    if (runLength===4) {\n      block[pos++] = 0;\n      if (pos >= length) { break; }\n    }\n    var ch = inStream.readByte();\n    if (ch === EOF) {\n      break;\n    }\n    crc.updateCRC(ch);\n    if (ch !== lastChar) {\n      lastChar = ch;\n      runLength = 1;\n    } else {\n      runLength++;\n      if (runLength > 4) {\n        if (runLength < 256) {\n          block[pos-1]++;\n          continue;\n        } else {\n          runLength = 1;\n        }\n      }\n    }\n    block[pos++] = ch;\n  }\n  return pos;\n};\n\n// divide the input into groups at most GROUP_SIZE symbols long.\n// assign each group to the Huffman table which compresses it best.\nvar assignSelectors = function(selectors, groups, input) {\n  var i, j, k;\n  for (i=0, k=0; i<input.length; i+=GROUP_SIZE) {\n    var groupSize = Math.min(GROUP_SIZE, input.length - i);\n    var best = 0, bestCost = groups[0].cost(input, i, groupSize);\n    for (j=1; j<groups.length; j++) {\n      var groupCost = groups[j].cost(input, i, groupSize);\n      if (groupCost < bestCost) {\n        best = j; bestCost = groupCost;\n      }\n    }\n    selectors[k++] = best;\n  }\n};\nvar optimizeHuffmanGroups = function(groups, targetGroups, input,\n                                     selectors, alphabetSize) {\n  // until we've got \"targetGroups\" Huffman codes, pick the Huffman code which\n  // matches the largest # of groups and split it by picking the groups\n  // which require more than the median number of bits to encode.\n  // then recompute frequencies and reassign Huffman codes.\n  var i, j, k, groupCounts = [];\n  while (groups.length < targetGroups) {\n    assignSelectors(selectors, groups, input);\n    // which code gets used the most?\n    for (i=0; i<groups.length; i++) { groupCounts[i] = 0; }\n    for (i=0; i<selectors.length; i++) {\n      groupCounts[selectors[i]]++;\n    }\n    var which = groupCounts.indexOf(Math.max.apply(Math, groupCounts));\n    // ok, let's look at the size of those blocks\n    var splits = [];\n    for (i=0, j=0; i<selectors.length; i++) {\n      if (selectors[i] !== which) { continue; }\n      var start = i*GROUP_SIZE;\n      var end = Math.min(start + GROUP_SIZE, input.length);\n      splits.push({index: i, cost:groups[which].cost(input, start, end-start)});\n    }\n    // find the median.  there are O(n) algorithms to do this, but we'll\n    // be lazy and use a full O(n ln n) sort.\n    splits.sort(function(s1, s2) { return s1.cost - s2.cost; });\n    // assign the groups in the top half to the \"new\" selector\n    for (i=(splits.length>>>1); i<splits.length; i++) {\n      selectors[splits[i].index] = groups.length;\n    }\n    groups.push(null);\n    // recompute frequencies\n    var freq = [], f;\n    for (i=0; i<groups.length; i++) {\n      f = freq[i] = [];\n      for (j=0; j<alphabetSize; j++) { f[j] = 0; }\n    }\n    for (i=0, j=0; i<input.length; ) {\n      f = freq[selectors[j++]];\n      for (k=0; k<GROUP_SIZE && i<input.length; k++) {\n        f[input[i++]]++;\n      }\n    }\n    // reconstruct Huffman codes\n    for (i=0; i<groups.length; i++) {\n      groups[i] = new StaticHuffman(freq[i], alphabetSize);\n    }\n  }\n};\n\nvar compressBlock = function(block, length, outStream) {\n  var c, i, j, k;\n  // do BWT transform\n  var U = Util.makeU8Buffer(length);\n  var pidx = BWT.bwtransform2(block, U, length, 256);\n  outStream.writeBit(0); // not randomized\n  outStream.writeBits(24, pidx);\n  // track values used; write bitmap\n  var used = [], compact = [];\n  for (i=0; i<length; i++) {\n    c = block[i];\n    used[c] = true;\n    compact[c>>>4] = true;\n  }\n  for (i=0; i<16; i++) {\n    outStream.writeBit(!!compact[i]);\n  }\n  for (i=0; i<16; i++) {\n    if (compact[i]) {\n      for (j=0; j<16; j++) {\n        outStream.writeBit(!!used[(i<<4)|j]);\n      }\n    }\n  }\n  var alphabetSize = 0;\n  for (i=0; i<256; i++) {\n    if (used[i]) {\n      alphabetSize++;\n    }\n  }\n  // now MTF and RLE/2 encoding, while tracking symbol statistics.\n  // output can be one longer than length, because we include the\n  // end-of-block character at the end. Similarly, we need a U16\n  // array because the end-of-block character can be 256.\n  var A = Util.makeU16Buffer(length+1);\n  var endOfBlock = alphabetSize + 1;\n  var freq = [];\n  for (i=0; i<=endOfBlock; i++) { freq[i] = 0; }\n  var M = Util.makeU8Buffer(alphabetSize);\n  for (i=0, j=0; i<256; i++) {\n    if (used[i]) { M[j++] = i; }\n  }\n  used = null; compact = null;\n  var pos = 0, runLength = 0;\n  var emit = function(c) {\n    A[pos++] = c;\n    freq[c]++;\n  };\n  var emitLastRun = function() {\n    while (runLength !== 0) {\n      if (runLength & 1) {\n        emit(0); // RUNA\n        runLength -= 1;\n      } else {\n        emit(1); // RUNB\n        runLength -= 2;\n      }\n      runLength >>>= 1;\n    }\n  };\n  for (i=0; i<U.length; i++) {\n    c = U[i];\n    // look for C in M\n    for (j=0; j<alphabetSize; j++) {\n      if (M[j]===c) { break; }\n    }\n    console.assert(j!==alphabetSize);\n    // shift MTF array\n    mtf(M, j);\n    // emit j\n    if (j===0) {\n      runLength++;\n    } else {\n      emitLastRun();\n      emit(j+1);\n      runLength = 0;\n    }\n  }\n  emitLastRun();\n  emit(endOfBlock); // end of block symbol\n  A = A.subarray(0, pos);\n  // now A[0...pos) has the encoded output, and freq[0-alphabetSize] has the\n  // frequencies.  Use these to construct Huffman tables.\n  // the canonical bzip2 encoder does some complicated optimization\n  // to attempt to select the best tables.  We're going to simplify things:\n  // (unless the block is very short) we're always going to create MAX_GROUPS\n  // tables; 1 based on global frequencies, and the rest based on dividing the\n  // block into MAX_GROUPS-1 pieces.\n  var groups = [];\n  var targetGroups; // how many Huffman groups should we create?\n  // look at length of MTF-encoded block to pick a good number of groups\n  if (pos >= 2400) { targetGroups = 6; }\n  else if (pos >= 1200) { targetGroups = 5; }\n  else if (pos >= 600) { targetGroups = 4; }\n  else if (pos >= 200) { targetGroups = 3; }\n  else { targetGroups = 2; }\n  // start with two Huffman groups: one with the global frequencies, and\n  // a second with a flat frequency distribution (which is also the smallest\n  // possible Huffman table to encode, which is handy to prevent excessive\n  // bloat if the input file size is very small)\n  groups.push(new StaticHuffman(freq, endOfBlock+1));\n  for (i=0; i<=endOfBlock; i++) { freq[i] = 1; }\n  groups.push(new StaticHuffman(freq, endOfBlock+1));\n  freq = null;\n  // Now optimize the Huffman groups!  this is a black art.\n  // we probably don't want to waste too much time on it, though.\n  var selectors = Util.makeU8Buffer(Math.ceil(pos / GROUP_SIZE));\n  optimizeHuffmanGroups(groups, targetGroups, A, selectors, endOfBlock+1);\n  assignSelectors(selectors, groups, A);\n\n  // okay, let's start writing out our Huffman tables\n  console.assert(groups.length >= MIN_GROUPS && groups.length <= MAX_GROUPS);\n  outStream.writeBits(3, groups.length);\n  // and write out the best selector for each group\n  outStream.writeBits(15, selectors.length);\n  for (i=0; i<groups.length; i++) { M[i] = i; } // initialize MTF table.\n  for (i=0; i<selectors.length; i++) {\n    var s = selectors[i];\n    // find selector in MTF list\n    for (j=0; j<groups.length; j++) { if (M[j]===s) { break; } }\n    console.assert(j<groups.length);\n    mtf(M, j);\n    // emit 'j' as a unary number\n    for (;j>0; j--) {\n      outStream.writeBit(1);\n    }\n    outStream.writeBit(0);\n  }\n  // okay, now emit the Huffman tables in order.\n  for (i=0; i<groups.length; i++) {\n    groups[i].emit(outStream);\n    groups[i].computeCanonical(); // get ready for next step while we're at it\n  }\n  // okay, now (finally!) emit the actual data!\n  for (i=0, k=0; i<pos; ) {\n    var huff = groups[selectors[k++]];\n    for (j=0; j<GROUP_SIZE && i<pos; j++) {\n      huff.encode(outStream, A[i++]);\n    }\n  }\n  // done.\n};\n\nvar Bzip2 = Object.create(null);\nBzip2.compressFile = function(inStream, outStream, props) {\n  inStream = Util.coerceInputStream(inStream);\n  var o = Util.coerceOutputStream(outStream, outStream);\n  outStream = new BitStream(o.stream);\n\n  var blockSizeMultiplier = 9;\n  if (typeof(props)==='number') {\n    blockSizeMultiplier = props;\n  }\n  if (blockSizeMultiplier < 1 || blockSizeMultiplier > 9) {\n    throw new Error('Invalid block size multiplier');\n  }\n\n  var blockSize = blockSizeMultiplier * 100000;\n  // the C implementation always writes at least length-19 characters,\n  // but it reads ahead enough that if the last character written was part\n  // of a run, it writes out the full run.\n  // That's really annoying to implement.\n  // So instead just subtract 19 from the blockSize; in most cases (unless\n  // there's a run at the end of the block) this will yield block divisions\n  // matching the C implementation.\n  blockSize -= 19;\n\n  // write file magic\n  outStream.writeByte('B'.charCodeAt(0));\n  outStream.writeByte('Z'.charCodeAt(0));\n  outStream.writeByte('h'.charCodeAt(0)); // Huffman-coded bzip\n  outStream.writeByte('0'.charCodeAt(0) + blockSizeMultiplier);\n\n  // allocate a buffer for the block\n  var block = Util.makeU8Buffer(blockSize);\n  var streamCRC = 0;\n  var length;\n\n  do {\n    var crc = new CRC32();\n    length = readBlock(inStream, block, blockSize, crc);\n    if (length > 0) {\n      streamCRC = (((streamCRC << 1) | (streamCRC>>>31)) ^ crc.getCRC()) >>> 0;\n      outStream.writeBits(48, WHOLEPI);\n      outStream.writeBits(32, crc.getCRC());\n      compressBlock(block, length, outStream);\n    }\n  } while (length === blockSize);\n\n  // finish up\n  outStream.writeBits(48, SQRTPI);\n  outStream.writeBits(32, streamCRC);\n  outStream.flush(); // get the last bits flushed out\n  return o.retval;\n};\n\nBzip2.decompressFile = Bunzip.decode;\nBzip2.decompressBlock = Bunzip.decodeBlock;\nBzip2.table = Bunzip.table;\n\nmodule.exports = Bzip2;\n","const freeze = require('./freeze');\nconst Stream = require('./Stream');\nconst BWT = require('./BWT');\nconst DefSumModel = require('./DefSumModel');\nconst FenwickModel = require('./FenwickModel');\nconst LogDistanceModel = require('./LogDistanceModel');\nconst NoModel = require('./NoModel');\nconst RangeCoder = require('./RangeCoder');\nconst Util = require('./Util');\n\n/* A simple bzip-like BWT compressor with a range encoder; written as a\n * self-test of the BWT package. */\nvar EOF = Stream.EOF;\n\nvar F_PROB_MAX  = 0xFF00;\nvar F_PROB_INCR = 0x0100;\n\nBWTC = Object.create(null);\nBWTC.MAGIC = \"bwtc\";\nBWTC.compressFile = Util.compressFileHelper(BWTC.MAGIC, function(input, output, size, props, finalByte) {\n    var encoder = new RangeCoder(output);\n    encoder.encodeStart(finalByte, 1);\n\n    var blockSize = 9;\n    if (typeof(props)==='number' && props >= 1 && props <= 9) {\n        blockSize = props;\n    }\n    encoder.encodeByte(blockSize);\n    var fast = (blockSize <= 5);\n    blockSize *= 100000;\n\n    var block = Util.makeU8Buffer(blockSize);\n    var readBlock = function() {\n        var pos;\n        for (pos=0; pos < blockSize; ) {\n            var ch = input.readByte();\n            if (ch < 0) { break; }\n            block[pos++] = ch;\n        }\n        return pos;\n    };\n    var U = Util.makeU8Buffer(blockSize);\n    var A = Util.makeS32Buffer(blockSize);\n    var M = Util.makeU8Buffer(256); // move to front array\n    var bitModelFactory = NoModel.factory(encoder);\n    var lenModel = new LogDistanceModel(blockSize, 0,\n                                        bitModelFactory,\n                                        bitModelFactory);\n    var length, b, c, pidx, i, j;\n    do {\n        length = readBlock();\n        if (length === 0) { break; }\n        // indicate that there's another block comin'\n        // and encode the length of the block if necessary\n        if (length === block.length) {\n            encoder.encodeFreq(1, 0, 3); // \"full size block\"\n            b = block;\n        } else {\n            encoder.encodeFreq(1, 1, 3); // \"short block\"\n            lenModel.encode(length);\n            b = block.subarray(0, length);\n        }\n        pidx = BWT.bwtransform(b, U, A, length, 256);\n        lenModel.encode(pidx); // starting index\n        // encode the alphabet subset used\n        var useTree = Util.makeU16Buffer(512);\n        for (i=0; i<length; i++) {\n            c = U[i];\n            useTree[256+c] = 1;\n        }\n        for (i=255; i>0; i--) { // sum all the way up the tree\n            useTree[i] = useTree[2*i] + useTree[2*i + 1];\n        }\n        useTree[0] = 1; // sentinel\n        for (i=1; i<512; i++) {\n            var parent = i>>>1;\n            var full = 1 << (9-Util.fls(i));\n            if (useTree[parent] === 0 || useTree[parent] === (full*2)) {\n                /* already known full/empty */\n            } else if (i >= 256) {\n                encoder.encodeBit(useTree[i]); // leaf node\n            } else {\n                var v = useTree[i];\n                v = (v===0) ? 0 : (v===full) ? 2 : 1;\n                encoder.encodeFreq(1, v, 3);\n            }\n        }\n        // remap symbols to this subset\n        var alphabetSize = 0;\n        for (i=0; i<256; i++) {\n            if (useTree[256+i]) { // symbol in use\n                M[alphabetSize++] = i;\n            }\n        }\n        useTree = null;\n        // MTF encoding of U\n        for (i=0; i<length; i++) {\n            c = U[i];\n            for (j=0; j<alphabetSize; j++) {\n                if (M[j] === c) {\n                    break;\n                }\n            }\n            console.assert(j<alphabetSize);\n            U[i] = j;\n            // move to front\n            for (; j>0; j--) {\n                M[j] = M[j-1];\n            }\n            M[0] = c;\n        }\n        // RLE/range encoding\n        var model = new FenwickModel(encoder, alphabetSize+1,\n                                        F_PROB_MAX, F_PROB_INCR);\n        if (fast) { model = new DefSumModel(encoder, alphabetSize+1); }\n        var runLength = 0;\n        var emitLastRun = function() {\n            // binary encode runs of zeros\n            while (runLength !== 0) {\n                if (runLength&1) {\n                    model.encode(0); // RUNA\n                    runLength-=1;\n                } else {\n                    model.encode(1); // RUNB\n                    runLength-=2;\n                }\n                runLength >>>= 1;\n            }\n        };\n        for (i=0; i<length; i++) {\n            c = U[i];\n            if (c === 0) {\n                runLength++;\n            } else {\n                emitLastRun();\n                model.encode(c+1);\n                // reset for next\n                runLength = 0;\n            }\n        }\n        emitLastRun();\n        // done with this block!\n    } while (length === block.length);\n\n    encoder.encodeFreq(1, 2, 3); // \"no more blocks\"\n    encoder.encodeFinish();\n}, true);\n\nBWTC.decompressFile = Util.decompressFileHelper(BWTC.MAGIC, function(input, output, size) {\n    var decoder = new RangeCoder(input);\n    decoder.decodeStart(true/* already read the extra byte */);\n    var blockSize = decoder.decodeByte();\n    console.assert(blockSize >= 1 && blockSize <= 9);\n    var fast = (blockSize <= 5);\n    blockSize *= 100000;\n\n    var block = Util.makeU8Buffer(blockSize);\n    var U = Util.makeU8Buffer(blockSize);\n    var A = Util.makeS32Buffer(blockSize);\n    var M = Util.makeU8Buffer(256); // move to front array\n    var bitModelFactory = NoModel.factory(decoder);\n    var lenModel = new LogDistanceModel(blockSize, 0,\n                                        bitModelFactory,\n                                        bitModelFactory);\n    var b, length, i, j, c;\n    while (true) {\n        var blockIndicator = decoder.decodeCulFreq(3);\n        decoder.decodeUpdate(1, blockIndicator, 3);\n        if (blockIndicator === 0) { // full-length block\n            length = blockSize;\n            b = block;\n        } else if (blockIndicator === 1) { // short block\n            length = lenModel.decode();\n            b = block.subarray(0, length);\n        } else if (blockIndicator === 2) { // all done, no more blocks\n            break;\n        }\n        // read starting index for unBWT\n        var pidx = lenModel.decode();\n        // decode the alphabet subset used\n        var useTree = Util.makeU16Buffer(512);\n        useTree[0] = 1; // sentinel\n        for (i=1; i<512; i++) {\n            var parent = i>>>1;\n            var full = 1 << (9-Util.fls(i));\n            if (useTree[parent] === 0 || useTree[parent] === (full*2)) {\n                /* already known full/empty */\n                useTree[i] = useTree[parent] >>> 1;\n            } else if (i >= 256) {\n                useTree[i] = decoder.decodeBit(); // leaf node\n            } else {\n                var v = decoder.decodeCulFreq(3);\n                decoder.decodeUpdate(1, v, 3);\n                useTree[i] = (v===2) ? full : v;\n            }\n        }\n        // remap symbols to this subset\n        var alphabetSize = 0;\n        for (i=0; i<256; i++) {\n            if (useTree[256+i]) { // symbol in use\n                M[alphabetSize++] = i;\n            }\n        }\n        useTree = null;\n        // RLE/range decoding\n        var model = new FenwickModel(decoder, alphabetSize+1,\n                                        F_PROB_MAX, F_PROB_INCR);\n        if (fast) { model = new DefSumModel(decoder, alphabetSize+1, true);}\n        var val = 1; // repeat count\n        for (i=0; i<length; ) {\n            c = model.decode();\n            if (c===0) {\n                for (j=0; j<val; j++) { b[i++] = 0; }\n                val *= 2;\n            } else if (c===1) {\n                for (j=0; j<val; j++) { b[i++] = 0; b[i++] = 0; }\n                val *= 2;\n            } else {\n                val = 1;\n                b[i++] = c-1;\n            }\n        }\n        // MTF decode\n        for (i=0; i<length; i++) {\n            j = b[i];\n            b[i] = c = M[j];\n            // move to front\n            for (; j>0; j--) {\n                M[j] = M[j-1];\n            }\n            M[0] = c;\n        }\n        // unBWT\n        BWT.unbwtransform(block, U, A, length, pidx);\n        // emit!\n        output.write(U, 0, length);\n    }\n    decoder.decodeFinish();\n});\n\nmodule.exports = BWTC;\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","const freeze = require('./lib/freeze');\nconst BitStream = require('./lib/BitStream');\nconst Stream = require('./lib/Stream');\nconst BWT = require('./lib/BWT');\nconst Context1Model = require('./lib/Context1Model');\nconst DefSumModel = require('./lib/DefSumModel');\nconst FenwickModel = require('./lib/FenwickModel');\nconst MTFModel = require('./lib/MTFModel');\nconst NoModel = require('./lib/NoModel');\nconst Huffman = require('./lib/Huffman');\nconst RangeCoder = require('./lib/RangeCoder');\nconst BWTC = require('./lib/BWTC');\nconst Bzip2 = require('./lib/Bzip2');\nconst Dmc = require('./lib/Dmc');\nconst Lzjb = require('./lib/Lzjb');\nconst LzjbR = require('./lib/LzjbR');\nconst Lzp3 = require('./lib/Lzp3');\nconst PPM = require('./lib/PPM');\nconst Simple = require('./lib/Simple');\n\nmodule.exports = freeze({\n    version: \"1.1.0\",\n    // APIs\n    BitStream: BitStream,\n    Stream: Stream,\n    // transforms\n    BWT: BWT,\n    // models and coder\n    Context1Model: Context1Model,\n    DefSumModel: DefSumModel,\n    FenwickModel: FenwickModel,\n    MTFModel: MTFModel,\n    NoModel: NoModel,\n    Huffman: Huffman,\n    RangeCoder: RangeCoder,\n    // compression methods\n    BWTC: BWTC,\n    Bzip2: Bzip2,\n    Dmc: Dmc,\n    Lzjb: Lzjb,\n    LzjbR: LzjbR,\n    Lzp3: Lzp3,\n    PPM: PPM,\n    Simple: Simple\n});\n","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\r\n} catch (e) {\r\n\t// This works if the window reference is available\r\n\tif (typeof window === \"object\") g = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n","<conditions-view>\n\t<div each={name, i in opts.conditions}>\n\t\t{name}\n\t</div>\n\t<script>\n\t\tvar self = this;\n\t</script>\n</conditions-view>","require('./person-view.tag');\n<contacts-view>\n    <person-view each={opts.people} person={this}/> \n</contacts-view>","require('./person-view.tag');\nrequire('./contacts-view.tag');\nrequire('./conditions-view.tag');\nrequire('./info-view.tag');\n<app-view>\n    <style>\n        app-view {\n            width: 100%;\n            height: 100%;\n            position: relative;\n            flex-direction: column;\n            display: flex;\n            overflow: hidden;\n        }\n        #content {\n            flex: 1;\n            background-color: lightgrey;\n            padding-left: 20px;\n            overflow: auto;\n        }\n        #content > * {\n            display: none;\n        }\n        ul li {\n            list-style-type: none;\n        }\n        ul {\n            margin: 0px;\n            padding: 0px;\n            background-color: blue;\n            display: flex;\n            height: 80px;\n        }\n        li {\n            height: 100%;\n            color: white;\n            display: block;\n            margin: 0px;\n            display: block;\n            width: 80px;\n        }\n        span.spacer {\n            flex: 1;\n        }\n        li > a {\n            display: block;\n            width: 100%;\n            height: 100%;\n            color: white;\n            text-align: center;            \n        }\n        .selectedButton {\n            background-color: lightblue;\n            border-top: 1px solid red;\n            padding-top: 2px;\n        }\n    </style>\n    <div id=\"content\">\n        <person-view id=\"self\" person={patient.self} />\n        <contacts-view id=\"contacts\" people={patient.contacts} />\n        <conditions-view id=\"conditions\" conditions={patient.conditions} />\n        <info-view id=\"info\" info={patient.info} />\n    </div>\n    <ul>\n        <span class=\"spacer\"/>\n        <li><a onclick={route} id=\"selfButton\">Self</a></li>\n        <li><a onclick={route} id=\"contactsButton\">Contacts</a></li>\n        <li><a onclick={route} id=\"conditionsButton\">Conditions</a></li>\n        <li><a onclick={route} id=\"infoButton\">Info</a></li>\n        <span class=\"spacer\"/>\n    </ul>\n    <script>\n        var self = this;\n        var patientcoder = require('../patientcoder');\n        var selected;\n        route (e) {\n            if(selected) {\n                document.getElementById(selected+'Button').classList.toggle('selectedButton');\n                document.getElementById(selected).style.display = \"none\";\n            }\n            var id = e.target.textContent.toLowerCase().trim();\n            selected = id;\n            document.getElementById(selected+'Button').classList.toggle('selectedButton');\n            document.getElementById(selected).style.display = \"block\";\n        }\n        self.on('mount', function () {\n            document.getElementById('selfButton').click();\n            self.update();\n        });\n        self.patient = parsePatient(window.location.href) || {\n                self: {\n                    name: \"Bob bob\",\n                    phone: \"1234567890\"\n                },\n                contacts: [\n                    {\n                        name: \"Jim jim\",\n                        phone: \"1237894560\"\n                    },\n                    {\n                        name: \"Joe joe\",\n                        phone: \"1231231234\"\n                    }\n                ],\n                conditions: [\n                    \"peanut allergy\",\n                    \"addiction to dank memes\"\n                ],\n                info: \"my favorite pie tastes like pumpkins\"\n        };\n        function parsePatient(href) {\n            var questionIdx = href.indexOf('?');\n            var strOfInterest = href.substring(questionIdx);\n            if(questionIdx == -1 || !strOfInterest) {\n                return undefined;\n            }\n            return patientcoder.makePatient(strOfInterest);\n        }\n    </script>\n</app-view>","require('./view/app-view.tag');\n//bad practice but i'm tired as fuck\nrequire('./edit/app-edit.tag');\nvar riot = require('riot');\n\nriot.mount('*');"],"sourceRoot":""}